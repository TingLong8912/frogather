{"ast":null,"code":"/**\n * Operators and utilities used for style expressions\n * @module ol/style/expressions\n */\n\nimport PaletteTexture from '../webgl/PaletteTexture.js';\nimport { Uniforms } from '../renderer/webgl/TileLayer.js';\nimport { asArray, fromString, isStringColor } from '../color.js';\n\n/**\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\n * which in turns takes {@link import(\"./expressions.js\").ExpressionValue} arguments.\n *\n * The following operators can be used:\n *\n * * Reading operators:\n *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band\n *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values\n *     are in the 0..1 range. {@link import(\"../source/TileImage.js\").default} sources have 4 bands: red,\n *     green, blue and alpha. {@link import(\"../source/DataTile.js\").default} sources can have any number\n *     of bands, depending on the underlying data source and\n *     {@link import(\"../source/GeoTIFF.js\").Options configuration}. `xOffset` and `yOffset` are optional\n *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels.\n *   * `['get', 'attributeName', typeHint]` fetches a feature property value, similar to `feature.get('attributeName')`\n *     A type hint can optionally be specified, in case the resulting expression contains a type ambiguity which\n *     will make it invalid. Type hints can be one of: 'string', 'color', 'number', 'boolean', 'number[]'\n *   * `['geometry-type']` returns a feature's geometry type as string, either: 'LineString', 'Point' or 'Polygon'\n *     `Multi*` values are returned as their singular equivalent\n *     `Circle` geometries are returned as 'Polygon'\n *     `GeometryCollection` geometries are returned as the type of the first geometry found in the collection\n *   * `['resolution']` returns the current resolution\n *   * `['time']` returns the time in seconds since the creation of the layer\n *   * `['var', 'varName']` fetches a value from the style variables; will throw an error if that variable is undefined\n *   * `['zoom']` returns the current zoom level\n *\n * * Math operators:\n *   * `['*', value1, value2, ...]` multiplies the values (either numbers or colors)\n *   * `['/', value1, value2]` divides `value1` by `value2`\n *   * `['+', value1, value2, ...]` adds the values\n *   * `['-', value1, value2]` subtracts `value2` from `value1`\n *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`\n *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\n *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\n *   * `['abs', value1]` returns the absolute value of `value1`\n *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`\n *   * `['round', value1]` returns the nearest integer to `value1`\n *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`\n *   * `['sin', value1]` returns the sine of `value1`\n *   * `['cos', value1]` returns the cosine of `value1`\n *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`\n *   * `['sqrt', value1]` returns the square root of `value1`\n *\n * * Transform operators:\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\n *     All conditions should be `boolean`, output and fallback can be any kind.\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\n *     returns the `fallback` value.\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\n *     `fallback` values must be of the same type, and can be of any kind.\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\n *     of 1 is equivalent to `['linear']`.\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\n *     between `output1` and `outputN`.\n *\n * * Logical operators:\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\n *     (inclusively), or `false` otherwise.\n *   * `['in', needle, haystack]` returns `true` if `needle` is found in `haystack`, and\n *     `false` otherwise.\n *     This operator has the following limitations:\n *     * `haystack` has to be an array of numbers or strings (searching for a substring in a string is not supported yet)\n *     * Only literal arrays are supported as `haystack` for now; this means that `haystack` cannot be the result of an\n *     expression. If `haystack` is an array of strings, use the `literal` operator to disambiguate from an expression:\n *     `['literal', ['abc', 'def', 'ghi']]`\n *\n * * Conversion operators:\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\n *     values can currently only be 2, 3 or 4.\n *   * `['color', red, green, blue, alpha]` creates a `color` value from `number` values; the `alpha` parameter is\n *     optional; if not specified, it will be set to 1.\n *     Note: `red`, `green` and `blue` components must be values between 0 and 255; `alpha` between 0 and 1.\n *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`\n *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors\n *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),\n *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b\n *     in the 0-255 range and a in the 0-1 range).\n *\n * Values can either be literals or another operator, as they will be evaluated recursively.\n * Literal values can be of the following types:\n * * `boolean`\n * * `number`\n * * `number[]` (number arrays can only have a length of 2, 3 or 4)\n * * `string`\n * * {@link module:ol/color~Color}\n *\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\n * @api\n */\n\n/**\n * Possible inferred types from a given value or expression.\n * Note: these are binary flags.\n * @enum {number}\n */\nexport const ValueTypes = {\n  NUMBER: 0b00001,\n  STRING: 0b00010,\n  COLOR: 0b00100,\n  BOOLEAN: 0b01000,\n  NUMBER_ARRAY: 0b10000,\n  ANY: 0b11111,\n  NONE: 0\n};\n\n/**\n * @param {string} typeHint Type hint\n * @return {ValueTypes} Resulting value type (will be a single type)\n */\nfunction getTypeFromHint(typeHint) {\n  switch (typeHint) {\n    case 'string':\n      return ValueTypes.STRING;\n    case 'color':\n      return ValueTypes.COLOR;\n    case 'number':\n      return ValueTypes.NUMBER;\n    case 'boolean':\n      return ValueTypes.BOOLEAN;\n    case 'number[]':\n      return ValueTypes.NUMBER_ARRAY;\n    default:\n      throw new Error(`Unrecognized type hint: ${typeHint}`);\n  }\n}\n\n/**\n * An operator declaration must contain two methods: `getReturnType` which returns a type based on\n * the operator arguments, and `toGlsl` which returns a GLSL-compatible string.\n * Note: both methods can process arguments recursively.\n * @typedef {Object} Operator\n * @property {function(Array<ExpressionValue>): ValueTypes|number} getReturnType Returns one or several types\n * @property {function(ParsingContext, Array<ExpressionValue>, ValueTypes): string} toGlsl Returns a GLSL-compatible string\n * given a parsing context, an array of arguments and an expected type.\n * Note: the expected type can be a combination such as ValueTypes.NUMBER | ValueTypes.STRING or ValueTypes.ANY for instance\n */\n\n/**\n * Operator declarations\n * @type {Object<string, Operator>}\n */\nexport const Operators = {};\n\n/**\n * Returns the possible types for a given value (each type being a binary flag)\n * To test a value use e.g. `getValueType(v) & ValueTypes.BOOLEAN`\n * @param {ExpressionValue} value Value\n * @return {ValueTypes|number} Type or types inferred from the value\n */\nexport function getValueType(value) {\n  if (typeof value === 'number') {\n    return ValueTypes.NUMBER;\n  }\n  if (typeof value === 'boolean') {\n    return ValueTypes.BOOLEAN;\n  }\n  if (typeof value === 'string') {\n    if (isStringColor(value)) {\n      return ValueTypes.COLOR | ValueTypes.STRING;\n    }\n    return ValueTypes.STRING;\n  }\n  if (!Array.isArray(value)) {\n    throw new Error(`Unhandled value type: ${JSON.stringify(value)}`);\n  }\n  const valueArr = /** @type {Array<*>} */value;\n  const onlyNumbers = valueArr.every(function (v) {\n    return typeof v === 'number';\n  });\n  if (onlyNumbers) {\n    if (valueArr.length === 3 || valueArr.length === 4) {\n      return ValueTypes.COLOR | ValueTypes.NUMBER_ARRAY;\n    }\n    return ValueTypes.NUMBER_ARRAY;\n  }\n  if (typeof valueArr[0] !== 'string') {\n    throw new Error(`Expected an expression operator but received: ${JSON.stringify(valueArr)}`);\n  }\n  const operator = Operators[valueArr[0]];\n  if (operator === undefined) {\n    throw new Error(`Unrecognized expression operator: ${JSON.stringify(valueArr)}`);\n  }\n  return operator.getReturnType(valueArr.slice(1));\n}\n\n/**\n * Checks if only one value type is enabled in the input number.\n * @param {ValueTypes|number} valueType Number containing value type binary flags\n * @return {boolean} True if only one type flag is enabled, false if zero or multiple\n */\nexport function isTypeUnique(valueType) {\n  return Math.log2(valueType) % 1 === 0;\n}\n\n/**\n * Print types as a readable string\n * @param {ValueTypes|number} valueType Number containing value type binary flags\n * @return {string} Types\n */\nfunction printTypes(valueType) {\n  const result = [];\n  if ((valueType & ValueTypes.NUMBER) > 0) {\n    result.push('number');\n  }\n  if ((valueType & ValueTypes.COLOR) > 0) {\n    result.push('color');\n  }\n  if ((valueType & ValueTypes.BOOLEAN) > 0) {\n    result.push('boolean');\n  }\n  if ((valueType & ValueTypes.NUMBER_ARRAY) > 0) {\n    result.push('number[]');\n  }\n  if ((valueType & ValueTypes.STRING) > 0) {\n    result.push('string');\n  }\n  return result.length > 0 ? result.join(', ') : '(no type)';\n}\n\n/**\n * @typedef {Object} ParsingContextExternal\n * @property {string} name Name, unprefixed\n * @property {ValueTypes} type One of the value types constants\n * @property {function(import(\"../Feature.js\").FeatureLike): *} [callback] Function used for computing the attribute value;\n *   if undefined, `feature.get(attribute.name)` will be used\n */\n\n/**\n * Context available during the parsing of an expression.\n * @typedef {Object} ParsingContext\n * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader\n * @property {Array<ParsingContextExternal>} variables External variables used in the expression\n * @property {Array<ParsingContextExternal>} attributes External attributes used in the expression\n * @property {Object<string, number>} stringLiteralsMap This object maps all encountered string values to a number\n * @property {Object<string, string>} functions Lookup of functions used by the style.\n * @property {number} [bandCount] Number of bands per pixel.\n * @property {Array<PaletteTexture>} [paletteTextures] List of palettes used by the style.\n * @property {import(\"../style/literal\").LiteralStyle} style The style being parsed\n */\n\n/**\n * @param {string} operator Operator\n * @param {ParsingContext} context Parsing context\n * @return {string} A function name based on the operator, unique in the given context\n */\nfunction computeOperatorFunctionName(operator, context) {\n  return `operator_${operator}_${Object.keys(context.functions).length}`;\n}\n\n/**\n * Will return the number as a float with a dot separator, which is required by GLSL.\n * @param {number} v Numerical value.\n * @return {string} The value as string.\n */\nexport function numberToGlsl(v) {\n  const s = v.toString();\n  return s.includes('.') ? s : s + '.0';\n}\n\n/**\n * Will return the number array as a float with a dot separator, concatenated with ', '.\n * @param {Array<number>} array Numerical values array.\n * @return {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.\n */\nexport function arrayToGlsl(array) {\n  if (array.length < 2 || array.length > 4) {\n    throw new Error('`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.');\n  }\n  return `vec${array.length}(${array.map(numberToGlsl).join(', ')})`;\n}\n\n/**\n * Will normalize and converts to string a `vec4` color array compatible with GLSL.\n * @param {string|import(\"../color.js\").Color} color Color either in string format or [r, g, b, a] array format,\n * with RGB components in the 0..255 range and the alpha component in the 0..1 range.\n * Note that the final array will always have 4 components.\n * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\n */\nexport function colorToGlsl(color) {\n  const array = asArray(color);\n  const alpha = array.length > 3 ? array[3] : 1;\n  // all components are premultiplied with alpha value\n  return arrayToGlsl([array[0] / 255 * alpha, array[1] / 255 * alpha, array[2] / 255 * alpha, alpha]);\n}\n\n/**\n * Returns a stable equivalent number for the string literal.\n * @param {ParsingContext} context Parsing context\n * @param {string} string String literal value\n * @return {number} Number equivalent\n */\nexport function getStringNumberEquivalent(context, string) {\n  if (context.stringLiteralsMap[string] === undefined) {\n    context.stringLiteralsMap[string] = Object.keys(context.stringLiteralsMap).length;\n  }\n  return context.stringLiteralsMap[string];\n}\n\n/**\n * Returns a stable equivalent number for the string literal, for use in shaders. This number is then\n * converted to be a GLSL-compatible string.\n * @param {ParsingContext} context Parsing context\n * @param {string} string String literal value\n * @return {string} GLSL-compatible string containing a number\n */\nexport function stringToGlsl(context, string) {\n  return numberToGlsl(getStringNumberEquivalent(context, string));\n}\n\n/**\n * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a parsing context that\n * will be read and modified during the parsing operation.\n * @param {ParsingContext} context Parsing context\n * @param {ExpressionValue} value Value\n * @param {ValueTypes|number} [expectedType] Expected final type (can be several types combined)\n * If omitted, defaults to ValueTypes.NUMBER\n * @return {string} GLSL-compatible output\n */\nexport function expressionToGlsl(context, value, expectedType) {\n  const returnType = expectedType !== undefined ? expectedType : ValueTypes.NUMBER;\n  // operator\n  if (Array.isArray(value) && typeof value[0] === 'string') {\n    const operator = Operators[value[0]];\n    if (operator === undefined) {\n      throw new Error(`Unrecognized expression operator: ${JSON.stringify(value)}`);\n    }\n    return operator.toGlsl(context, value.slice(1), returnType);\n  }\n  const possibleType = getValueType(value) & returnType;\n  assertNotEmptyType(value, possibleType, '');\n  if ((possibleType & ValueTypes.NUMBER) > 0) {\n    return numberToGlsl(/** @type {number} */value);\n  }\n  if ((possibleType & ValueTypes.BOOLEAN) > 0) {\n    return value.toString();\n  }\n  if ((possibleType & ValueTypes.STRING) > 0) {\n    return stringToGlsl(context, value.toString());\n  }\n  if ((possibleType & ValueTypes.COLOR) > 0) {\n    return colorToGlsl(/** @type {Array<number> | string} */value);\n  }\n  if ((possibleType & ValueTypes.NUMBER_ARRAY) > 0) {\n    return arrayToGlsl(/** @type {Array<number>} */value);\n  }\n  throw new Error(`Unexpected expression ${value} (expected type ${printTypes(returnType)})`);\n}\nfunction assertNumber(value) {\n  if ((getValueType(value) & ValueTypes.NUMBER) === 0) {\n    throw new Error(`A numeric value was expected, got ${JSON.stringify(value)} instead`);\n  }\n}\nfunction assertNumbers(values) {\n  for (let i = 0; i < values.length; i++) {\n    assertNumber(values[i]);\n  }\n}\nfunction assertString(value) {\n  if ((getValueType(value) & ValueTypes.STRING) === 0) {\n    throw new Error(`A string value was expected, got ${JSON.stringify(value)} instead`);\n  }\n}\nfunction assertBoolean(value) {\n  if ((getValueType(value) & ValueTypes.BOOLEAN) === 0) {\n    throw new Error(`A boolean value was expected, got ${JSON.stringify(value)} instead`);\n  }\n}\nfunction assertArgsCount(args, count) {\n  if (args.length !== count) {\n    throw new Error(`Exactly ${count} arguments were expected, got ${args.length} instead`);\n  }\n}\nfunction assertArgsMinCount(args, count) {\n  if (args.length < count) {\n    throw new Error(`At least ${count} arguments were expected, got ${args.length} instead`);\n  }\n}\nfunction assertArgsMaxCount(args, count) {\n  if (args.length > count) {\n    throw new Error(`At most ${count} arguments were expected, got ${args.length} instead`);\n  }\n}\nfunction assertArgsEven(args) {\n  if (args.length % 2 !== 0) {\n    throw new Error(`An even amount of arguments was expected, got ${JSON.stringify(args)} instead`);\n  }\n}\nfunction assertArgsOdd(args) {\n  if (args.length % 2 === 0) {\n    throw new Error(`An odd amount of arguments was expected, got ${JSON.stringify(args)} instead`);\n  }\n}\nfunction assertNotEmptyType(args, types, descriptor) {\n  if (types === ValueTypes.NONE) {\n    throw new Error(`No matching type was found for the following expression ${descriptor}: ${JSON.stringify(args)}`);\n  }\n}\nfunction assertSingleType(args, types, descriptor) {\n  assertNotEmptyType(args, types, descriptor);\n  if (!isTypeUnique(types)) {\n    throw new Error(`Expected to have a unique type for the following expression ${descriptor}: ${JSON.stringify(args)}\nGot the following types instead: ${printTypes(types)}`);\n  }\n}\nfunction assertOfType(args, types, expectedTypes, descriptor) {\n  if ((types & expectedTypes) === ValueTypes.NONE) {\n    throw new Error(`Expected the ${descriptor} type of the following expression: ${JSON.stringify(args)} to be of the following types: ${printTypes(expectedTypes)}\nGot these types instead: ${printTypes(types)}`);\n  }\n}\nOperators['get'] = {\n  getReturnType: function (args) {\n    if (args.length === 2) {\n      const hint = args[1];\n      return getTypeFromHint(/** @type {string} */hint);\n    }\n    return ValueTypes.ANY;\n  },\n  toGlsl: function (context, args, expectedType) {\n    assertArgsMinCount(args, 1);\n    assertArgsMaxCount(args, 2);\n    assertString(args[0]);\n    const outputType = expectedType & Operators['get'].getReturnType(args);\n    assertSingleType(['get', ...args], outputType, '');\n    const name = args[0].toString();\n    const existing = context.attributes.find(a => a.name === name);\n    if (!existing) {\n      context.attributes.push({\n        name: name,\n        type: outputType\n      });\n    } else if (outputType !== existing.type) {\n      throw new Error(`The following attribute was used in different places with incompatible types: ${name}\nTypes were: ${printTypes(existing.type)} and ${printTypes(outputType)}`);\n    }\n    const prefix = context.inFragmentShader ? 'v_' : 'a_';\n    return prefix + name;\n  }\n};\n\n/**\n * Get the uniform name given a variable name.\n * @param {string} variableName The variable name.\n * @return {string} The uniform name.\n */\nexport function uniformNameForVariable(variableName) {\n  return 'u_var_' + variableName;\n}\nOperators['var'] = {\n  getReturnType: function () {\n    return ValueTypes.ANY;\n  },\n  toGlsl: function (context, args, expectedType) {\n    assertArgsCount(args, 1);\n    assertString(args[0]);\n    const name = args[0].toString();\n    if (!context.style.variables || context.style.variables[name] === undefined) {\n      throw new Error(`The following variable is missing from the style: ${name}`);\n    }\n    const initialValue = context.style.variables[name];\n    const outputType = expectedType & getValueType(initialValue);\n    assertSingleType(['var', ...args], outputType, '');\n    const existing = context.variables.find(a => a.name === name);\n    if (!existing) {\n      context.variables.push({\n        name: name,\n        type: outputType\n      });\n    } else if (outputType !== existing.type) {\n      throw new Error(`The following variable was used in different places with incompatible types: ${name}\nTypes were: ${printTypes(existing.type)} and ${printTypes(outputType)}`);\n    }\n    return uniformNameForVariable(name);\n  }\n};\nexport const PALETTE_TEXTURE_ARRAY = 'u_paletteTextures';\n\n// ['palette', index, colors]\nOperators['palette'] = {\n  getReturnType: function () {\n    return ValueTypes.COLOR;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumber(args[0]);\n    const index = expressionToGlsl(context, args[0]);\n    const colors = args[1];\n    if (!Array.isArray(colors)) {\n      throw new Error('The second argument of palette must be an array');\n    }\n    const numColors = colors.length;\n    const palette = new Uint8Array(numColors * 4);\n    for (let i = 0; i < numColors; i++) {\n      const candidate = colors[i];\n      /**\n       * @type {import('../color.js').Color}\n       */\n      let color;\n      if (typeof candidate === 'string') {\n        color = fromString(candidate);\n      } else {\n        if (!Array.isArray(candidate)) {\n          throw new Error('The second argument of palette must be an array of strings or colors');\n        }\n        const length = candidate.length;\n        if (length === 4) {\n          color = candidate;\n        } else {\n          if (length !== 3) {\n            throw new Error(`Expected palette color to have 3 or 4 values, got ${length}`);\n          }\n          color = [candidate[0], candidate[1], candidate[2], 1];\n        }\n      }\n      const offset = i * 4;\n      palette[offset] = color[0];\n      palette[offset + 1] = color[1];\n      palette[offset + 2] = color[2];\n      palette[offset + 3] = color[3] * 255;\n    }\n    if (!context.paletteTextures) {\n      context.paletteTextures = [];\n    }\n    const paletteName = `${PALETTE_TEXTURE_ARRAY}[${context.paletteTextures.length}]`;\n    const paletteTexture = new PaletteTexture(paletteName, palette);\n    context.paletteTextures.push(paletteTexture);\n    return `texture2D(${paletteName}, vec2((${index} + 0.5) / ${numColors}.0, 0.5))`;\n  }\n};\nconst GET_BAND_VALUE_FUNC = 'getBandValue';\nOperators['band'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 1);\n    assertArgsMaxCount(args, 3);\n    const band = args[0];\n    if (!(GET_BAND_VALUE_FUNC in context.functions)) {\n      let ifBlocks = '';\n      const bandCount = context.bandCount || 1;\n      for (let i = 0; i < bandCount; i++) {\n        const colorIndex = Math.floor(i / 4);\n        let bandIndex = i % 4;\n        if (i === bandCount - 1 && bandIndex === 1) {\n          // LUMINANCE_ALPHA - band 1 assigned to rgb and band 2 assigned to alpha\n          bandIndex = 3;\n        }\n        const textureName = `${Uniforms.TILE_TEXTURE_ARRAY}[${colorIndex}]`;\n        ifBlocks += `\n          if (band == ${i + 1}.0) {\n            return texture2D(${textureName}, v_textureCoord + vec2(dx, dy))[${bandIndex}];\n          }\n        `;\n      }\n      context.functions[GET_BAND_VALUE_FUNC] = `\n        float getBandValue(float band, float xOffset, float yOffset) {\n          float dx = xOffset / ${Uniforms.TEXTURE_PIXEL_WIDTH};\n          float dy = yOffset / ${Uniforms.TEXTURE_PIXEL_HEIGHT};\n          ${ifBlocks}\n        }\n      `;\n    }\n    const bandExpression = expressionToGlsl(context, band);\n    const xOffsetExpression = expressionToGlsl(context, args[1] || 0);\n    const yOffsetExpression = expressionToGlsl(context, args[2] || 0);\n    return `${GET_BAND_VALUE_FUNC}(${bandExpression}, ${xOffsetExpression}, ${yOffsetExpression})`;\n  }\n};\nOperators['time'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_time';\n  }\n};\nOperators['zoom'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_zoom';\n  }\n};\nOperators['resolution'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_resolution';\n  }\n};\nOperators['geometry-type'] = {\n  getReturnType: function () {\n    return ValueTypes.STRING;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    const name = 'geometryType';\n    const computeType = geometry => {\n      const type = geometry.getType();\n      switch (type) {\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n          return type;\n        case 'MultiPoint':\n        case 'MultiLineString':\n        case 'MultiPolygon':\n          return type.substring(5);\n        case 'Circle':\n          return 'Polygon';\n        case 'GeometryCollection':\n          return computeType(geometry.getGeometries()[0]);\n        default:\n      }\n    };\n    const existing = context.attributes.find(a => a.name === name);\n    if (!existing) {\n      context.attributes.push({\n        name: name,\n        type: ValueTypes.STRING,\n        callback: feature => {\n          return computeType(feature.getGeometry());\n        }\n      });\n    }\n    const prefix = context.inFragmentShader ? 'v_' : 'a_';\n    return prefix + name;\n  }\n};\nOperators['*'] = {\n  getReturnType: function (args) {\n    let outputType = ValueTypes.NUMBER | ValueTypes.COLOR;\n    for (let i = 0; i < args.length; i++) {\n      outputType = outputType & getValueType(args[i]);\n    }\n    return outputType;\n  },\n  toGlsl: function (context, args, expectedType) {\n    assertArgsMinCount(args, 2);\n    let outputType = expectedType;\n    for (let i = 0; i < args.length; i++) {\n      outputType = outputType & getValueType(args[i]);\n    }\n    assertOfType(args, outputType, ValueTypes.NUMBER | ValueTypes.COLOR, 'output');\n    return `(${args.map(arg => expressionToGlsl(context, arg, outputType)).join(' * ')})`;\n  }\n};\nOperators['/'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} / ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['+'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 2);\n    assertNumbers(args);\n    return `(${args.map(arg => expressionToGlsl(context, arg)).join(' + ')})`;\n  }\n};\nOperators['-'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} - ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['clamp'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 3);\n    assertNumbers(args);\n    const min = expressionToGlsl(context, args[1]);\n    const max = expressionToGlsl(context, args[2]);\n    return `clamp(${expressionToGlsl(context, args[0])}, ${min}, ${max})`;\n  }\n};\nOperators['%'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `mod(${expressionToGlsl(context, args[0])}, ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['^'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `pow(${expressionToGlsl(context, args[0])}, ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['abs'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `abs(${expressionToGlsl(context, args[0])})`;\n  }\n};\nOperators['floor'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `floor(${expressionToGlsl(context, args[0])})`;\n  }\n};\nOperators['round'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `floor(${expressionToGlsl(context, args[0])} + 0.5)`;\n  }\n};\nOperators['ceil'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `ceil(${expressionToGlsl(context, args[0])})`;\n  }\n};\nOperators['sin'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `sin(${expressionToGlsl(context, args[0])})`;\n  }\n};\nOperators['cos'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `cos(${expressionToGlsl(context, args[0])})`;\n  }\n};\nOperators['atan'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 1);\n    assertArgsMaxCount(args, 2);\n    assertNumbers(args);\n    return args.length === 2 ? `atan(${expressionToGlsl(context, args[0])}, ${expressionToGlsl(context, args[1])})` : `atan(${expressionToGlsl(context, args[0])})`;\n  }\n};\nOperators['sqrt'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `sqrt(${expressionToGlsl(context, args[0])})`;\n  }\n};\nOperators['>'] = {\n  getReturnType: function () {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} > ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['>='] = {\n  getReturnType: function () {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} >= ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['<'] = {\n  getReturnType: function () {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} < ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['<='] = {\n  getReturnType: function () {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} <= ${expressionToGlsl(context, args[1])})`;\n  }\n};\nfunction getEqualOperator(operator) {\n  return {\n    getReturnType: function () {\n      return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n      assertArgsCount(args, 2);\n\n      // find common type\n      let type = ValueTypes.ANY;\n      for (let i = 0; i < args.length; i++) {\n        type &= getValueType(args[i]);\n      }\n      if (type === ValueTypes.NONE) {\n        throw new Error(`All arguments should be of compatible type, got ${JSON.stringify(args)} instead`);\n      }\n\n      // Since it's not possible to have color types here, we can leave it out\n      // This fixes issues in case the value type is ambiguously detected as a color (e.g. the string 'red')\n      type &= ~ValueTypes.COLOR;\n      return `(${expressionToGlsl(context, args[0], type)} ${operator} ${expressionToGlsl(context, args[1], type)})`;\n    }\n  };\n}\nOperators['=='] = getEqualOperator('==');\nOperators['!='] = getEqualOperator('!=');\nOperators['!'] = {\n  getReturnType: function () {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertBoolean(args[0]);\n    return `(!${expressionToGlsl(context, args[0], ValueTypes.BOOLEAN)})`;\n  }\n};\nfunction getDecisionOperator(operator) {\n  return {\n    getReturnType: function () {\n      return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n      assertArgsMinCount(args, 2);\n      for (let i = 0; i < args.length; i++) {\n        assertBoolean(args[i]);\n      }\n      let result = args.map(arg => expressionToGlsl(context, arg, ValueTypes.BOOLEAN)).join(` ${operator} `);\n      result = `(${result})`;\n      return result;\n    }\n  };\n}\nOperators['all'] = getDecisionOperator('&&');\nOperators['any'] = getDecisionOperator('||');\nOperators['between'] = {\n  getReturnType: function () {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 3);\n    assertNumbers(args);\n    const min = expressionToGlsl(context, args[1]);\n    const max = expressionToGlsl(context, args[2]);\n    const value = expressionToGlsl(context, args[0]);\n    return `(${value} >= ${min} && ${value} <= ${max})`;\n  }\n};\nOperators['array'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER_ARRAY;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 2);\n    assertArgsMaxCount(args, 4);\n    assertNumbers(args);\n    const parsedArgs = args.map(function (val) {\n      return expressionToGlsl(context, val);\n    });\n    return `vec${args.length}(${parsedArgs.join(', ')})`;\n  }\n};\nOperators['color'] = {\n  getReturnType: function () {\n    return ValueTypes.COLOR;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 3);\n    assertArgsMaxCount(args, 4);\n    assertNumbers(args);\n    const parsedArgs = args.slice(0, 3).map(val => `${expressionToGlsl(context, val)} / 255.0`);\n    if (args.length === 3) {\n      return `vec4(${parsedArgs.join(', ')}, 1.0)`;\n    }\n    const alpha = expressionToGlsl(context, args[3]);\n    return `(${alpha} * vec4(${parsedArgs.join(', ')}, 1.0))`;\n  }\n};\nOperators['interpolate'] = {\n  getReturnType: function (args) {\n    let type = ValueTypes.COLOR | ValueTypes.NUMBER;\n    for (let i = 3; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    return type;\n  },\n  toGlsl: function (context, args, expectedType) {\n    assertArgsEven(args);\n    assertArgsMinCount(args, 6);\n\n    // validate interpolation type\n    const type = args[0];\n    let interpolation;\n    switch (type[0]) {\n      case 'linear':\n        interpolation = 1;\n        break;\n      case 'exponential':\n        interpolation = type[1];\n        break;\n      default:\n        interpolation = null;\n    }\n    if (!interpolation) {\n      throw new Error(`Invalid interpolation type for \"interpolate\" operator, received: ${JSON.stringify(type)}`);\n    }\n\n    // compute input/output types\n    const inputType = ValueTypes.NUMBER;\n    const outputType = Operators['interpolate'].getReturnType(args) & expectedType;\n    assertSingleType(['interpolate', ...args], outputType, 'output');\n    const input = expressionToGlsl(context, args[1], inputType);\n    const exponent = numberToGlsl(interpolation);\n    let result = '';\n    for (let i = 2; i < args.length - 2; i += 2) {\n      const stop1 = expressionToGlsl(context, args[i], inputType);\n      const output1 = result || expressionToGlsl(context, args[i + 1], outputType);\n      const stop2 = expressionToGlsl(context, args[i + 2], inputType);\n      const output2 = expressionToGlsl(context, args[i + 3], outputType);\n      let ratio;\n      if (interpolation === 1) {\n        ratio = `(${input} - ${stop1}) / (${stop2} - ${stop1})`;\n      } else {\n        ratio = `(pow(${exponent}, (${input} - ${stop1})) - 1.0) / (pow(${exponent}, (${stop2} - ${stop1})) - 1.0)`;\n      }\n      result = `mix(${output1}, ${output2}, clamp(${ratio}, 0.0, 1.0))`;\n    }\n    return result;\n  }\n};\nOperators['match'] = {\n  getReturnType: function (args) {\n    let type = ValueTypes.ANY;\n    for (let i = 2; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    type = type & getValueType(args[args.length - 1]);\n    return type;\n  },\n  toGlsl: function (context, args, expectedType) {\n    assertArgsEven(args);\n    assertArgsMinCount(args, 4);\n    let inputType = getValueType(args[0]);\n    for (let i = 1; i < args.length - 1; i += 2) {\n      inputType = inputType & getValueType(args[i]);\n    }\n    assertOfType(['match', ...args], inputType, ValueTypes.STRING | ValueTypes.NUMBER | ValueTypes.BOOLEAN, 'input');\n    inputType = (ValueTypes.STRING | ValueTypes.NUMBER | ValueTypes.BOOLEAN) & inputType;\n    const outputType = Operators['match'].getReturnType(args) & expectedType;\n    assertSingleType(['match', ...args], outputType, 'output');\n    const input = expressionToGlsl(context, args[0], inputType);\n    const fallback = expressionToGlsl(context, args[args.length - 1], outputType);\n    let result = null;\n    for (let i = args.length - 3; i >= 1; i -= 2) {\n      const match = expressionToGlsl(context, args[i], inputType);\n      const output = expressionToGlsl(context, args[i + 1], outputType);\n      result = `(${input} == ${match} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  }\n};\nOperators['case'] = {\n  getReturnType: function (args) {\n    let type = ValueTypes.ANY;\n    for (let i = 1; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    type = type & getValueType(args[args.length - 1]);\n    return type;\n  },\n  toGlsl: function (context, args, expectedType) {\n    assertArgsOdd(args);\n    assertArgsMinCount(args, 3);\n    const outputType = Operators['case'].getReturnType(args) & expectedType;\n    assertSingleType(['case', ...args], outputType, 'output');\n    for (let i = 0; i < args.length - 1; i += 2) {\n      assertBoolean(args[i]);\n    }\n    const fallback = expressionToGlsl(context, args[args.length - 1], outputType);\n    let result = null;\n    for (let i = args.length - 3; i >= 0; i -= 2) {\n      const condition = expressionToGlsl(context, args[i], ValueTypes.BOOLEAN);\n      const output = expressionToGlsl(context, args[i + 1], outputType);\n      result = `(${condition} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  }\n};\nOperators['in'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    const needle = args[0];\n    let haystack = args[1];\n    if (!Array.isArray(haystack)) {\n      throw new Error(`The \"in\" operator expects an array literal as its second argument.`);\n    }\n    if (typeof haystack[0] === 'string') {\n      if (haystack[0] !== 'literal') {\n        throw new Error(`For the \"in\" operator, a string array should be wrapped in a \"literal\" operator to disambiguate from expressions.`);\n      }\n      if (!Array.isArray(haystack[1])) {\n        throw new Error(`The \"in\" operator was provided a literal value which was not an array as second argument.`);\n      }\n      haystack = haystack[1];\n    }\n    let inputType = getValueType(needle);\n    for (let i = 0; i < haystack.length - 1; i += 1) {\n      inputType = inputType & getValueType(haystack[i]);\n    }\n    assertOfType(['match', ...args], inputType, ValueTypes.STRING | ValueTypes.NUMBER | ValueTypes.BOOLEAN, 'input');\n    inputType = (ValueTypes.STRING | ValueTypes.NUMBER | ValueTypes.BOOLEAN) & inputType;\n    const funcName = computeOperatorFunctionName('in', context);\n    const tests = [];\n    for (let i = 0; i < haystack.length; i += 1) {\n      tests.push(`  if (inputValue == ${expressionToGlsl(context, haystack[i], inputType)}) { return true; }`);\n    }\n    context.functions[funcName] = `bool ${funcName}(float inputValue) {\n${tests.join('\\n')}\n  return false;\n}`;\n    return `${funcName}(${expressionToGlsl(context, needle, inputType)})`;\n  }\n};","map":{"version":3,"names":["PaletteTexture","Uniforms","asArray","fromString","isStringColor","ValueTypes","NUMBER","STRING","COLOR","BOOLEAN","NUMBER_ARRAY","ANY","NONE","getTypeFromHint","typeHint","Error","Operators","getValueType","value","Array","isArray","JSON","stringify","valueArr","onlyNumbers","every","v","length","operator","undefined","getReturnType","slice","isTypeUnique","valueType","Math","log2","printTypes","result","push","join","computeOperatorFunctionName","context","Object","keys","functions","numberToGlsl","s","toString","includes","arrayToGlsl","array","map","colorToGlsl","color","alpha","getStringNumberEquivalent","string","stringLiteralsMap","stringToGlsl","expressionToGlsl","expectedType","returnType","toGlsl","possibleType","assertNotEmptyType","assertNumber","assertNumbers","values","i","assertString","assertBoolean","assertArgsCount","args","count","assertArgsMinCount","assertArgsMaxCount","assertArgsEven","assertArgsOdd","types","descriptor","assertSingleType","assertOfType","expectedTypes","hint","outputType","name","existing","attributes","find","a","type","prefix","inFragmentShader","uniformNameForVariable","variableName","style","variables","initialValue","PALETTE_TEXTURE_ARRAY","index","colors","numColors","palette","Uint8Array","candidate","offset","paletteTextures","paletteName","paletteTexture","GET_BAND_VALUE_FUNC","band","ifBlocks","bandCount","colorIndex","floor","bandIndex","textureName","TILE_TEXTURE_ARRAY","TEXTURE_PIXEL_WIDTH","TEXTURE_PIXEL_HEIGHT","bandExpression","xOffsetExpression","yOffsetExpression","computeType","geometry","getType","substring","getGeometries","callback","feature","getGeometry","arg","min","max","getEqualOperator","getDecisionOperator","parsedArgs","val","interpolation","inputType","input","exponent","stop1","output1","stop2","output2","ratio","fallback","match","output","condition","needle","haystack","funcName","tests"],"sources":["/Users/yantinglong/Documents/project/frogather/node_modules/ol/style/expressions.js"],"sourcesContent":["/**\n * Operators and utilities used for style expressions\n * @module ol/style/expressions\n */\n\nimport PaletteTexture from '../webgl/PaletteTexture.js';\nimport {Uniforms} from '../renderer/webgl/TileLayer.js';\nimport {asArray, fromString, isStringColor} from '../color.js';\n\n/**\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\n * which in turns takes {@link import(\"./expressions.js\").ExpressionValue} arguments.\n *\n * The following operators can be used:\n *\n * * Reading operators:\n *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band\n *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values\n *     are in the 0..1 range. {@link import(\"../source/TileImage.js\").default} sources have 4 bands: red,\n *     green, blue and alpha. {@link import(\"../source/DataTile.js\").default} sources can have any number\n *     of bands, depending on the underlying data source and\n *     {@link import(\"../source/GeoTIFF.js\").Options configuration}. `xOffset` and `yOffset` are optional\n *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels.\n *   * `['get', 'attributeName', typeHint]` fetches a feature property value, similar to `feature.get('attributeName')`\n *     A type hint can optionally be specified, in case the resulting expression contains a type ambiguity which\n *     will make it invalid. Type hints can be one of: 'string', 'color', 'number', 'boolean', 'number[]'\n *   * `['geometry-type']` returns a feature's geometry type as string, either: 'LineString', 'Point' or 'Polygon'\n *     `Multi*` values are returned as their singular equivalent\n *     `Circle` geometries are returned as 'Polygon'\n *     `GeometryCollection` geometries are returned as the type of the first geometry found in the collection\n *   * `['resolution']` returns the current resolution\n *   * `['time']` returns the time in seconds since the creation of the layer\n *   * `['var', 'varName']` fetches a value from the style variables; will throw an error if that variable is undefined\n *   * `['zoom']` returns the current zoom level\n *\n * * Math operators:\n *   * `['*', value1, value2, ...]` multiplies the values (either numbers or colors)\n *   * `['/', value1, value2]` divides `value1` by `value2`\n *   * `['+', value1, value2, ...]` adds the values\n *   * `['-', value1, value2]` subtracts `value2` from `value1`\n *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`\n *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\n *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\n *   * `['abs', value1]` returns the absolute value of `value1`\n *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`\n *   * `['round', value1]` returns the nearest integer to `value1`\n *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`\n *   * `['sin', value1]` returns the sine of `value1`\n *   * `['cos', value1]` returns the cosine of `value1`\n *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`\n *   * `['sqrt', value1]` returns the square root of `value1`\n *\n * * Transform operators:\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\n *     All conditions should be `boolean`, output and fallback can be any kind.\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\n *     returns the `fallback` value.\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\n *     `fallback` values must be of the same type, and can be of any kind.\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\n *     of 1 is equivalent to `['linear']`.\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\n *     between `output1` and `outputN`.\n *\n * * Logical operators:\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\n *     (inclusively), or `false` otherwise.\n *   * `['in', needle, haystack]` returns `true` if `needle` is found in `haystack`, and\n *     `false` otherwise.\n *     This operator has the following limitations:\n *     * `haystack` has to be an array of numbers or strings (searching for a substring in a string is not supported yet)\n *     * Only literal arrays are supported as `haystack` for now; this means that `haystack` cannot be the result of an\n *     expression. If `haystack` is an array of strings, use the `literal` operator to disambiguate from an expression:\n *     `['literal', ['abc', 'def', 'ghi']]`\n *\n * * Conversion operators:\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\n *     values can currently only be 2, 3 or 4.\n *   * `['color', red, green, blue, alpha]` creates a `color` value from `number` values; the `alpha` parameter is\n *     optional; if not specified, it will be set to 1.\n *     Note: `red`, `green` and `blue` components must be values between 0 and 255; `alpha` between 0 and 1.\n *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`\n *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors\n *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),\n *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b\n *     in the 0-255 range and a in the 0-1 range).\n *\n * Values can either be literals or another operator, as they will be evaluated recursively.\n * Literal values can be of the following types:\n * * `boolean`\n * * `number`\n * * `number[]` (number arrays can only have a length of 2, 3 or 4)\n * * `string`\n * * {@link module:ol/color~Color}\n *\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\n * @api\n */\n\n/**\n * Possible inferred types from a given value or expression.\n * Note: these are binary flags.\n * @enum {number}\n */\nexport const ValueTypes = {\n  NUMBER: 0b00001,\n  STRING: 0b00010,\n  COLOR: 0b00100,\n  BOOLEAN: 0b01000,\n  NUMBER_ARRAY: 0b10000,\n  ANY: 0b11111,\n  NONE: 0,\n};\n\n/**\n * @param {string} typeHint Type hint\n * @return {ValueTypes} Resulting value type (will be a single type)\n */\nfunction getTypeFromHint(typeHint) {\n  switch (typeHint) {\n    case 'string':\n      return ValueTypes.STRING;\n    case 'color':\n      return ValueTypes.COLOR;\n    case 'number':\n      return ValueTypes.NUMBER;\n    case 'boolean':\n      return ValueTypes.BOOLEAN;\n    case 'number[]':\n      return ValueTypes.NUMBER_ARRAY;\n    default:\n      throw new Error(`Unrecognized type hint: ${typeHint}`);\n  }\n}\n\n/**\n * An operator declaration must contain two methods: `getReturnType` which returns a type based on\n * the operator arguments, and `toGlsl` which returns a GLSL-compatible string.\n * Note: both methods can process arguments recursively.\n * @typedef {Object} Operator\n * @property {function(Array<ExpressionValue>): ValueTypes|number} getReturnType Returns one or several types\n * @property {function(ParsingContext, Array<ExpressionValue>, ValueTypes): string} toGlsl Returns a GLSL-compatible string\n * given a parsing context, an array of arguments and an expected type.\n * Note: the expected type can be a combination such as ValueTypes.NUMBER | ValueTypes.STRING or ValueTypes.ANY for instance\n */\n\n/**\n * Operator declarations\n * @type {Object<string, Operator>}\n */\nexport const Operators = {};\n\n/**\n * Returns the possible types for a given value (each type being a binary flag)\n * To test a value use e.g. `getValueType(v) & ValueTypes.BOOLEAN`\n * @param {ExpressionValue} value Value\n * @return {ValueTypes|number} Type or types inferred from the value\n */\nexport function getValueType(value) {\n  if (typeof value === 'number') {\n    return ValueTypes.NUMBER;\n  }\n  if (typeof value === 'boolean') {\n    return ValueTypes.BOOLEAN;\n  }\n  if (typeof value === 'string') {\n    if (isStringColor(value)) {\n      return ValueTypes.COLOR | ValueTypes.STRING;\n    }\n    return ValueTypes.STRING;\n  }\n  if (!Array.isArray(value)) {\n    throw new Error(`Unhandled value type: ${JSON.stringify(value)}`);\n  }\n  const valueArr = /** @type {Array<*>} */ (value);\n  const onlyNumbers = valueArr.every(function (v) {\n    return typeof v === 'number';\n  });\n  if (onlyNumbers) {\n    if (valueArr.length === 3 || valueArr.length === 4) {\n      return ValueTypes.COLOR | ValueTypes.NUMBER_ARRAY;\n    }\n    return ValueTypes.NUMBER_ARRAY;\n  }\n  if (typeof valueArr[0] !== 'string') {\n    throw new Error(\n      `Expected an expression operator but received: ${JSON.stringify(\n        valueArr\n      )}`\n    );\n  }\n  const operator = Operators[valueArr[0]];\n  if (operator === undefined) {\n    throw new Error(\n      `Unrecognized expression operator: ${JSON.stringify(valueArr)}`\n    );\n  }\n  return operator.getReturnType(valueArr.slice(1));\n}\n\n/**\n * Checks if only one value type is enabled in the input number.\n * @param {ValueTypes|number} valueType Number containing value type binary flags\n * @return {boolean} True if only one type flag is enabled, false if zero or multiple\n */\nexport function isTypeUnique(valueType) {\n  return Math.log2(valueType) % 1 === 0;\n}\n\n/**\n * Print types as a readable string\n * @param {ValueTypes|number} valueType Number containing value type binary flags\n * @return {string} Types\n */\nfunction printTypes(valueType) {\n  const result = [];\n  if ((valueType & ValueTypes.NUMBER) > 0) {\n    result.push('number');\n  }\n  if ((valueType & ValueTypes.COLOR) > 0) {\n    result.push('color');\n  }\n  if ((valueType & ValueTypes.BOOLEAN) > 0) {\n    result.push('boolean');\n  }\n  if ((valueType & ValueTypes.NUMBER_ARRAY) > 0) {\n    result.push('number[]');\n  }\n  if ((valueType & ValueTypes.STRING) > 0) {\n    result.push('string');\n  }\n  return result.length > 0 ? result.join(', ') : '(no type)';\n}\n\n/**\n * @typedef {Object} ParsingContextExternal\n * @property {string} name Name, unprefixed\n * @property {ValueTypes} type One of the value types constants\n * @property {function(import(\"../Feature.js\").FeatureLike): *} [callback] Function used for computing the attribute value;\n *   if undefined, `feature.get(attribute.name)` will be used\n */\n\n/**\n * Context available during the parsing of an expression.\n * @typedef {Object} ParsingContext\n * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader\n * @property {Array<ParsingContextExternal>} variables External variables used in the expression\n * @property {Array<ParsingContextExternal>} attributes External attributes used in the expression\n * @property {Object<string, number>} stringLiteralsMap This object maps all encountered string values to a number\n * @property {Object<string, string>} functions Lookup of functions used by the style.\n * @property {number} [bandCount] Number of bands per pixel.\n * @property {Array<PaletteTexture>} [paletteTextures] List of palettes used by the style.\n * @property {import(\"../style/literal\").LiteralStyle} style The style being parsed\n */\n\n/**\n * @param {string} operator Operator\n * @param {ParsingContext} context Parsing context\n * @return {string} A function name based on the operator, unique in the given context\n */\nfunction computeOperatorFunctionName(operator, context) {\n  return `operator_${operator}_${Object.keys(context.functions).length}`;\n}\n\n/**\n * Will return the number as a float with a dot separator, which is required by GLSL.\n * @param {number} v Numerical value.\n * @return {string} The value as string.\n */\nexport function numberToGlsl(v) {\n  const s = v.toString();\n  return s.includes('.') ? s : s + '.0';\n}\n\n/**\n * Will return the number array as a float with a dot separator, concatenated with ', '.\n * @param {Array<number>} array Numerical values array.\n * @return {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.\n */\nexport function arrayToGlsl(array) {\n  if (array.length < 2 || array.length > 4) {\n    throw new Error(\n      '`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.'\n    );\n  }\n  return `vec${array.length}(${array.map(numberToGlsl).join(', ')})`;\n}\n\n/**\n * Will normalize and converts to string a `vec4` color array compatible with GLSL.\n * @param {string|import(\"../color.js\").Color} color Color either in string format or [r, g, b, a] array format,\n * with RGB components in the 0..255 range and the alpha component in the 0..1 range.\n * Note that the final array will always have 4 components.\n * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\n */\nexport function colorToGlsl(color) {\n  const array = asArray(color);\n  const alpha = array.length > 3 ? array[3] : 1;\n  // all components are premultiplied with alpha value\n  return arrayToGlsl([\n    (array[0] / 255) * alpha,\n    (array[1] / 255) * alpha,\n    (array[2] / 255) * alpha,\n    alpha,\n  ]);\n}\n\n/**\n * Returns a stable equivalent number for the string literal.\n * @param {ParsingContext} context Parsing context\n * @param {string} string String literal value\n * @return {number} Number equivalent\n */\nexport function getStringNumberEquivalent(context, string) {\n  if (context.stringLiteralsMap[string] === undefined) {\n    context.stringLiteralsMap[string] = Object.keys(\n      context.stringLiteralsMap\n    ).length;\n  }\n  return context.stringLiteralsMap[string];\n}\n\n/**\n * Returns a stable equivalent number for the string literal, for use in shaders. This number is then\n * converted to be a GLSL-compatible string.\n * @param {ParsingContext} context Parsing context\n * @param {string} string String literal value\n * @return {string} GLSL-compatible string containing a number\n */\nexport function stringToGlsl(context, string) {\n  return numberToGlsl(getStringNumberEquivalent(context, string));\n}\n\n/**\n * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a parsing context that\n * will be read and modified during the parsing operation.\n * @param {ParsingContext} context Parsing context\n * @param {ExpressionValue} value Value\n * @param {ValueTypes|number} [expectedType] Expected final type (can be several types combined)\n * If omitted, defaults to ValueTypes.NUMBER\n * @return {string} GLSL-compatible output\n */\nexport function expressionToGlsl(context, value, expectedType) {\n  const returnType =\n    expectedType !== undefined ? expectedType : ValueTypes.NUMBER;\n  // operator\n  if (Array.isArray(value) && typeof value[0] === 'string') {\n    const operator = Operators[value[0]];\n    if (operator === undefined) {\n      throw new Error(\n        `Unrecognized expression operator: ${JSON.stringify(value)}`\n      );\n    }\n    return operator.toGlsl(context, value.slice(1), returnType);\n  }\n\n  const possibleType = getValueType(value) & returnType;\n  assertNotEmptyType(value, possibleType, '');\n\n  if ((possibleType & ValueTypes.NUMBER) > 0) {\n    return numberToGlsl(/** @type {number} */ (value));\n  }\n\n  if ((possibleType & ValueTypes.BOOLEAN) > 0) {\n    return value.toString();\n  }\n\n  if ((possibleType & ValueTypes.STRING) > 0) {\n    return stringToGlsl(context, value.toString());\n  }\n\n  if ((possibleType & ValueTypes.COLOR) > 0) {\n    return colorToGlsl(/** @type {Array<number> | string} */ (value));\n  }\n\n  if ((possibleType & ValueTypes.NUMBER_ARRAY) > 0) {\n    return arrayToGlsl(/** @type {Array<number>} */ (value));\n  }\n\n  throw new Error(\n    `Unexpected expression ${value} (expected type ${printTypes(returnType)})`\n  );\n}\n\nfunction assertNumber(value) {\n  if ((getValueType(value) & ValueTypes.NUMBER) === 0) {\n    throw new Error(\n      `A numeric value was expected, got ${JSON.stringify(value)} instead`\n    );\n  }\n}\nfunction assertNumbers(values) {\n  for (let i = 0; i < values.length; i++) {\n    assertNumber(values[i]);\n  }\n}\nfunction assertString(value) {\n  if ((getValueType(value) & ValueTypes.STRING) === 0) {\n    throw new Error(\n      `A string value was expected, got ${JSON.stringify(value)} instead`\n    );\n  }\n}\nfunction assertBoolean(value) {\n  if ((getValueType(value) & ValueTypes.BOOLEAN) === 0) {\n    throw new Error(\n      `A boolean value was expected, got ${JSON.stringify(value)} instead`\n    );\n  }\n}\nfunction assertArgsCount(args, count) {\n  if (args.length !== count) {\n    throw new Error(\n      `Exactly ${count} arguments were expected, got ${args.length} instead`\n    );\n  }\n}\nfunction assertArgsMinCount(args, count) {\n  if (args.length < count) {\n    throw new Error(\n      `At least ${count} arguments were expected, got ${args.length} instead`\n    );\n  }\n}\nfunction assertArgsMaxCount(args, count) {\n  if (args.length > count) {\n    throw new Error(\n      `At most ${count} arguments were expected, got ${args.length} instead`\n    );\n  }\n}\nfunction assertArgsEven(args) {\n  if (args.length % 2 !== 0) {\n    throw new Error(\n      `An even amount of arguments was expected, got ${JSON.stringify(\n        args\n      )} instead`\n    );\n  }\n}\nfunction assertArgsOdd(args) {\n  if (args.length % 2 === 0) {\n    throw new Error(\n      `An odd amount of arguments was expected, got ${JSON.stringify(\n        args\n      )} instead`\n    );\n  }\n}\nfunction assertNotEmptyType(args, types, descriptor) {\n  if (types === ValueTypes.NONE) {\n    throw new Error(\n      `No matching type was found for the following expression ${descriptor}: ${JSON.stringify(\n        args\n      )}`\n    );\n  }\n}\nfunction assertSingleType(args, types, descriptor) {\n  assertNotEmptyType(args, types, descriptor);\n  if (!isTypeUnique(types)) {\n    throw new Error(\n      `Expected to have a unique type for the following expression ${descriptor}: ${JSON.stringify(\n        args\n      )}\nGot the following types instead: ${printTypes(types)}`\n    );\n  }\n}\nfunction assertOfType(args, types, expectedTypes, descriptor) {\n  if ((types & expectedTypes) === ValueTypes.NONE) {\n    throw new Error(\n      `Expected the ${descriptor} type of the following expression: ${JSON.stringify(\n        args\n      )} to be of the following types: ${printTypes(expectedTypes)}\nGot these types instead: ${printTypes(types)}`\n    );\n  }\n}\n\nOperators['get'] = {\n  getReturnType: function (args) {\n    if (args.length === 2) {\n      const hint = args[1];\n      return getTypeFromHint(/** @type {string} */ (hint));\n    }\n    return ValueTypes.ANY;\n  },\n  toGlsl: function (context, args, expectedType) {\n    assertArgsMinCount(args, 1);\n    assertArgsMaxCount(args, 2);\n    assertString(args[0]);\n    const outputType = expectedType & Operators['get'].getReturnType(args);\n    assertSingleType(['get', ...args], outputType, '');\n    const name = args[0].toString();\n    const existing = context.attributes.find((a) => a.name === name);\n    if (!existing) {\n      context.attributes.push({\n        name: name,\n        type: outputType,\n      });\n    } else if (outputType !== existing.type) {\n      throw new Error(\n        `The following attribute was used in different places with incompatible types: ${name}\nTypes were: ${printTypes(existing.type)} and ${printTypes(outputType)}`\n      );\n    }\n    const prefix = context.inFragmentShader ? 'v_' : 'a_';\n    return prefix + name;\n  },\n};\n\n/**\n * Get the uniform name given a variable name.\n * @param {string} variableName The variable name.\n * @return {string} The uniform name.\n */\nexport function uniformNameForVariable(variableName) {\n  return 'u_var_' + variableName;\n}\n\nOperators['var'] = {\n  getReturnType: function () {\n    return ValueTypes.ANY;\n  },\n  toGlsl: function (context, args, expectedType) {\n    assertArgsCount(args, 1);\n    assertString(args[0]);\n    const name = args[0].toString();\n    if (\n      !context.style.variables ||\n      context.style.variables[name] === undefined\n    ) {\n      throw new Error(\n        `The following variable is missing from the style: ${name}`\n      );\n    }\n    const initialValue = context.style.variables[name];\n    const outputType = expectedType & getValueType(initialValue);\n    assertSingleType(['var', ...args], outputType, '');\n    const existing = context.variables.find((a) => a.name === name);\n    if (!existing) {\n      context.variables.push({\n        name: name,\n        type: outputType,\n      });\n    } else if (outputType !== existing.type) {\n      throw new Error(\n        `The following variable was used in different places with incompatible types: ${name}\nTypes were: ${printTypes(existing.type)} and ${printTypes(outputType)}`\n      );\n    }\n    return uniformNameForVariable(name);\n  },\n};\n\nexport const PALETTE_TEXTURE_ARRAY = 'u_paletteTextures';\n\n// ['palette', index, colors]\nOperators['palette'] = {\n  getReturnType: function () {\n    return ValueTypes.COLOR;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumber(args[0]);\n    const index = expressionToGlsl(context, args[0]);\n    const colors = args[1];\n    if (!Array.isArray(colors)) {\n      throw new Error('The second argument of palette must be an array');\n    }\n    const numColors = colors.length;\n    const palette = new Uint8Array(numColors * 4);\n    for (let i = 0; i < numColors; i++) {\n      const candidate = colors[i];\n      /**\n       * @type {import('../color.js').Color}\n       */\n      let color;\n      if (typeof candidate === 'string') {\n        color = fromString(candidate);\n      } else {\n        if (!Array.isArray(candidate)) {\n          throw new Error(\n            'The second argument of palette must be an array of strings or colors'\n          );\n        }\n        const length = candidate.length;\n        if (length === 4) {\n          color = candidate;\n        } else {\n          if (length !== 3) {\n            throw new Error(\n              `Expected palette color to have 3 or 4 values, got ${length}`\n            );\n          }\n          color = [candidate[0], candidate[1], candidate[2], 1];\n        }\n      }\n      const offset = i * 4;\n      palette[offset] = color[0];\n      palette[offset + 1] = color[1];\n      palette[offset + 2] = color[2];\n      palette[offset + 3] = color[3] * 255;\n    }\n    if (!context.paletteTextures) {\n      context.paletteTextures = [];\n    }\n    const paletteName = `${PALETTE_TEXTURE_ARRAY}[${context.paletteTextures.length}]`;\n    const paletteTexture = new PaletteTexture(paletteName, palette);\n    context.paletteTextures.push(paletteTexture);\n    return `texture2D(${paletteName}, vec2((${index} + 0.5) / ${numColors}.0, 0.5))`;\n  },\n};\n\nconst GET_BAND_VALUE_FUNC = 'getBandValue';\n\nOperators['band'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 1);\n    assertArgsMaxCount(args, 3);\n    const band = args[0];\n\n    if (!(GET_BAND_VALUE_FUNC in context.functions)) {\n      let ifBlocks = '';\n      const bandCount = context.bandCount || 1;\n      for (let i = 0; i < bandCount; i++) {\n        const colorIndex = Math.floor(i / 4);\n        let bandIndex = i % 4;\n        if (i === bandCount - 1 && bandIndex === 1) {\n          // LUMINANCE_ALPHA - band 1 assigned to rgb and band 2 assigned to alpha\n          bandIndex = 3;\n        }\n        const textureName = `${Uniforms.TILE_TEXTURE_ARRAY}[${colorIndex}]`;\n        ifBlocks += `\n          if (band == ${i + 1}.0) {\n            return texture2D(${textureName}, v_textureCoord + vec2(dx, dy))[${bandIndex}];\n          }\n        `;\n      }\n\n      context.functions[GET_BAND_VALUE_FUNC] = `\n        float getBandValue(float band, float xOffset, float yOffset) {\n          float dx = xOffset / ${Uniforms.TEXTURE_PIXEL_WIDTH};\n          float dy = yOffset / ${Uniforms.TEXTURE_PIXEL_HEIGHT};\n          ${ifBlocks}\n        }\n      `;\n    }\n\n    const bandExpression = expressionToGlsl(context, band);\n    const xOffsetExpression = expressionToGlsl(context, args[1] || 0);\n    const yOffsetExpression = expressionToGlsl(context, args[2] || 0);\n    return `${GET_BAND_VALUE_FUNC}(${bandExpression}, ${xOffsetExpression}, ${yOffsetExpression})`;\n  },\n};\n\nOperators['time'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_time';\n  },\n};\n\nOperators['zoom'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_zoom';\n  },\n};\n\nOperators['resolution'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_resolution';\n  },\n};\n\nOperators['geometry-type'] = {\n  getReturnType: function () {\n    return ValueTypes.STRING;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    const name = 'geometryType';\n    const computeType = (geometry) => {\n      const type = geometry.getType();\n      switch (type) {\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n          return type;\n        case 'MultiPoint':\n        case 'MultiLineString':\n        case 'MultiPolygon':\n          return type.substring(5);\n        case 'Circle':\n          return 'Polygon';\n        case 'GeometryCollection':\n          return computeType(geometry.getGeometries()[0]);\n        default:\n      }\n    };\n    const existing = context.attributes.find((a) => a.name === name);\n    if (!existing) {\n      context.attributes.push({\n        name: name,\n        type: ValueTypes.STRING,\n        callback: (feature) => {\n          return computeType(feature.getGeometry());\n        },\n      });\n    }\n    const prefix = context.inFragmentShader ? 'v_' : 'a_';\n    return prefix + name;\n  },\n};\n\nOperators['*'] = {\n  getReturnType: function (args) {\n    let outputType = ValueTypes.NUMBER | ValueTypes.COLOR;\n    for (let i = 0; i < args.length; i++) {\n      outputType = outputType & getValueType(args[i]);\n    }\n    return outputType;\n  },\n  toGlsl: function (context, args, expectedType) {\n    assertArgsMinCount(args, 2);\n    let outputType = expectedType;\n    for (let i = 0; i < args.length; i++) {\n      outputType = outputType & getValueType(args[i]);\n    }\n    assertOfType(\n      args,\n      outputType,\n      ValueTypes.NUMBER | ValueTypes.COLOR,\n      'output'\n    );\n    return `(${args\n      .map((arg) => expressionToGlsl(context, arg, outputType))\n      .join(' * ')})`;\n  },\n};\n\nOperators['/'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} / ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['+'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 2);\n    assertNumbers(args);\n    return `(${args.map((arg) => expressionToGlsl(context, arg)).join(' + ')})`;\n  },\n};\n\nOperators['-'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} - ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['clamp'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 3);\n    assertNumbers(args);\n    const min = expressionToGlsl(context, args[1]);\n    const max = expressionToGlsl(context, args[2]);\n    return `clamp(${expressionToGlsl(context, args[0])}, ${min}, ${max})`;\n  },\n};\n\nOperators['%'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `mod(${expressionToGlsl(context, args[0])}, ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['^'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `pow(${expressionToGlsl(context, args[0])}, ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['abs'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `abs(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['floor'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `floor(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['round'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `floor(${expressionToGlsl(context, args[0])} + 0.5)`;\n  },\n};\n\nOperators['ceil'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `ceil(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['sin'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `sin(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['cos'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `cos(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['atan'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 1);\n    assertArgsMaxCount(args, 2);\n    assertNumbers(args);\n    return args.length === 2\n      ? `atan(${expressionToGlsl(context, args[0])}, ${expressionToGlsl(\n          context,\n          args[1]\n        )})`\n      : `atan(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['sqrt'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `sqrt(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['>'] = {\n  getReturnType: function () {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} > ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['>='] = {\n  getReturnType: function () {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} >= ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['<'] = {\n  getReturnType: function () {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} < ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['<='] = {\n  getReturnType: function () {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} <= ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nfunction getEqualOperator(operator) {\n  return {\n    getReturnType: function () {\n      return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n      assertArgsCount(args, 2);\n\n      // find common type\n      let type = ValueTypes.ANY;\n      for (let i = 0; i < args.length; i++) {\n        type &= getValueType(args[i]);\n      }\n      if (type === ValueTypes.NONE) {\n        throw new Error(\n          `All arguments should be of compatible type, got ${JSON.stringify(\n            args\n          )} instead`\n        );\n      }\n\n      // Since it's not possible to have color types here, we can leave it out\n      // This fixes issues in case the value type is ambiguously detected as a color (e.g. the string 'red')\n      type &= ~ValueTypes.COLOR;\n\n      return `(${expressionToGlsl(\n        context,\n        args[0],\n        type\n      )} ${operator} ${expressionToGlsl(context, args[1], type)})`;\n    },\n  };\n}\n\nOperators['=='] = getEqualOperator('==');\n\nOperators['!='] = getEqualOperator('!=');\n\nOperators['!'] = {\n  getReturnType: function () {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertBoolean(args[0]);\n    return `(!${expressionToGlsl(context, args[0], ValueTypes.BOOLEAN)})`;\n  },\n};\n\nfunction getDecisionOperator(operator) {\n  return {\n    getReturnType: function () {\n      return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n      assertArgsMinCount(args, 2);\n      for (let i = 0; i < args.length; i++) {\n        assertBoolean(args[i]);\n      }\n      let result = args\n        .map((arg) => expressionToGlsl(context, arg, ValueTypes.BOOLEAN))\n        .join(` ${operator} `);\n      result = `(${result})`;\n      return result;\n    },\n  };\n}\n\nOperators['all'] = getDecisionOperator('&&');\n\nOperators['any'] = getDecisionOperator('||');\n\nOperators['between'] = {\n  getReturnType: function () {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 3);\n    assertNumbers(args);\n    const min = expressionToGlsl(context, args[1]);\n    const max = expressionToGlsl(context, args[2]);\n    const value = expressionToGlsl(context, args[0]);\n    return `(${value} >= ${min} && ${value} <= ${max})`;\n  },\n};\n\nOperators['array'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER_ARRAY;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 2);\n    assertArgsMaxCount(args, 4);\n    assertNumbers(args);\n    const parsedArgs = args.map(function (val) {\n      return expressionToGlsl(context, val);\n    });\n    return `vec${args.length}(${parsedArgs.join(', ')})`;\n  },\n};\n\nOperators['color'] = {\n  getReturnType: function () {\n    return ValueTypes.COLOR;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 3);\n    assertArgsMaxCount(args, 4);\n    assertNumbers(args);\n    const parsedArgs = args\n      .slice(0, 3)\n      .map((val) => `${expressionToGlsl(context, val)} / 255.0`);\n    if (args.length === 3) {\n      return `vec4(${parsedArgs.join(', ')}, 1.0)`;\n    }\n    const alpha = expressionToGlsl(context, args[3]);\n    return `(${alpha} * vec4(${parsedArgs.join(', ')}, 1.0))`;\n  },\n};\n\nOperators['interpolate'] = {\n  getReturnType: function (args) {\n    let type = ValueTypes.COLOR | ValueTypes.NUMBER;\n    for (let i = 3; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    return type;\n  },\n  toGlsl: function (context, args, expectedType) {\n    assertArgsEven(args);\n    assertArgsMinCount(args, 6);\n\n    // validate interpolation type\n    const type = args[0];\n    let interpolation;\n    switch (type[0]) {\n      case 'linear':\n        interpolation = 1;\n        break;\n      case 'exponential':\n        interpolation = type[1];\n        break;\n      default:\n        interpolation = null;\n    }\n    if (!interpolation) {\n      throw new Error(\n        `Invalid interpolation type for \"interpolate\" operator, received: ${JSON.stringify(\n          type\n        )}`\n      );\n    }\n\n    // compute input/output types\n    const inputType = ValueTypes.NUMBER;\n    const outputType =\n      Operators['interpolate'].getReturnType(args) & expectedType;\n    assertSingleType(['interpolate', ...args], outputType, 'output');\n\n    const input = expressionToGlsl(context, args[1], inputType);\n    const exponent = numberToGlsl(interpolation);\n\n    let result = '';\n    for (let i = 2; i < args.length - 2; i += 2) {\n      const stop1 = expressionToGlsl(context, args[i], inputType);\n      const output1 =\n        result || expressionToGlsl(context, args[i + 1], outputType);\n      const stop2 = expressionToGlsl(context, args[i + 2], inputType);\n      const output2 = expressionToGlsl(context, args[i + 3], outputType);\n      let ratio;\n      if (interpolation === 1) {\n        ratio = `(${input} - ${stop1}) / (${stop2} - ${stop1})`;\n      } else {\n        ratio = `(pow(${exponent}, (${input} - ${stop1})) - 1.0) / (pow(${exponent}, (${stop2} - ${stop1})) - 1.0)`;\n      }\n      result = `mix(${output1}, ${output2}, clamp(${ratio}, 0.0, 1.0))`;\n    }\n    return result;\n  },\n};\n\nOperators['match'] = {\n  getReturnType: function (args) {\n    let type = ValueTypes.ANY;\n    for (let i = 2; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    type = type & getValueType(args[args.length - 1]);\n    return type;\n  },\n  toGlsl: function (context, args, expectedType) {\n    assertArgsEven(args);\n    assertArgsMinCount(args, 4);\n\n    let inputType = getValueType(args[0]);\n    for (let i = 1; i < args.length - 1; i += 2) {\n      inputType = inputType & getValueType(args[i]);\n    }\n    assertOfType(\n      ['match', ...args],\n      inputType,\n      ValueTypes.STRING | ValueTypes.NUMBER | ValueTypes.BOOLEAN,\n      'input'\n    );\n    inputType =\n      (ValueTypes.STRING | ValueTypes.NUMBER | ValueTypes.BOOLEAN) & inputType;\n\n    const outputType = Operators['match'].getReturnType(args) & expectedType;\n    assertSingleType(['match', ...args], outputType, 'output');\n\n    const input = expressionToGlsl(context, args[0], inputType);\n    const fallback = expressionToGlsl(\n      context,\n      args[args.length - 1],\n      outputType\n    );\n    let result = null;\n    for (let i = args.length - 3; i >= 1; i -= 2) {\n      const match = expressionToGlsl(context, args[i], inputType);\n      const output = expressionToGlsl(context, args[i + 1], outputType);\n      result = `(${input} == ${match} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  },\n};\n\nOperators['case'] = {\n  getReturnType: function (args) {\n    let type = ValueTypes.ANY;\n    for (let i = 1; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    type = type & getValueType(args[args.length - 1]);\n    return type;\n  },\n  toGlsl: function (context, args, expectedType) {\n    assertArgsOdd(args);\n    assertArgsMinCount(args, 3);\n\n    const outputType = Operators['case'].getReturnType(args) & expectedType;\n    assertSingleType(['case', ...args], outputType, 'output');\n    for (let i = 0; i < args.length - 1; i += 2) {\n      assertBoolean(args[i]);\n    }\n\n    const fallback = expressionToGlsl(\n      context,\n      args[args.length - 1],\n      outputType\n    );\n    let result = null;\n    for (let i = args.length - 3; i >= 0; i -= 2) {\n      const condition = expressionToGlsl(context, args[i], ValueTypes.BOOLEAN);\n      const output = expressionToGlsl(context, args[i + 1], outputType);\n      result = `(${condition} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  },\n};\n\nOperators['in'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    const needle = args[0];\n    let haystack = args[1];\n    if (!Array.isArray(haystack)) {\n      throw new Error(\n        `The \"in\" operator expects an array literal as its second argument.`\n      );\n    }\n    if (typeof haystack[0] === 'string') {\n      if (haystack[0] !== 'literal') {\n        throw new Error(\n          `For the \"in\" operator, a string array should be wrapped in a \"literal\" operator to disambiguate from expressions.`\n        );\n      }\n      if (!Array.isArray(haystack[1])) {\n        throw new Error(\n          `The \"in\" operator was provided a literal value which was not an array as second argument.`\n        );\n      }\n      haystack = haystack[1];\n    }\n\n    let inputType = getValueType(needle);\n    for (let i = 0; i < haystack.length - 1; i += 1) {\n      inputType = inputType & getValueType(haystack[i]);\n    }\n    assertOfType(\n      ['match', ...args],\n      inputType,\n      ValueTypes.STRING | ValueTypes.NUMBER | ValueTypes.BOOLEAN,\n      'input'\n    );\n    inputType =\n      (ValueTypes.STRING | ValueTypes.NUMBER | ValueTypes.BOOLEAN) & inputType;\n\n    const funcName = computeOperatorFunctionName('in', context);\n    const tests = [];\n    for (let i = 0; i < haystack.length; i += 1) {\n      tests.push(\n        `  if (inputValue == ${expressionToGlsl(\n          context,\n          haystack[i],\n          inputType\n        )}) { return true; }`\n      );\n    }\n    context.functions[funcName] = `bool ${funcName}(float inputValue) {\n${tests.join('\\n')}\n  return false;\n}`;\n    return `${funcName}(${expressionToGlsl(context, needle, inputType)})`;\n  },\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,OAAOA,cAAc,MAAM,4BAA4B;AACvD,SAAQC,QAAQ,QAAO,gCAAgC;AACvD,SAAQC,OAAO,EAAEC,UAAU,EAAEC,aAAa,QAAO,aAAa;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,UAAU,GAAG;EACxBC,MAAM,EAAE,OAAO;EACfC,MAAM,EAAE,OAAO;EACfC,KAAK,EAAE,OAAO;EACdC,OAAO,EAAE,OAAO;EAChBC,YAAY,EAAE,OAAO;EACrBC,GAAG,EAAE,OAAO;EACZC,IAAI,EAAE;AACR,CAAC;;AAED;AACA;AACA;AACA;AACA,SAASC,eAAeA,CAACC,QAAQ,EAAE;EACjC,QAAQA,QAAQ;IACd,KAAK,QAAQ;MACX,OAAOT,UAAU,CAACE,MAAM;IAC1B,KAAK,OAAO;MACV,OAAOF,UAAU,CAACG,KAAK;IACzB,KAAK,QAAQ;MACX,OAAOH,UAAU,CAACC,MAAM;IAC1B,KAAK,SAAS;MACZ,OAAOD,UAAU,CAACI,OAAO;IAC3B,KAAK,UAAU;MACb,OAAOJ,UAAU,CAACK,YAAY;IAChC;MACE,MAAM,IAAIK,KAAK,CAAC,2BAA2BD,QAAQ,EAAE,CAAC;EAC1D;AAC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","ignoreList":[]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"/**\n * @module ol/render/Feature\n */\nimport Feature from '../Feature.js';\nimport { LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon } from '../geom.js';\nimport { compose as composeTransform, create as createTransform } from '../transform.js';\nimport { createOrUpdateFromCoordinate, createOrUpdateFromFlatCoordinates, getCenter, getHeight } from '../extent.js';\nimport { extend } from '../array.js';\nimport { getInteriorPointOfArray, getInteriorPointsOfMultiArray } from '../geom/flat/interiorpoint.js';\nimport { get as getProjection } from '../proj.js';\nimport { inflateEnds } from '../geom/flat/orient.js';\nimport { interpolatePoint } from '../geom/flat/interpolate.js';\nimport { linearRingss as linearRingssCenter } from '../geom/flat/center.js';\nimport { transform2D } from '../geom/flat/transform.js';\n\n/**\n * @type {import(\"../transform.js\").Transform}\n */\nconst tmpTransform = createTransform();\n\n/**\n * Lightweight, read-only, {@link module:ol/Feature~Feature} and {@link module:ol/geom/Geometry~Geometry} like\n * structure, optimized for vector tile rendering and styling. Geometry access\n * through the API is limited to getting the type and extent of the geometry.\n */\nclass RenderFeature {\n  /**\n   * @param {import(\"../geom/Geometry.js\").Type} type Geometry type.\n   * @param {Array<number>} flatCoordinates Flat coordinates. These always need\n   *     to be right-handed for polygons.\n   * @param {Array<number>|Array<Array<number>>} ends Ends or Endss.\n   * @param {Object<string, *>} properties Properties.\n   * @param {number|string|undefined} id Feature id.\n   */\n  constructor(type, flatCoordinates, ends, properties, id) {\n    /**\n     * @type {import(\"../style/Style.js\").StyleFunction|undefined}\n     */\n    this.styleFunction;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent|undefined}\n     */\n    this.extent_;\n\n    /**\n     * @private\n     * @type {number|string|undefined}\n     */\n    this.id_ = id;\n\n    /**\n     * @private\n     * @type {import(\"../geom/Geometry.js\").Type}\n     */\n    this.type_ = type;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatCoordinates_ = flatCoordinates;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatInteriorPoints_ = null;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatMidpoints_ = null;\n\n    /**\n     * @private\n     * @type {Array<number>|Array<Array<number>>}\n     */\n    this.ends_ = ends;\n\n    /**\n     * @private\n     * @type {Object<string, *>}\n     */\n    this.properties_ = properties;\n  }\n\n  /**\n   * Get a feature property by its key.\n   * @param {string} key Key\n   * @return {*} Value for the requested key.\n   * @api\n   */\n  get(key) {\n    return this.properties_[key];\n  }\n\n  /**\n   * Get the extent of this feature's geometry.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getExtent() {\n    if (!this.extent_) {\n      this.extent_ = this.type_ === 'Point' ? createOrUpdateFromCoordinate(this.flatCoordinates_) : createOrUpdateFromFlatCoordinates(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2);\n    }\n    return this.extent_;\n  }\n\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  getFlatInteriorPoint() {\n    if (!this.flatInteriorPoints_) {\n      const flatCenter = getCenter(this.getExtent());\n      this.flatInteriorPoints_ = getInteriorPointOfArray(this.flatCoordinates_, 0, /** @type {Array<number>} */this.ends_, 2, flatCenter, 0);\n    }\n    return this.flatInteriorPoints_;\n  }\n\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  getFlatInteriorPoints() {\n    if (!this.flatInteriorPoints_) {\n      const flatCenters = linearRingssCenter(this.flatCoordinates_, 0, /** @type {Array<Array<number>>} */this.ends_, 2);\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.flatCoordinates_, 0, /** @type {Array<Array<number>>} */this.ends_, 2, flatCenters);\n    }\n    return this.flatInteriorPoints_;\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoint.\n   */\n  getFlatMidpoint() {\n    if (!this.flatMidpoints_) {\n      this.flatMidpoints_ = interpolatePoint(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, 0.5);\n    }\n    return this.flatMidpoints_;\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoints.\n   */\n  getFlatMidpoints() {\n    if (!this.flatMidpoints_) {\n      this.flatMidpoints_ = [];\n      const flatCoordinates = this.flatCoordinates_;\n      let offset = 0;\n      const ends = /** @type {Array<number>} */this.ends_;\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        const end = ends[i];\n        const midpoint = interpolatePoint(flatCoordinates, offset, end, 2, 0.5);\n        extend(this.flatMidpoints_, midpoint);\n        offset = end;\n      }\n    }\n    return this.flatMidpoints_;\n  }\n\n  /**\n   * Get the feature identifier.  This is a stable identifier for the feature and\n   * is set when reading data from a remote source.\n   * @return {number|string|undefined} Id.\n   * @api\n   */\n  getId() {\n    return this.id_;\n  }\n\n  /**\n   * @return {Array<number>} Flat coordinates.\n   */\n  getOrientedFlatCoordinates() {\n    return this.flatCoordinates_;\n  }\n\n  /**\n   * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when\n   * determining the geometry type in style function (see {@link #getType}).\n   * @return {RenderFeature} Feature.\n   * @api\n   */\n  getGeometry() {\n    return this;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {RenderFeature} Simplified geometry.\n   */\n  getSimplifiedGeometry(squaredTolerance) {\n    return this;\n  }\n\n  /**\n   * Get a transformed and simplified version of the geometry.\n   * @abstract\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\n   * @return {RenderFeature} Simplified geometry.\n   */\n  simplifyTransformed(squaredTolerance, transform) {\n    return this;\n  }\n\n  /**\n   * Get the feature properties.\n   * @return {Object<string, *>} Feature properties.\n   * @api\n   */\n  getProperties() {\n    return this.properties_;\n  }\n\n  /**\n   * @return {number} Stride.\n   */\n  getStride() {\n    return 2;\n  }\n\n  /**\n   * @return {import('../style/Style.js').StyleFunction|undefined} Style\n   */\n  getStyleFunction() {\n    return this.styleFunction;\n  }\n\n  /**\n   * Get the type of this feature's geometry.\n   * @return {import(\"../geom/Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return this.type_;\n  }\n\n  /**\n   * Transform geometry coordinates from tile pixel space to projected.\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} projection The data projection\n   */\n  transform(projection) {\n    projection = getProjection(projection);\n    const pixelExtent = projection.getExtent();\n    const projectedExtent = projection.getWorldExtent();\n    if (pixelExtent && projectedExtent) {\n      const scale = getHeight(projectedExtent) / getHeight(pixelExtent);\n      composeTransform(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);\n      transform2D(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, tmpTransform, this.flatCoordinates_);\n    }\n  }\n  /**\n   * @return {Array<number>|Array<Array<number>>} Ends or endss.\n   */\n  getEnds() {\n    return this.ends_;\n  }\n}\nRenderFeature.prototype.getEndss = RenderFeature.prototype.getEnds;\n\n/**\n * @return {Array<number>} Flat coordinates.\n */\nRenderFeature.prototype.getFlatCoordinates = RenderFeature.prototype.getOrientedFlatCoordinates;\n\n/**\n * Create a geometry from an `ol/render/Feature`\n * @param {RenderFeature} renderFeature\n * Render Feature\n * @return {Point|MultiPoint|LineString|MultiLineString|Polygon|MultiPolygon}\n * New geometry instance.\n * @api\n */\nexport function toGeometry(renderFeature) {\n  const geometryType = renderFeature.getType();\n  switch (geometryType) {\n    case 'Point':\n      return new Point(renderFeature.getFlatCoordinates());\n    case 'MultiPoint':\n      return new MultiPoint(renderFeature.getFlatCoordinates(), 'XY');\n    case 'LineString':\n      return new LineString(renderFeature.getFlatCoordinates(), 'XY');\n    case 'MultiLineString':\n      return new MultiLineString(renderFeature.getFlatCoordinates(), 'XY', /** @type {Array<number>} */renderFeature.getEnds());\n    case 'Polygon':\n      const flatCoordinates = renderFeature.getFlatCoordinates();\n      const ends = /** @type {Array<number>} */renderFeature.getEnds();\n      const endss = inflateEnds(flatCoordinates, ends);\n      return endss.length > 1 ? new MultiPolygon(flatCoordinates, 'XY', endss) : new Polygon(flatCoordinates, 'XY', ends);\n    default:\n      throw new Error('Invalid geometry type:' + geometryType);\n  }\n}\n\n/**\n * Create an `ol/Feature` from an `ol/render/Feature`\n * @param {RenderFeature} renderFeature RenderFeature\n * @param {string} [geometryName='geometry'] Geometry name to use\n * when creating the Feature.\n * @return {Feature} Newly constructed `ol/Feature` with properties,\n * geometry, and id copied over.\n * @api\n */\nexport function toFeature(renderFeature, geometryName) {\n  const id = renderFeature.getId();\n  const geometry = toGeometry(renderFeature);\n  const properties = renderFeature.getProperties();\n  const feature = new Feature();\n  if (geometryName !== undefined) {\n    feature.setGeometryName(geometryName);\n  }\n  feature.setGeometry(geometry);\n  if (id !== undefined) {\n    feature.setId(id);\n  }\n  feature.setProperties(properties, true);\n  return feature;\n}\nexport default RenderFeature;","map":{"version":3,"names":["Feature","LineString","MultiLineString","MultiPoint","MultiPolygon","Point","Polygon","compose","composeTransform","create","createTransform","createOrUpdateFromCoordinate","createOrUpdateFromFlatCoordinates","getCenter","getHeight","extend","getInteriorPointOfArray","getInteriorPointsOfMultiArray","get","getProjection","inflateEnds","interpolatePoint","linearRingss","linearRingssCenter","transform2D","tmpTransform","RenderFeature","constructor","type","flatCoordinates","ends","properties","id","styleFunction","extent_","id_","type_","flatCoordinates_","flatInteriorPoints_","flatMidpoints_","ends_","properties_","key","getExtent","length","getFlatInteriorPoint","flatCenter","getFlatInteriorPoints","flatCenters","getFlatMidpoint","getFlatMidpoints","offset","i","ii","end","midpoint","getId","getOrientedFlatCoordinates","getGeometry","getSimplifiedGeometry","squaredTolerance","simplifyTransformed","transform","getProperties","getStride","getStyleFunction","getType","projection","pixelExtent","projectedExtent","getWorldExtent","scale","getEnds","prototype","getEndss","getFlatCoordinates","toGeometry","renderFeature","geometryType","endss","Error","toFeature","geometryName","geometry","feature","undefined","setGeometryName","setGeometry","setId","setProperties"],"sources":["/Users/yantinglong/Documents/project/frogather/node_modules/ol/render/Feature.js"],"sourcesContent":["/**\n * @module ol/render/Feature\n */\nimport Feature from '../Feature.js';\nimport {\n  LineString,\n  MultiLineString,\n  MultiPoint,\n  MultiPolygon,\n  Point,\n  Polygon,\n} from '../geom.js';\nimport {\n  compose as composeTransform,\n  create as createTransform,\n} from '../transform.js';\nimport {\n  createOrUpdateFromCoordinate,\n  createOrUpdateFromFlatCoordinates,\n  getCenter,\n  getHeight,\n} from '../extent.js';\nimport {extend} from '../array.js';\nimport {\n  getInteriorPointOfArray,\n  getInteriorPointsOfMultiArray,\n} from '../geom/flat/interiorpoint.js';\nimport {get as getProjection} from '../proj.js';\nimport {inflateEnds} from '../geom/flat/orient.js';\nimport {interpolatePoint} from '../geom/flat/interpolate.js';\nimport {linearRingss as linearRingssCenter} from '../geom/flat/center.js';\nimport {transform2D} from '../geom/flat/transform.js';\n\n/**\n * @type {import(\"../transform.js\").Transform}\n */\nconst tmpTransform = createTransform();\n\n/**\n * Lightweight, read-only, {@link module:ol/Feature~Feature} and {@link module:ol/geom/Geometry~Geometry} like\n * structure, optimized for vector tile rendering and styling. Geometry access\n * through the API is limited to getting the type and extent of the geometry.\n */\nclass RenderFeature {\n  /**\n   * @param {import(\"../geom/Geometry.js\").Type} type Geometry type.\n   * @param {Array<number>} flatCoordinates Flat coordinates. These always need\n   *     to be right-handed for polygons.\n   * @param {Array<number>|Array<Array<number>>} ends Ends or Endss.\n   * @param {Object<string, *>} properties Properties.\n   * @param {number|string|undefined} id Feature id.\n   */\n  constructor(type, flatCoordinates, ends, properties, id) {\n    /**\n     * @type {import(\"../style/Style.js\").StyleFunction|undefined}\n     */\n    this.styleFunction;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent|undefined}\n     */\n    this.extent_;\n\n    /**\n     * @private\n     * @type {number|string|undefined}\n     */\n    this.id_ = id;\n\n    /**\n     * @private\n     * @type {import(\"../geom/Geometry.js\").Type}\n     */\n    this.type_ = type;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatCoordinates_ = flatCoordinates;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatInteriorPoints_ = null;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatMidpoints_ = null;\n\n    /**\n     * @private\n     * @type {Array<number>|Array<Array<number>>}\n     */\n    this.ends_ = ends;\n\n    /**\n     * @private\n     * @type {Object<string, *>}\n     */\n    this.properties_ = properties;\n  }\n\n  /**\n   * Get a feature property by its key.\n   * @param {string} key Key\n   * @return {*} Value for the requested key.\n   * @api\n   */\n  get(key) {\n    return this.properties_[key];\n  }\n\n  /**\n   * Get the extent of this feature's geometry.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getExtent() {\n    if (!this.extent_) {\n      this.extent_ =\n        this.type_ === 'Point'\n          ? createOrUpdateFromCoordinate(this.flatCoordinates_)\n          : createOrUpdateFromFlatCoordinates(\n              this.flatCoordinates_,\n              0,\n              this.flatCoordinates_.length,\n              2\n            );\n    }\n    return this.extent_;\n  }\n\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  getFlatInteriorPoint() {\n    if (!this.flatInteriorPoints_) {\n      const flatCenter = getCenter(this.getExtent());\n      this.flatInteriorPoints_ = getInteriorPointOfArray(\n        this.flatCoordinates_,\n        0,\n        /** @type {Array<number>} */ (this.ends_),\n        2,\n        flatCenter,\n        0\n      );\n    }\n    return this.flatInteriorPoints_;\n  }\n\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  getFlatInteriorPoints() {\n    if (!this.flatInteriorPoints_) {\n      const flatCenters = linearRingssCenter(\n        this.flatCoordinates_,\n        0,\n        /** @type {Array<Array<number>>} */ (this.ends_),\n        2\n      );\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(\n        this.flatCoordinates_,\n        0,\n        /** @type {Array<Array<number>>} */ (this.ends_),\n        2,\n        flatCenters\n      );\n    }\n    return this.flatInteriorPoints_;\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoint.\n   */\n  getFlatMidpoint() {\n    if (!this.flatMidpoints_) {\n      this.flatMidpoints_ = interpolatePoint(\n        this.flatCoordinates_,\n        0,\n        this.flatCoordinates_.length,\n        2,\n        0.5\n      );\n    }\n    return this.flatMidpoints_;\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoints.\n   */\n  getFlatMidpoints() {\n    if (!this.flatMidpoints_) {\n      this.flatMidpoints_ = [];\n      const flatCoordinates = this.flatCoordinates_;\n      let offset = 0;\n      const ends = /** @type {Array<number>} */ (this.ends_);\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        const end = ends[i];\n        const midpoint = interpolatePoint(flatCoordinates, offset, end, 2, 0.5);\n        extend(this.flatMidpoints_, midpoint);\n        offset = end;\n      }\n    }\n    return this.flatMidpoints_;\n  }\n\n  /**\n   * Get the feature identifier.  This is a stable identifier for the feature and\n   * is set when reading data from a remote source.\n   * @return {number|string|undefined} Id.\n   * @api\n   */\n  getId() {\n    return this.id_;\n  }\n\n  /**\n   * @return {Array<number>} Flat coordinates.\n   */\n  getOrientedFlatCoordinates() {\n    return this.flatCoordinates_;\n  }\n\n  /**\n   * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when\n   * determining the geometry type in style function (see {@link #getType}).\n   * @return {RenderFeature} Feature.\n   * @api\n   */\n  getGeometry() {\n    return this;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {RenderFeature} Simplified geometry.\n   */\n  getSimplifiedGeometry(squaredTolerance) {\n    return this;\n  }\n\n  /**\n   * Get a transformed and simplified version of the geometry.\n   * @abstract\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\n   * @return {RenderFeature} Simplified geometry.\n   */\n  simplifyTransformed(squaredTolerance, transform) {\n    return this;\n  }\n\n  /**\n   * Get the feature properties.\n   * @return {Object<string, *>} Feature properties.\n   * @api\n   */\n  getProperties() {\n    return this.properties_;\n  }\n\n  /**\n   * @return {number} Stride.\n   */\n  getStride() {\n    return 2;\n  }\n\n  /**\n   * @return {import('../style/Style.js').StyleFunction|undefined} Style\n   */\n  getStyleFunction() {\n    return this.styleFunction;\n  }\n\n  /**\n   * Get the type of this feature's geometry.\n   * @return {import(\"../geom/Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return this.type_;\n  }\n\n  /**\n   * Transform geometry coordinates from tile pixel space to projected.\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} projection The data projection\n   */\n  transform(projection) {\n    projection = getProjection(projection);\n    const pixelExtent = projection.getExtent();\n    const projectedExtent = projection.getWorldExtent();\n    if (pixelExtent && projectedExtent) {\n      const scale = getHeight(projectedExtent) / getHeight(pixelExtent);\n      composeTransform(\n        tmpTransform,\n        projectedExtent[0],\n        projectedExtent[3],\n        scale,\n        -scale,\n        0,\n        0,\n        0\n      );\n      transform2D(\n        this.flatCoordinates_,\n        0,\n        this.flatCoordinates_.length,\n        2,\n        tmpTransform,\n        this.flatCoordinates_\n      );\n    }\n  }\n  /**\n   * @return {Array<number>|Array<Array<number>>} Ends or endss.\n   */\n  getEnds() {\n    return this.ends_;\n  }\n}\n\nRenderFeature.prototype.getEndss = RenderFeature.prototype.getEnds;\n\n/**\n * @return {Array<number>} Flat coordinates.\n */\nRenderFeature.prototype.getFlatCoordinates =\n  RenderFeature.prototype.getOrientedFlatCoordinates;\n\n/**\n * Create a geometry from an `ol/render/Feature`\n * @param {RenderFeature} renderFeature\n * Render Feature\n * @return {Point|MultiPoint|LineString|MultiLineString|Polygon|MultiPolygon}\n * New geometry instance.\n * @api\n */\nexport function toGeometry(renderFeature) {\n  const geometryType = renderFeature.getType();\n  switch (geometryType) {\n    case 'Point':\n      return new Point(renderFeature.getFlatCoordinates());\n    case 'MultiPoint':\n      return new MultiPoint(renderFeature.getFlatCoordinates(), 'XY');\n    case 'LineString':\n      return new LineString(renderFeature.getFlatCoordinates(), 'XY');\n    case 'MultiLineString':\n      return new MultiLineString(\n        renderFeature.getFlatCoordinates(),\n        'XY',\n        /** @type {Array<number>} */ (renderFeature.getEnds())\n      );\n    case 'Polygon':\n      const flatCoordinates = renderFeature.getFlatCoordinates();\n      const ends = /** @type {Array<number>} */ (renderFeature.getEnds());\n      const endss = inflateEnds(flatCoordinates, ends);\n      return endss.length > 1\n        ? new MultiPolygon(flatCoordinates, 'XY', endss)\n        : new Polygon(flatCoordinates, 'XY', ends);\n    default:\n      throw new Error('Invalid geometry type:' + geometryType);\n  }\n}\n\n/**\n * Create an `ol/Feature` from an `ol/render/Feature`\n * @param {RenderFeature} renderFeature RenderFeature\n * @param {string} [geometryName='geometry'] Geometry name to use\n * when creating the Feature.\n * @return {Feature} Newly constructed `ol/Feature` with properties,\n * geometry, and id copied over.\n * @api\n */\nexport function toFeature(renderFeature, geometryName) {\n  const id = renderFeature.getId();\n  const geometry = toGeometry(renderFeature);\n  const properties = renderFeature.getProperties();\n  const feature = new Feature();\n  if (geometryName !== undefined) {\n    feature.setGeometryName(geometryName);\n  }\n  feature.setGeometry(geometry);\n  if (id !== undefined) {\n    feature.setId(id);\n  }\n  feature.setProperties(properties, true);\n  return feature;\n}\n\nexport default RenderFeature;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}
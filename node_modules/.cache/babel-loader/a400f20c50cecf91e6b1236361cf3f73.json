{"ast":null,"code":"/**\n * Class for generating shaders from literal style objects\n * @module ol/webgl/ShaderBuilder\n */\nimport { colorToGlsl, numberToGlsl } from '../style/expressions.js';\nimport { createDefaultStyle } from '../style/flat.js';\nconst BASE_UNIFORMS = `uniform mat4 u_projectionMatrix;\nuniform mat4 u_screenToWorldMatrix;\nuniform vec2 u_viewportSizePx;\nuniform float u_pixelRatio;\nuniform float u_globalAlpha;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\nuniform vec4 u_renderExtent;\nuniform mediump int u_hitDetection;\n`;\nconst DEFAULT_STYLE = createDefaultStyle();\n\n/**\n * @typedef {Object} VaryingDescription\n * @property {string} name Varying name, as will be declared in the header.\n * @property {string} type Varying type, either `float`, `vec2`, `vec4`...\n * @property {string} expression Expression which will be assigned to the varying in the vertex shader, and\n * passed on to the fragment shader.\n */\n\n/**\n * @classdesc\n * This class implements a classic builder pattern for generating many different types of shaders.\n * Methods can be chained, e. g.:\n *\n * ```js\n * const shader = new ShaderBuilder()\n *   .addVarying('v_width', 'float', 'a_width')\n *   .addUniform('u_time')\n *   .setColorExpression('...')\n *   .setSymbolSizeExpression('...')\n *   .outputSymbolFragmentShader();\n * ```\n */\nexport class ShaderBuilder {\n  constructor() {\n    /**\n     * Uniforms; these will be declared in the header (should include the type).\n     * @type {Array<string>}\n     * @private\n     */\n    this.uniforms_ = [];\n\n    /**\n     * Attributes; these will be declared in the header (should include the type).\n     * @type {Array<string>}\n     * @private\n     */\n    this.attributes_ = [];\n\n    /**\n     * Varyings with a name, a type and an expression.\n     * @type {Array<VaryingDescription>}\n     * @private\n     */\n    this.varyings_ = [];\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasSymbol_ = false;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.symbolSizeExpression_ = `vec2(${numberToGlsl(DEFAULT_STYLE['circle-radius'])})`;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.symbolRotationExpression_ = '0.0';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.symbolOffsetExpression_ = 'vec2(0.0)';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.symbolColorExpression_ = colorToGlsl(/** @type {string} */DEFAULT_STYLE['circle-fill-color']);\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.texCoordExpression_ = 'vec4(0.0, 0.0, 1.0, 1.0)';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.discardExpression_ = 'false';\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.symbolRotateWithView_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasStroke_ = false;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.strokeWidthExpression_ = numberToGlsl(DEFAULT_STYLE['stroke-width']);\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.strokeColorExpression_ = colorToGlsl(/** @type {string} */DEFAULT_STYLE['stroke-color']);\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasFill_ = false;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.fillColorExpression_ = colorToGlsl(/** @type {string} */DEFAULT_STYLE['fill-color']);\n\n    /**\n     * @type {Array<string>}\n     * @private\n     */\n    this.vertexShaderFunctions_ = [];\n\n    /**\n     * @type {Array<string>}\n     * @private\n     */\n    this.fragmentShaderFunctions_ = [];\n  }\n\n  /**\n   * Adds a uniform accessible in both fragment and vertex shaders.\n   * The given name should include a type, such as `sampler2D u_texture`.\n   * @param {string} name Uniform name\n   * @return {ShaderBuilder} the builder object\n   */\n  addUniform(name) {\n    this.uniforms_.push(name);\n    return this;\n  }\n\n  /**\n   * Adds an attribute accessible in the vertex shader, read from the geometry buffer.\n   * The given name should include a type, such as `vec2 a_position`.\n   * @param {string} name Attribute name\n   * @return {ShaderBuilder} the builder object\n   */\n  addAttribute(name) {\n    this.attributes_.push(name);\n    return this;\n  }\n\n  /**\n   * Adds a varying defined in the vertex shader and accessible from the fragment shader.\n   * The type and expression of the varying have to be specified separately.\n   * @param {string} name Varying name\n   * @param {'float'|'vec2'|'vec3'|'vec4'} type Type\n   * @param {string} expression Expression used to assign a value to the varying.\n   * @return {ShaderBuilder} the builder object\n   */\n  addVarying(name, type, expression) {\n    this.varyings_.push({\n      name: name,\n      type: type,\n      expression: expression\n    });\n    return this;\n  }\n\n  /**\n   * Sets an expression to compute the size of the shape.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec2` value.\n   * @param {string} expression Size expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setSymbolSizeExpression(expression) {\n    this.hasSymbol_ = true;\n    this.symbolSizeExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @return {string} The current symbol size expression\n   */\n  getSymbolSizeExpression() {\n    return this.symbolSizeExpression_;\n  }\n\n  /**\n   * Sets an expression to compute the rotation of the shape.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `float` value in radians.\n   * @param {string} expression Size expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setSymbolRotationExpression(expression) {\n    this.symbolRotationExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * Sets an expression to compute the offset of the symbol from the point center.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec2` value.\n   * @param {string} expression Offset expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setSymbolOffsetExpression(expression) {\n    this.symbolOffsetExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * Sets an expression to compute the color of the shape.\n   * This expression can use all the uniforms, varyings and attributes available\n   * in the fragment shader, and should evaluate to a `vec4` value.\n   * @param {string} expression Color expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setSymbolColorExpression(expression) {\n    this.hasSymbol_ = true;\n    this.symbolColorExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @return {string} The current symbol color expression\n   */\n  getSymbolColorExpression() {\n    return this.symbolColorExpression_;\n  }\n\n  /**\n   * Sets an expression to compute the texture coordinates of the vertices.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec4` value.\n   * @param {string} expression Texture coordinate expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setTextureCoordinateExpression(expression) {\n    this.texCoordExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * Sets an expression to determine whether a fragment (pixel) should be discarded,\n   * i.e. not drawn at all.\n   * This expression can use all the uniforms, varyings and attributes available\n   * in the fragment shader, and should evaluate to a `bool` value (it will be\n   * used in an `if` statement)\n   * @param {string} expression Fragment discard expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setFragmentDiscardExpression(expression) {\n    this.discardExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * Sets whether the symbols should rotate with the view or stay aligned with the map.\n   * Note: will only be used for point geometry shaders.\n   * @param {boolean} rotateWithView Rotate with view\n   * @return {ShaderBuilder} the builder object\n   */\n  setSymbolRotateWithView(rotateWithView) {\n    this.symbolRotateWithView_ = rotateWithView;\n    return this;\n  }\n\n  /**\n   * @param {string} expression Stroke width expression, returning value in pixels\n   * @return {ShaderBuilder} the builder object\n   */\n  setStrokeWidthExpression(expression) {\n    this.hasStroke_ = true;\n    this.strokeWidthExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @param {string} expression Stroke color expression, evaluate to `vec4`\n   * @return {ShaderBuilder} the builder object\n   */\n  setStrokeColorExpression(expression) {\n    this.hasStroke_ = true;\n    this.strokeColorExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @param {string} expression Fill color expression, evaluate to `vec4`\n   * @return {ShaderBuilder} the builder object\n   */\n  setFillColorExpression(expression) {\n    this.hasFill_ = true;\n    this.fillColorExpression_ = expression;\n    return this;\n  }\n  addVertexShaderFunction(code) {\n    if (this.vertexShaderFunctions_.includes(code)) {\n      return;\n    }\n    this.vertexShaderFunctions_.push(code);\n  }\n  addFragmentShaderFunction(code) {\n    if (this.fragmentShaderFunctions_.includes(code)) {\n      return;\n    }\n    this.fragmentShaderFunctions_.push(code);\n  }\n\n  /**\n   * Generates a symbol vertex shader from the builder parameters\n   *\n   * The following uniforms are hardcoded in all shaders: `u_projectionMatrix`, `u_offsetScaleMatrix`,\n   * `u_offsetRotateMatrix`, `u_time`, `u_zoom`, `u_resolution`, `u_hitDetection`.\n   *\n   * The following attributes are hardcoded and expected to be present in the vertex buffers:\n   * `vec2 a_position`, `float a_index` (being the index of the vertex in the quad, 0 to 3), `vec4 a_hitColor`.\n   *\n   * The following varyings are hardcoded and gives the coordinate of the pixel both in the quad and on the texture:\n   * `vec2 v_quadCoord`, `vec2 v_texCoord`, `vec4 v_hitColor`.\n   *\n   * @return {string|null} The full shader as a string; null if no size or color specified\n   */\n  getSymbolVertexShader() {\n    if (!this.hasSymbol_) {\n      return null;\n    }\n    const offsetMatrix = this.symbolRotateWithView_ ? 'u_offsetScaleMatrix * u_offsetRotateMatrix' : 'u_offsetScaleMatrix';\n    return `precision mediump float;\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\nuniform mediump int u_hitDetection;\n\n${this.uniforms_.map(function (uniform) {\n      return 'uniform ' + uniform + ';';\n    }).join('\\n')}\nattribute vec2 a_position;\nattribute float a_index;\nattribute vec4 a_hitColor;\n${this.attributes_.map(function (attribute) {\n      return 'attribute ' + attribute + ';';\n    }).join('\\n')}\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\nvarying vec4 v_hitColor;\n${this.varyings_.map(function (varying) {\n      return 'varying ' + varying.type + ' ' + varying.name + ';';\n    }).join('\\n')}\n${this.vertexShaderFunctions_.join('\\n')}\nvoid main(void) {\n  mat4 offsetMatrix = ${offsetMatrix};\n  vec2 halfSize = ${this.symbolSizeExpression_} * 0.5;\n  vec2 offset = ${this.symbolOffsetExpression_};\n  float angle = ${this.symbolRotationExpression_};\n  float offsetX;\n  float offsetY;\n  if (a_index == 0.0) {\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\n  } else if (a_index == 1.0) {\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\n  } else if (a_index == 2.0) {\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\n  } else {\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\n  }\n  vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n  vec4 texCoord = ${this.texCoordExpression_};\n  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;\n  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;\n  v_texCoord = vec2(u, v);\n  u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n  v = a_index == 2.0 || a_index == 3.0 ? 0.0 : 1.0;\n  v_quadCoord = vec2(u, v);\n  v_hitColor = a_hitColor;\n${this.varyings_.map(function (varying) {\n      return '  ' + varying.name + ' = ' + varying.expression + ';';\n    }).join('\\n')}\n}`;\n  }\n\n  /**\n   * Generates a symbol fragment shader from the builder parameters\n   *\n   * Expects the following varyings to be transmitted by the vertex shader:\n   * `vec2 v_quadCoord`, `vec2 v_texCoord`, `vec4 v_hitColor`.\n   *\n   * @return {string|null} The full shader as a string; null if no size or color specified\n   */\n  getSymbolFragmentShader() {\n    if (!this.hasSymbol_) {\n      return null;\n    }\n    return `precision mediump float;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\nuniform mediump int u_hitDetection;\n${this.uniforms_.map(function (uniform) {\n      return 'uniform ' + uniform + ';';\n    }).join('\\n')}\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\nvarying vec4 v_hitColor;\n${this.varyings_.map(function (varying) {\n      return 'varying ' + varying.type + ' ' + varying.name + ';';\n    }).join('\\n')}\n${this.fragmentShaderFunctions_.join('\\n')}\nvoid main(void) {\n  if (${this.discardExpression_}) { discard; }\n  gl_FragColor = ${this.symbolColorExpression_};\n  gl_FragColor.rgb *= gl_FragColor.a;\n  if (u_hitDetection > 0) {\n    if (gl_FragColor.a < 0.1) { discard; };\n    gl_FragColor = v_hitColor;\n  }\n}`;\n  }\n\n  /**\n   * Generates a stroke vertex shader from the builder parameters\n   * @return {string|null} The full shader as a string; null if no size or color specified\n   */\n  getStrokeVertexShader() {\n    if (!this.hasStroke_) {\n      return null;\n    }\n    return `#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n${BASE_UNIFORMS}\n${this.uniforms_.map(function (uniform) {\n      return 'uniform ' + uniform + ';';\n    }).join('\\n')}\nattribute vec2 a_position;\nattribute float a_index;\nattribute vec2 a_segmentStart;\nattribute vec2 a_segmentEnd;\nattribute float a_parameters;\nattribute vec4 a_hitColor;\n${this.attributes_.map(function (attribute) {\n      return 'attribute ' + attribute + ';';\n    }).join('\\n')}\nvarying vec2 v_segmentStart;\nvarying vec2 v_segmentEnd;\nvarying float v_angleStart;\nvarying float v_angleEnd;\nvarying float v_width;\nvarying vec4 v_hitColor;\n${this.varyings_.map(function (varying) {\n      return 'varying ' + varying.type + ' ' + varying.name + ';';\n    }).join('\\n')}\n${this.vertexShaderFunctions_.join('\\n')}\nvec2 worldToPx(vec2 worldPos) {\n  vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);\n  return (0.5 * screenPos.xy + 0.5) * u_viewportSizePx;\n}\n\nvec4 pxToScreen(vec2 pxPos) {\n  vec2 screenPos = pxPos * 4.0 / u_viewportSizePx;\n  return vec4(screenPos.xy, 0.0, 0.0);\n}\n\nvec2 getOffsetDirection(vec2 normalPx, vec2 tangentPx, float joinAngle) {\n  if (cos(joinAngle) > 0.93) return normalPx - tangentPx;\n  float halfAngle = joinAngle / 2.0;\n  vec2 angleBisectorNormal = vec2(\n    sin(halfAngle) * normalPx.x + cos(halfAngle) * normalPx.y,\n    -cos(halfAngle) * normalPx.x + sin(halfAngle) * normalPx.y\n  );\n  float length = 1.0 / sin(halfAngle);\n  return angleBisectorNormal * length;\n}\n\nvoid main(void) {\n  float lineWidth = ${this.strokeWidthExpression_};\n  float anglePrecision = 1500.0;\n  float paramShift = 10000.0;\n  v_angleStart = fract(a_parameters / paramShift) * paramShift / anglePrecision;\n  v_angleEnd = fract(floor(a_parameters / paramShift + 0.5) / paramShift) * paramShift / anglePrecision;\n  float vertexNumber = floor(a_parameters / paramShift / paramShift + 0.0001);\n  vec2 tangentPx = worldToPx(a_segmentEnd) - worldToPx(a_segmentStart);\n  tangentPx = normalize(tangentPx);\n  vec2 normalPx = vec2(-tangentPx.y, tangentPx.x);\n  float normalDir = vertexNumber < 0.5 || (vertexNumber > 1.5 && vertexNumber < 2.5) ? 1.0 : -1.0;\n  float tangentDir = vertexNumber < 1.5 ? 1.0 : -1.0;\n  float angle = vertexNumber < 1.5 ? v_angleStart : v_angleEnd;\n  vec2 offsetPx = getOffsetDirection(normalPx * normalDir, tangentDir * tangentPx, angle) * lineWidth * 0.5;\n  vec2 position =  vertexNumber < 1.5 ? a_segmentStart : a_segmentEnd;\n  gl_Position = u_projectionMatrix * vec4(position, 0.0, 1.0) + pxToScreen(offsetPx);\n  v_segmentStart = worldToPx(a_segmentStart);\n  v_segmentEnd = worldToPx(a_segmentEnd);\n  v_width = lineWidth;\n  v_hitColor = a_hitColor;\n${this.varyings_.map(function (varying) {\n      return '  ' + varying.name + ' = ' + varying.expression + ';';\n    }).join('\\n')}\n}`;\n  }\n\n  /**\n   * Generates a stroke fragment shader from the builder parameters\n   *\n   * @return {string|null} The full shader as a string; null if no size or color specified\n   */\n  getStrokeFragmentShader() {\n    if (!this.hasStroke_) {\n      return null;\n    }\n    return `#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n${BASE_UNIFORMS}\n${this.uniforms_.map(function (uniform) {\n      return 'uniform ' + uniform + ';';\n    }).join('\\n')}\nvarying vec2 v_segmentStart;\nvarying vec2 v_segmentEnd;\nvarying float v_angleStart;\nvarying float v_angleEnd;\nvarying float v_width;\nvarying vec4 v_hitColor;\n${this.varyings_.map(function (varying) {\n      return 'varying ' + varying.type + ' ' + varying.name + ';';\n    }).join('\\n')}\n${this.fragmentShaderFunctions_.join('\\n')}\nvec2 pxToWorld(vec2 pxPos) {\n  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;\n  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;\n}\n\nfloat segmentDistanceField(vec2 point, vec2 start, vec2 end, float radius) {\n  vec2 startToPoint = point - start;\n  vec2 startToEnd = end - start;\n  float ratio = clamp(dot(startToPoint, startToEnd) / dot(startToEnd, startToEnd), 0.0, 1.0);\n  float dist = length(startToPoint - ratio * startToEnd);\n  return 1.0 - smoothstep(radius - 1.0, radius, dist);\n}\n\nvoid main(void) {\n  vec2 v_currentPoint = gl_FragCoord.xy / u_pixelRatio;\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n  vec2 v_worldPos = pxToWorld(v_currentPoint);\n  if (\n    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (\n      v_worldPos[0] < u_renderExtent[0] ||\n      v_worldPos[1] < u_renderExtent[1] ||\n      v_worldPos[0] > u_renderExtent[2] ||\n      v_worldPos[1] > u_renderExtent[3]\n    )\n  ) {\n    discard;\n  }\n  #endif\n  if (${this.discardExpression_}) { discard; }\n  gl_FragColor = ${this.strokeColorExpression_} * u_globalAlpha;\n  gl_FragColor *= segmentDistanceField(v_currentPoint, v_segmentStart, v_segmentEnd, v_width);\n  if (u_hitDetection > 0) {\n    if (gl_FragColor.a < 0.1) { discard; };\n    gl_FragColor = v_hitColor;\n  }\n}`;\n  }\n\n  /**\n   * Generates a fill vertex shader from the builder parameters\n   *\n   * @return {string|null} The full shader as a string; null if no color specified\n   */\n  getFillVertexShader() {\n    if (!this.hasFill_) {\n      return null;\n    }\n    return `#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n${BASE_UNIFORMS}\n${this.uniforms_.map(function (uniform) {\n      return 'uniform ' + uniform + ';';\n    }).join('\\n')}\nattribute vec2 a_position;\nattribute vec4 a_hitColor;\n${this.attributes_.map(function (attribute) {\n      return 'attribute ' + attribute + ';';\n    }).join('\\n')}\nvarying vec4 v_hitColor;\n${this.varyings_.map(function (varying) {\n      return 'varying ' + varying.type + ' ' + varying.name + ';';\n    }).join('\\n')}\n${this.vertexShaderFunctions_.join('\\n')}\nvoid main(void) {\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\n${this.varyings_.map(function (varying) {\n      return '  ' + varying.name + ' = ' + varying.expression + ';';\n    }).join('\\n')}\n}`;\n  }\n\n  /**\n   * Generates a fill fragment shader from the builder parameters\n   * @return {string|null} The full shader as a string; null if no color specified\n   */\n  getFillFragmentShader() {\n    if (!this.hasFill_) {\n      return null;\n    }\n    return `#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n${BASE_UNIFORMS}\n${this.uniforms_.map(function (uniform) {\n      return 'uniform ' + uniform + ';';\n    }).join('\\n')}\nvarying vec4 v_hitColor;\n${this.varyings_.map(function (varying) {\n      return 'varying ' + varying.type + ' ' + varying.name + ';';\n    }).join('\\n')}\n${this.fragmentShaderFunctions_.join('\\n')}\nvec2 pxToWorld(vec2 pxPos) {\n  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;\n  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;\n}\n\nvoid main(void) {\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n  vec2 v_worldPos = pxToWorld(gl_FragCoord.xy / u_pixelRatio);\n  if (\n    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (\n      v_worldPos[0] < u_renderExtent[0] ||\n      v_worldPos[1] < u_renderExtent[1] ||\n      v_worldPos[0] > u_renderExtent[2] ||\n      v_worldPos[1] > u_renderExtent[3]\n    )\n  ) {\n    discard;\n  }\n  #endif\n  if (${this.discardExpression_}) { discard; }\n  gl_FragColor = ${this.fillColorExpression_} * u_globalAlpha;\n  if (u_hitDetection > 0) {\n    if (gl_FragColor.a < 0.1) { discard; };\n    gl_FragColor = v_hitColor;\n  }\n}`;\n  }\n}","map":{"version":3,"names":["colorToGlsl","numberToGlsl","createDefaultStyle","BASE_UNIFORMS","DEFAULT_STYLE","ShaderBuilder","constructor","uniforms_","attributes_","varyings_","hasSymbol_","symbolSizeExpression_","symbolRotationExpression_","symbolOffsetExpression_","symbolColorExpression_","texCoordExpression_","discardExpression_","symbolRotateWithView_","hasStroke_","strokeWidthExpression_","strokeColorExpression_","hasFill_","fillColorExpression_","vertexShaderFunctions_","fragmentShaderFunctions_","addUniform","name","push","addAttribute","addVarying","type","expression","setSymbolSizeExpression","getSymbolSizeExpression","setSymbolRotationExpression","setSymbolOffsetExpression","setSymbolColorExpression","getSymbolColorExpression","setTextureCoordinateExpression","setFragmentDiscardExpression","setSymbolRotateWithView","rotateWithView","setStrokeWidthExpression","setStrokeColorExpression","setFillColorExpression","addVertexShaderFunction","code","includes","addFragmentShaderFunction","getSymbolVertexShader","offsetMatrix","map","uniform","join","attribute","varying","getSymbolFragmentShader","getStrokeVertexShader","getStrokeFragmentShader","getFillVertexShader","getFillFragmentShader"],"sources":["/Users/yantinglong/Documents/project/frogather/node_modules/ol/webgl/ShaderBuilder.js"],"sourcesContent":["/**\n * Class for generating shaders from literal style objects\n * @module ol/webgl/ShaderBuilder\n */\nimport {colorToGlsl, numberToGlsl} from '../style/expressions.js';\nimport {createDefaultStyle} from '../style/flat.js';\n\nconst BASE_UNIFORMS = `uniform mat4 u_projectionMatrix;\nuniform mat4 u_screenToWorldMatrix;\nuniform vec2 u_viewportSizePx;\nuniform float u_pixelRatio;\nuniform float u_globalAlpha;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\nuniform vec4 u_renderExtent;\nuniform mediump int u_hitDetection;\n`;\n\nconst DEFAULT_STYLE = createDefaultStyle();\n\n/**\n * @typedef {Object} VaryingDescription\n * @property {string} name Varying name, as will be declared in the header.\n * @property {string} type Varying type, either `float`, `vec2`, `vec4`...\n * @property {string} expression Expression which will be assigned to the varying in the vertex shader, and\n * passed on to the fragment shader.\n */\n\n/**\n * @classdesc\n * This class implements a classic builder pattern for generating many different types of shaders.\n * Methods can be chained, e. g.:\n *\n * ```js\n * const shader = new ShaderBuilder()\n *   .addVarying('v_width', 'float', 'a_width')\n *   .addUniform('u_time')\n *   .setColorExpression('...')\n *   .setSymbolSizeExpression('...')\n *   .outputSymbolFragmentShader();\n * ```\n */\nexport class ShaderBuilder {\n  constructor() {\n    /**\n     * Uniforms; these will be declared in the header (should include the type).\n     * @type {Array<string>}\n     * @private\n     */\n    this.uniforms_ = [];\n\n    /**\n     * Attributes; these will be declared in the header (should include the type).\n     * @type {Array<string>}\n     * @private\n     */\n    this.attributes_ = [];\n\n    /**\n     * Varyings with a name, a type and an expression.\n     * @type {Array<VaryingDescription>}\n     * @private\n     */\n    this.varyings_ = [];\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasSymbol_ = false;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.symbolSizeExpression_ = `vec2(${numberToGlsl(\n      DEFAULT_STYLE['circle-radius']\n    )})`;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.symbolRotationExpression_ = '0.0';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.symbolOffsetExpression_ = 'vec2(0.0)';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.symbolColorExpression_ = colorToGlsl(\n      /** @type {string} */ (DEFAULT_STYLE['circle-fill-color'])\n    );\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.texCoordExpression_ = 'vec4(0.0, 0.0, 1.0, 1.0)';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.discardExpression_ = 'false';\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.symbolRotateWithView_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasStroke_ = false;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.strokeWidthExpression_ = numberToGlsl(DEFAULT_STYLE['stroke-width']);\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.strokeColorExpression_ = colorToGlsl(\n      /** @type {string} */ (DEFAULT_STYLE['stroke-color'])\n    );\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasFill_ = false;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.fillColorExpression_ = colorToGlsl(\n      /** @type {string} */ (DEFAULT_STYLE['fill-color'])\n    );\n\n    /**\n     * @type {Array<string>}\n     * @private\n     */\n    this.vertexShaderFunctions_ = [];\n\n    /**\n     * @type {Array<string>}\n     * @private\n     */\n    this.fragmentShaderFunctions_ = [];\n  }\n\n  /**\n   * Adds a uniform accessible in both fragment and vertex shaders.\n   * The given name should include a type, such as `sampler2D u_texture`.\n   * @param {string} name Uniform name\n   * @return {ShaderBuilder} the builder object\n   */\n  addUniform(name) {\n    this.uniforms_.push(name);\n    return this;\n  }\n\n  /**\n   * Adds an attribute accessible in the vertex shader, read from the geometry buffer.\n   * The given name should include a type, such as `vec2 a_position`.\n   * @param {string} name Attribute name\n   * @return {ShaderBuilder} the builder object\n   */\n  addAttribute(name) {\n    this.attributes_.push(name);\n    return this;\n  }\n\n  /**\n   * Adds a varying defined in the vertex shader and accessible from the fragment shader.\n   * The type and expression of the varying have to be specified separately.\n   * @param {string} name Varying name\n   * @param {'float'|'vec2'|'vec3'|'vec4'} type Type\n   * @param {string} expression Expression used to assign a value to the varying.\n   * @return {ShaderBuilder} the builder object\n   */\n  addVarying(name, type, expression) {\n    this.varyings_.push({\n      name: name,\n      type: type,\n      expression: expression,\n    });\n    return this;\n  }\n\n  /**\n   * Sets an expression to compute the size of the shape.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec2` value.\n   * @param {string} expression Size expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setSymbolSizeExpression(expression) {\n    this.hasSymbol_ = true;\n    this.symbolSizeExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @return {string} The current symbol size expression\n   */\n  getSymbolSizeExpression() {\n    return this.symbolSizeExpression_;\n  }\n\n  /**\n   * Sets an expression to compute the rotation of the shape.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `float` value in radians.\n   * @param {string} expression Size expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setSymbolRotationExpression(expression) {\n    this.symbolRotationExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * Sets an expression to compute the offset of the symbol from the point center.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec2` value.\n   * @param {string} expression Offset expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setSymbolOffsetExpression(expression) {\n    this.symbolOffsetExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * Sets an expression to compute the color of the shape.\n   * This expression can use all the uniforms, varyings and attributes available\n   * in the fragment shader, and should evaluate to a `vec4` value.\n   * @param {string} expression Color expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setSymbolColorExpression(expression) {\n    this.hasSymbol_ = true;\n    this.symbolColorExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @return {string} The current symbol color expression\n   */\n  getSymbolColorExpression() {\n    return this.symbolColorExpression_;\n  }\n\n  /**\n   * Sets an expression to compute the texture coordinates of the vertices.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec4` value.\n   * @param {string} expression Texture coordinate expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setTextureCoordinateExpression(expression) {\n    this.texCoordExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * Sets an expression to determine whether a fragment (pixel) should be discarded,\n   * i.e. not drawn at all.\n   * This expression can use all the uniforms, varyings and attributes available\n   * in the fragment shader, and should evaluate to a `bool` value (it will be\n   * used in an `if` statement)\n   * @param {string} expression Fragment discard expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setFragmentDiscardExpression(expression) {\n    this.discardExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * Sets whether the symbols should rotate with the view or stay aligned with the map.\n   * Note: will only be used for point geometry shaders.\n   * @param {boolean} rotateWithView Rotate with view\n   * @return {ShaderBuilder} the builder object\n   */\n  setSymbolRotateWithView(rotateWithView) {\n    this.symbolRotateWithView_ = rotateWithView;\n    return this;\n  }\n\n  /**\n   * @param {string} expression Stroke width expression, returning value in pixels\n   * @return {ShaderBuilder} the builder object\n   */\n  setStrokeWidthExpression(expression) {\n    this.hasStroke_ = true;\n    this.strokeWidthExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @param {string} expression Stroke color expression, evaluate to `vec4`\n   * @return {ShaderBuilder} the builder object\n   */\n  setStrokeColorExpression(expression) {\n    this.hasStroke_ = true;\n    this.strokeColorExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @param {string} expression Fill color expression, evaluate to `vec4`\n   * @return {ShaderBuilder} the builder object\n   */\n  setFillColorExpression(expression) {\n    this.hasFill_ = true;\n    this.fillColorExpression_ = expression;\n    return this;\n  }\n\n  addVertexShaderFunction(code) {\n    if (this.vertexShaderFunctions_.includes(code)) {\n      return;\n    }\n    this.vertexShaderFunctions_.push(code);\n  }\n  addFragmentShaderFunction(code) {\n    if (this.fragmentShaderFunctions_.includes(code)) {\n      return;\n    }\n    this.fragmentShaderFunctions_.push(code);\n  }\n\n  /**\n   * Generates a symbol vertex shader from the builder parameters\n   *\n   * The following uniforms are hardcoded in all shaders: `u_projectionMatrix`, `u_offsetScaleMatrix`,\n   * `u_offsetRotateMatrix`, `u_time`, `u_zoom`, `u_resolution`, `u_hitDetection`.\n   *\n   * The following attributes are hardcoded and expected to be present in the vertex buffers:\n   * `vec2 a_position`, `float a_index` (being the index of the vertex in the quad, 0 to 3), `vec4 a_hitColor`.\n   *\n   * The following varyings are hardcoded and gives the coordinate of the pixel both in the quad and on the texture:\n   * `vec2 v_quadCoord`, `vec2 v_texCoord`, `vec4 v_hitColor`.\n   *\n   * @return {string|null} The full shader as a string; null if no size or color specified\n   */\n  getSymbolVertexShader() {\n    if (!this.hasSymbol_) {\n      return null;\n    }\n\n    const offsetMatrix = this.symbolRotateWithView_\n      ? 'u_offsetScaleMatrix * u_offsetRotateMatrix'\n      : 'u_offsetScaleMatrix';\n\n    return `precision mediump float;\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\nuniform mediump int u_hitDetection;\n\n${this.uniforms_\n  .map(function (uniform) {\n    return 'uniform ' + uniform + ';';\n  })\n  .join('\\n')}\nattribute vec2 a_position;\nattribute float a_index;\nattribute vec4 a_hitColor;\n${this.attributes_\n  .map(function (attribute) {\n    return 'attribute ' + attribute + ';';\n  })\n  .join('\\n')}\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\nvarying vec4 v_hitColor;\n${this.varyings_\n  .map(function (varying) {\n    return 'varying ' + varying.type + ' ' + varying.name + ';';\n  })\n  .join('\\n')}\n${this.vertexShaderFunctions_.join('\\n')}\nvoid main(void) {\n  mat4 offsetMatrix = ${offsetMatrix};\n  vec2 halfSize = ${this.symbolSizeExpression_} * 0.5;\n  vec2 offset = ${this.symbolOffsetExpression_};\n  float angle = ${this.symbolRotationExpression_};\n  float offsetX;\n  float offsetY;\n  if (a_index == 0.0) {\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\n  } else if (a_index == 1.0) {\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\n  } else if (a_index == 2.0) {\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\n  } else {\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\n  }\n  vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n  vec4 texCoord = ${this.texCoordExpression_};\n  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;\n  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;\n  v_texCoord = vec2(u, v);\n  u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n  v = a_index == 2.0 || a_index == 3.0 ? 0.0 : 1.0;\n  v_quadCoord = vec2(u, v);\n  v_hitColor = a_hitColor;\n${this.varyings_\n  .map(function (varying) {\n    return '  ' + varying.name + ' = ' + varying.expression + ';';\n  })\n  .join('\\n')}\n}`;\n  }\n\n  /**\n   * Generates a symbol fragment shader from the builder parameters\n   *\n   * Expects the following varyings to be transmitted by the vertex shader:\n   * `vec2 v_quadCoord`, `vec2 v_texCoord`, `vec4 v_hitColor`.\n   *\n   * @return {string|null} The full shader as a string; null if no size or color specified\n   */\n  getSymbolFragmentShader() {\n    if (!this.hasSymbol_) {\n      return null;\n    }\n\n    return `precision mediump float;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\nuniform mediump int u_hitDetection;\n${this.uniforms_\n  .map(function (uniform) {\n    return 'uniform ' + uniform + ';';\n  })\n  .join('\\n')}\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\nvarying vec4 v_hitColor;\n${this.varyings_\n  .map(function (varying) {\n    return 'varying ' + varying.type + ' ' + varying.name + ';';\n  })\n  .join('\\n')}\n${this.fragmentShaderFunctions_.join('\\n')}\nvoid main(void) {\n  if (${this.discardExpression_}) { discard; }\n  gl_FragColor = ${this.symbolColorExpression_};\n  gl_FragColor.rgb *= gl_FragColor.a;\n  if (u_hitDetection > 0) {\n    if (gl_FragColor.a < 0.1) { discard; };\n    gl_FragColor = v_hitColor;\n  }\n}`;\n  }\n\n  /**\n   * Generates a stroke vertex shader from the builder parameters\n   * @return {string|null} The full shader as a string; null if no size or color specified\n   */\n  getStrokeVertexShader() {\n    if (!this.hasStroke_) {\n      return null;\n    }\n\n    return `#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n${BASE_UNIFORMS}\n${this.uniforms_\n  .map(function (uniform) {\n    return 'uniform ' + uniform + ';';\n  })\n  .join('\\n')}\nattribute vec2 a_position;\nattribute float a_index;\nattribute vec2 a_segmentStart;\nattribute vec2 a_segmentEnd;\nattribute float a_parameters;\nattribute vec4 a_hitColor;\n${this.attributes_\n  .map(function (attribute) {\n    return 'attribute ' + attribute + ';';\n  })\n  .join('\\n')}\nvarying vec2 v_segmentStart;\nvarying vec2 v_segmentEnd;\nvarying float v_angleStart;\nvarying float v_angleEnd;\nvarying float v_width;\nvarying vec4 v_hitColor;\n${this.varyings_\n  .map(function (varying) {\n    return 'varying ' + varying.type + ' ' + varying.name + ';';\n  })\n  .join('\\n')}\n${this.vertexShaderFunctions_.join('\\n')}\nvec2 worldToPx(vec2 worldPos) {\n  vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);\n  return (0.5 * screenPos.xy + 0.5) * u_viewportSizePx;\n}\n\nvec4 pxToScreen(vec2 pxPos) {\n  vec2 screenPos = pxPos * 4.0 / u_viewportSizePx;\n  return vec4(screenPos.xy, 0.0, 0.0);\n}\n\nvec2 getOffsetDirection(vec2 normalPx, vec2 tangentPx, float joinAngle) {\n  if (cos(joinAngle) > 0.93) return normalPx - tangentPx;\n  float halfAngle = joinAngle / 2.0;\n  vec2 angleBisectorNormal = vec2(\n    sin(halfAngle) * normalPx.x + cos(halfAngle) * normalPx.y,\n    -cos(halfAngle) * normalPx.x + sin(halfAngle) * normalPx.y\n  );\n  float length = 1.0 / sin(halfAngle);\n  return angleBisectorNormal * length;\n}\n\nvoid main(void) {\n  float lineWidth = ${this.strokeWidthExpression_};\n  float anglePrecision = 1500.0;\n  float paramShift = 10000.0;\n  v_angleStart = fract(a_parameters / paramShift) * paramShift / anglePrecision;\n  v_angleEnd = fract(floor(a_parameters / paramShift + 0.5) / paramShift) * paramShift / anglePrecision;\n  float vertexNumber = floor(a_parameters / paramShift / paramShift + 0.0001);\n  vec2 tangentPx = worldToPx(a_segmentEnd) - worldToPx(a_segmentStart);\n  tangentPx = normalize(tangentPx);\n  vec2 normalPx = vec2(-tangentPx.y, tangentPx.x);\n  float normalDir = vertexNumber < 0.5 || (vertexNumber > 1.5 && vertexNumber < 2.5) ? 1.0 : -1.0;\n  float tangentDir = vertexNumber < 1.5 ? 1.0 : -1.0;\n  float angle = vertexNumber < 1.5 ? v_angleStart : v_angleEnd;\n  vec2 offsetPx = getOffsetDirection(normalPx * normalDir, tangentDir * tangentPx, angle) * lineWidth * 0.5;\n  vec2 position =  vertexNumber < 1.5 ? a_segmentStart : a_segmentEnd;\n  gl_Position = u_projectionMatrix * vec4(position, 0.0, 1.0) + pxToScreen(offsetPx);\n  v_segmentStart = worldToPx(a_segmentStart);\n  v_segmentEnd = worldToPx(a_segmentEnd);\n  v_width = lineWidth;\n  v_hitColor = a_hitColor;\n${this.varyings_\n  .map(function (varying) {\n    return '  ' + varying.name + ' = ' + varying.expression + ';';\n  })\n  .join('\\n')}\n}`;\n  }\n\n  /**\n   * Generates a stroke fragment shader from the builder parameters\n   *\n   * @return {string|null} The full shader as a string; null if no size or color specified\n   */\n  getStrokeFragmentShader() {\n    if (!this.hasStroke_) {\n      return null;\n    }\n\n    return `#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n${BASE_UNIFORMS}\n${this.uniforms_\n  .map(function (uniform) {\n    return 'uniform ' + uniform + ';';\n  })\n  .join('\\n')}\nvarying vec2 v_segmentStart;\nvarying vec2 v_segmentEnd;\nvarying float v_angleStart;\nvarying float v_angleEnd;\nvarying float v_width;\nvarying vec4 v_hitColor;\n${this.varyings_\n  .map(function (varying) {\n    return 'varying ' + varying.type + ' ' + varying.name + ';';\n  })\n  .join('\\n')}\n${this.fragmentShaderFunctions_.join('\\n')}\nvec2 pxToWorld(vec2 pxPos) {\n  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;\n  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;\n}\n\nfloat segmentDistanceField(vec2 point, vec2 start, vec2 end, float radius) {\n  vec2 startToPoint = point - start;\n  vec2 startToEnd = end - start;\n  float ratio = clamp(dot(startToPoint, startToEnd) / dot(startToEnd, startToEnd), 0.0, 1.0);\n  float dist = length(startToPoint - ratio * startToEnd);\n  return 1.0 - smoothstep(radius - 1.0, radius, dist);\n}\n\nvoid main(void) {\n  vec2 v_currentPoint = gl_FragCoord.xy / u_pixelRatio;\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n  vec2 v_worldPos = pxToWorld(v_currentPoint);\n  if (\n    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (\n      v_worldPos[0] < u_renderExtent[0] ||\n      v_worldPos[1] < u_renderExtent[1] ||\n      v_worldPos[0] > u_renderExtent[2] ||\n      v_worldPos[1] > u_renderExtent[3]\n    )\n  ) {\n    discard;\n  }\n  #endif\n  if (${this.discardExpression_}) { discard; }\n  gl_FragColor = ${this.strokeColorExpression_} * u_globalAlpha;\n  gl_FragColor *= segmentDistanceField(v_currentPoint, v_segmentStart, v_segmentEnd, v_width);\n  if (u_hitDetection > 0) {\n    if (gl_FragColor.a < 0.1) { discard; };\n    gl_FragColor = v_hitColor;\n  }\n}`;\n  }\n\n  /**\n   * Generates a fill vertex shader from the builder parameters\n   *\n   * @return {string|null} The full shader as a string; null if no color specified\n   */\n  getFillVertexShader() {\n    if (!this.hasFill_) {\n      return null;\n    }\n\n    return `#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n${BASE_UNIFORMS}\n${this.uniforms_\n  .map(function (uniform) {\n    return 'uniform ' + uniform + ';';\n  })\n  .join('\\n')}\nattribute vec2 a_position;\nattribute vec4 a_hitColor;\n${this.attributes_\n  .map(function (attribute) {\n    return 'attribute ' + attribute + ';';\n  })\n  .join('\\n')}\nvarying vec4 v_hitColor;\n${this.varyings_\n  .map(function (varying) {\n    return 'varying ' + varying.type + ' ' + varying.name + ';';\n  })\n  .join('\\n')}\n${this.vertexShaderFunctions_.join('\\n')}\nvoid main(void) {\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\n${this.varyings_\n  .map(function (varying) {\n    return '  ' + varying.name + ' = ' + varying.expression + ';';\n  })\n  .join('\\n')}\n}`;\n  }\n\n  /**\n   * Generates a fill fragment shader from the builder parameters\n   * @return {string|null} The full shader as a string; null if no color specified\n   */\n  getFillFragmentShader() {\n    if (!this.hasFill_) {\n      return null;\n    }\n\n    return `#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n${BASE_UNIFORMS}\n${this.uniforms_\n  .map(function (uniform) {\n    return 'uniform ' + uniform + ';';\n  })\n  .join('\\n')}\nvarying vec4 v_hitColor;\n${this.varyings_\n  .map(function (varying) {\n    return 'varying ' + varying.type + ' ' + varying.name + ';';\n  })\n  .join('\\n')}\n${this.fragmentShaderFunctions_.join('\\n')}\nvec2 pxToWorld(vec2 pxPos) {\n  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;\n  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;\n}\n\nvoid main(void) {\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n  vec2 v_worldPos = pxToWorld(gl_FragCoord.xy / u_pixelRatio);\n  if (\n    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (\n      v_worldPos[0] < u_renderExtent[0] ||\n      v_worldPos[1] < u_renderExtent[1] ||\n      v_worldPos[0] > u_renderExtent[2] ||\n      v_worldPos[1] > u_renderExtent[3]\n    )\n  ) {\n    discard;\n  }\n  #endif\n  if (${this.discardExpression_}) { discard; }\n  gl_FragColor = ${this.fillColorExpression_} * u_globalAlpha;\n  if (u_hitDetection > 0) {\n    if (gl_FragColor.a < 0.1) { discard; };\n    gl_FragColor = v_hitColor;\n  }\n}`;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}
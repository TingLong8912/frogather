{"ast":null,"code":"/*! @petamoriken/float16 v3.9.2 | MIT License - https://github.com/petamoriken/float16 */\n\nvar float16 = function (exports) {\n  'use strict';\n\n  const THIS_IS_NOT_AN_OBJECT = \"This is not an object\";\n  const THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT = \"This is not a Float16Array object\";\n  const THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY = \"This constructor is not a subclass of Float16Array\";\n  const THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT = \"The constructor property value is not an object\";\n  const SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT = \"Species constructor didn't return TypedArray object\";\n  const DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH = \"Derived constructor created TypedArray object which was too small length\";\n  const ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER = \"Attempting to access detached ArrayBuffer\";\n  const CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT = \"Cannot convert undefined or null to object\";\n  const CANNOT_MIX_BIGINT_AND_OTHER_TYPES = \"Cannot mix BigInt and other types, use explicit conversions\";\n  const ITERATOR_PROPERTY_IS_NOT_CALLABLE = \"@@iterator property is not callable\";\n  const REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE = \"Reduce of empty array with no initial value\";\n  const THE_COMPARISON_FUNCTION_MUST_BE_EITHER_A_FUNCTION_OR_UNDEFINED = \"The comparison function must be either a function or undefined\";\n  const OFFSET_IS_OUT_OF_BOUNDS = \"Offset is out of bounds\";\n  function uncurryThis(target) {\n    return (thisArg, ...args) => {\n      return ReflectApply(target, thisArg, args);\n    };\n  }\n  function uncurryThisGetter(target, key) {\n    return uncurryThis(ReflectGetOwnPropertyDescriptor(target, key).get);\n  }\n  const {\n    apply: ReflectApply,\n    construct: ReflectConstruct,\n    defineProperty: ReflectDefineProperty,\n    get: ReflectGet,\n    getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor,\n    getPrototypeOf: ReflectGetPrototypeOf,\n    has: ReflectHas,\n    ownKeys: ReflectOwnKeys,\n    set: ReflectSet,\n    setPrototypeOf: ReflectSetPrototypeOf\n  } = Reflect;\n  const NativeProxy = Proxy;\n  const {\n    EPSILON,\n    MAX_SAFE_INTEGER,\n    isFinite: NumberIsFinite,\n    isNaN: NumberIsNaN\n  } = Number;\n  const {\n    iterator: SymbolIterator,\n    species: SymbolSpecies,\n    toStringTag: SymbolToStringTag,\n    for: SymbolFor\n  } = Symbol;\n  const NativeObject = Object;\n  const {\n    create: ObjectCreate,\n    defineProperty: ObjectDefineProperty,\n    freeze: ObjectFreeze,\n    is: ObjectIs\n  } = NativeObject;\n  const ObjectPrototype = NativeObject.prototype;\n  const ObjectPrototype__lookupGetter__ = ObjectPrototype.__lookupGetter__ ? uncurryThis(ObjectPrototype.__lookupGetter__) : (object, key) => {\n    if (object == null) {\n      throw NativeTypeError(CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT);\n    }\n    let target = NativeObject(object);\n    do {\n      const descriptor = ReflectGetOwnPropertyDescriptor(target, key);\n      if (descriptor !== undefined) {\n        if (ObjectHasOwn(descriptor, \"get\")) {\n          return descriptor.get;\n        }\n        return;\n      }\n    } while ((target = ReflectGetPrototypeOf(target)) !== null);\n  };\n  const ObjectHasOwn = NativeObject.hasOwn || uncurryThis(ObjectPrototype.hasOwnProperty);\n  const NativeArray = Array;\n  const ArrayIsArray = NativeArray.isArray;\n  const ArrayPrototype = NativeArray.prototype;\n  const ArrayPrototypeJoin = uncurryThis(ArrayPrototype.join);\n  const ArrayPrototypePush = uncurryThis(ArrayPrototype.push);\n  const ArrayPrototypeToLocaleString = uncurryThis(ArrayPrototype.toLocaleString);\n  const NativeArrayPrototypeSymbolIterator = ArrayPrototype[SymbolIterator];\n  const ArrayPrototypeSymbolIterator = uncurryThis(NativeArrayPrototypeSymbolIterator);\n  const {\n    abs: MathAbs,\n    trunc: MathTrunc\n  } = Math;\n  const NativeArrayBuffer = ArrayBuffer;\n  const ArrayBufferIsView = NativeArrayBuffer.isView;\n  const ArrayBufferPrototype = NativeArrayBuffer.prototype;\n  const ArrayBufferPrototypeSlice = uncurryThis(ArrayBufferPrototype.slice);\n  const ArrayBufferPrototypeGetByteLength = uncurryThisGetter(ArrayBufferPrototype, \"byteLength\");\n  const NativeSharedArrayBuffer = typeof SharedArrayBuffer !== \"undefined\" ? SharedArrayBuffer : null;\n  const SharedArrayBufferPrototypeGetByteLength = NativeSharedArrayBuffer && uncurryThisGetter(NativeSharedArrayBuffer.prototype, \"byteLength\");\n  const TypedArray = ReflectGetPrototypeOf(Uint8Array);\n  const TypedArrayFrom = TypedArray.from;\n  const TypedArrayPrototype = TypedArray.prototype;\n  const NativeTypedArrayPrototypeSymbolIterator = TypedArrayPrototype[SymbolIterator];\n  const TypedArrayPrototypeKeys = uncurryThis(TypedArrayPrototype.keys);\n  const TypedArrayPrototypeValues = uncurryThis(TypedArrayPrototype.values);\n  const TypedArrayPrototypeEntries = uncurryThis(TypedArrayPrototype.entries);\n  const TypedArrayPrototypeSet = uncurryThis(TypedArrayPrototype.set);\n  const TypedArrayPrototypeReverse = uncurryThis(TypedArrayPrototype.reverse);\n  const TypedArrayPrototypeFill = uncurryThis(TypedArrayPrototype.fill);\n  const TypedArrayPrototypeCopyWithin = uncurryThis(TypedArrayPrototype.copyWithin);\n  const TypedArrayPrototypeSort = uncurryThis(TypedArrayPrototype.sort);\n  const TypedArrayPrototypeSlice = uncurryThis(TypedArrayPrototype.slice);\n  const TypedArrayPrototypeSubarray = uncurryThis(TypedArrayPrototype.subarray);\n  const TypedArrayPrototypeGetBuffer = uncurryThisGetter(TypedArrayPrototype, \"buffer\");\n  const TypedArrayPrototypeGetByteOffset = uncurryThisGetter(TypedArrayPrototype, \"byteOffset\");\n  const TypedArrayPrototypeGetLength = uncurryThisGetter(TypedArrayPrototype, \"length\");\n  const TypedArrayPrototypeGetSymbolToStringTag = uncurryThisGetter(TypedArrayPrototype, SymbolToStringTag);\n  const NativeUint8Array = Uint8Array;\n  const NativeUint16Array = Uint16Array;\n  const Uint16ArrayFrom = (...args) => {\n    return ReflectApply(TypedArrayFrom, NativeUint16Array, args);\n  };\n  const NativeUint32Array = Uint32Array;\n  const NativeFloat32Array = Float32Array;\n  const ArrayIteratorPrototype = ReflectGetPrototypeOf([][SymbolIterator]());\n  const ArrayIteratorPrototypeNext = uncurryThis(ArrayIteratorPrototype.next);\n  const GeneratorPrototypeNext = uncurryThis(function* () {}().next);\n  const IteratorPrototype = ReflectGetPrototypeOf(ArrayIteratorPrototype);\n  const DataViewPrototype = DataView.prototype;\n  const DataViewPrototypeGetUint16 = uncurryThis(DataViewPrototype.getUint16);\n  const DataViewPrototypeSetUint16 = uncurryThis(DataViewPrototype.setUint16);\n  const NativeTypeError = TypeError;\n  const NativeRangeError = RangeError;\n  const NativeWeakSet = WeakSet;\n  const WeakSetPrototype = NativeWeakSet.prototype;\n  const WeakSetPrototypeAdd = uncurryThis(WeakSetPrototype.add);\n  const WeakSetPrototypeHas = uncurryThis(WeakSetPrototype.has);\n  const NativeWeakMap = WeakMap;\n  const WeakMapPrototype = NativeWeakMap.prototype;\n  const WeakMapPrototypeGet = uncurryThis(WeakMapPrototype.get);\n  const WeakMapPrototypeHas = uncurryThis(WeakMapPrototype.has);\n  const WeakMapPrototypeSet = uncurryThis(WeakMapPrototype.set);\n  const arrayIterators = new NativeWeakMap();\n  const SafeIteratorPrototype = ObjectCreate(null, {\n    next: {\n      value: function next() {\n        const arrayIterator = WeakMapPrototypeGet(arrayIterators, this);\n        return ArrayIteratorPrototypeNext(arrayIterator);\n      }\n    },\n    [SymbolIterator]: {\n      value: function values() {\n        return this;\n      }\n    }\n  });\n  function safeIfNeeded(array) {\n    if (array[SymbolIterator] === NativeArrayPrototypeSymbolIterator && ArrayIteratorPrototype.next === ArrayIteratorPrototypeNext) {\n      return array;\n    }\n    const safe = ObjectCreate(SafeIteratorPrototype);\n    WeakMapPrototypeSet(arrayIterators, safe, ArrayPrototypeSymbolIterator(array));\n    return safe;\n  }\n  const generators = new NativeWeakMap();\n  const DummyArrayIteratorPrototype = ObjectCreate(IteratorPrototype, {\n    next: {\n      value: function next() {\n        const generator = WeakMapPrototypeGet(generators, this);\n        return GeneratorPrototypeNext(generator);\n      },\n      writable: true,\n      configurable: true\n    }\n  });\n  for (const key of ReflectOwnKeys(ArrayIteratorPrototype)) {\n    if (key === \"next\") {\n      continue;\n    }\n    ObjectDefineProperty(DummyArrayIteratorPrototype, key, ReflectGetOwnPropertyDescriptor(ArrayIteratorPrototype, key));\n  }\n  function wrap(generator) {\n    const dummy = ObjectCreate(DummyArrayIteratorPrototype);\n    WeakMapPrototypeSet(generators, dummy, generator);\n    return dummy;\n  }\n  function isObject(value) {\n    return value !== null && typeof value === \"object\" || typeof value === \"function\";\n  }\n  function isObjectLike(value) {\n    return value !== null && typeof value === \"object\";\n  }\n  function isNativeTypedArray(value) {\n    return TypedArrayPrototypeGetSymbolToStringTag(value) !== undefined;\n  }\n  function isNativeBigIntTypedArray(value) {\n    const typedArrayName = TypedArrayPrototypeGetSymbolToStringTag(value);\n    return typedArrayName === \"BigInt64Array\" || typedArrayName === \"BigUint64Array\";\n  }\n  function isArrayBuffer(value) {\n    try {\n      if (ArrayIsArray(value)) {\n        return false;\n      }\n      ArrayBufferPrototypeGetByteLength(value);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  function isSharedArrayBuffer(value) {\n    if (NativeSharedArrayBuffer === null) {\n      return false;\n    }\n    try {\n      SharedArrayBufferPrototypeGetByteLength(value);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  function isAnyArrayBuffer(value) {\n    return isArrayBuffer(value) || isSharedArrayBuffer(value);\n  }\n  function isOrdinaryArray(value) {\n    if (!ArrayIsArray(value)) {\n      return false;\n    }\n    return value[SymbolIterator] === NativeArrayPrototypeSymbolIterator && ArrayIteratorPrototype.next === ArrayIteratorPrototypeNext;\n  }\n  function isOrdinaryNativeTypedArray(value) {\n    if (!isNativeTypedArray(value)) {\n      return false;\n    }\n    return value[SymbolIterator] === NativeTypedArrayPrototypeSymbolIterator && ArrayIteratorPrototype.next === ArrayIteratorPrototypeNext;\n  }\n  function isCanonicalIntegerIndexString(value) {\n    if (typeof value !== \"string\") {\n      return false;\n    }\n    const number = +value;\n    if (value !== number + \"\") {\n      return false;\n    }\n    if (!NumberIsFinite(number)) {\n      return false;\n    }\n    return number === MathTrunc(number);\n  }\n  const brand = SymbolFor(\"__Float16Array__\");\n  function hasFloat16ArrayBrand(target) {\n    if (!isObjectLike(target)) {\n      return false;\n    }\n    const prototype = ReflectGetPrototypeOf(target);\n    if (!isObjectLike(prototype)) {\n      return false;\n    }\n    const constructor = prototype.constructor;\n    if (constructor === undefined) {\n      return false;\n    }\n    if (!isObject(constructor)) {\n      throw NativeTypeError(THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT);\n    }\n    return ReflectHas(constructor, brand);\n  }\n  const INVERSE_OF_EPSILON = 1 / EPSILON;\n  function roundTiesToEven(num) {\n    return num + INVERSE_OF_EPSILON - INVERSE_OF_EPSILON;\n  }\n  const FLOAT16_MIN_VALUE = 6.103515625e-05;\n  const FLOAT16_MAX_VALUE = 65504;\n  const FLOAT16_EPSILON = 0.0009765625;\n  const FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE = FLOAT16_EPSILON * FLOAT16_MIN_VALUE;\n  const FLOAT16_EPSILON_DEVIDED_BY_EPSILON = FLOAT16_EPSILON * INVERSE_OF_EPSILON;\n  function roundToFloat16(num) {\n    const number = +num;\n    if (!NumberIsFinite(number) || number === 0) {\n      return number;\n    }\n    const sign = number > 0 ? 1 : -1;\n    const absolute = MathAbs(number);\n    if (absolute < FLOAT16_MIN_VALUE) {\n      return sign * roundTiesToEven(absolute / FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE) * FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE;\n    }\n    const temp = (1 + FLOAT16_EPSILON_DEVIDED_BY_EPSILON) * absolute;\n    const result = temp - (temp - absolute);\n    if (result > FLOAT16_MAX_VALUE || NumberIsNaN(result)) {\n      return sign * Infinity;\n    }\n    return sign * result;\n  }\n  const buffer = new NativeArrayBuffer(4);\n  const floatView = new NativeFloat32Array(buffer);\n  const uint32View = new NativeUint32Array(buffer);\n  const baseTable = new NativeUint16Array(512);\n  const shiftTable = new NativeUint8Array(512);\n  for (let i = 0; i < 256; ++i) {\n    const e = i - 127;\n    if (e < -24) {\n      baseTable[i] = 0x0000;\n      baseTable[i | 0x100] = 0x8000;\n      shiftTable[i] = 24;\n      shiftTable[i | 0x100] = 24;\n    } else if (e < -14) {\n      baseTable[i] = 0x0400 >> -e - 14;\n      baseTable[i | 0x100] = 0x0400 >> -e - 14 | 0x8000;\n      shiftTable[i] = -e - 1;\n      shiftTable[i | 0x100] = -e - 1;\n    } else if (e <= 15) {\n      baseTable[i] = e + 15 << 10;\n      baseTable[i | 0x100] = e + 15 << 10 | 0x8000;\n      shiftTable[i] = 13;\n      shiftTable[i | 0x100] = 13;\n    } else if (e < 128) {\n      baseTable[i] = 0x7c00;\n      baseTable[i | 0x100] = 0xfc00;\n      shiftTable[i] = 24;\n      shiftTable[i | 0x100] = 24;\n    } else {\n      baseTable[i] = 0x7c00;\n      baseTable[i | 0x100] = 0xfc00;\n      shiftTable[i] = 13;\n      shiftTable[i | 0x100] = 13;\n    }\n  }\n  function roundToFloat16Bits(num) {\n    floatView[0] = roundToFloat16(num);\n    const f = uint32View[0];\n    const e = f >> 23 & 0x1ff;\n    return baseTable[e] + ((f & 0x007fffff) >> shiftTable[e]);\n  }\n  const mantissaTable = new NativeUint32Array(2048);\n  for (let i = 1; i < 1024; ++i) {\n    let m = i << 13;\n    let e = 0;\n    while ((m & 0x00800000) === 0) {\n      m <<= 1;\n      e -= 0x00800000;\n    }\n    m &= -8388609;\n    e += 0x38800000;\n    mantissaTable[i] = m | e;\n  }\n  for (let i = 1024; i < 2048; ++i) {\n    mantissaTable[i] = 0x38000000 + (i - 1024 << 13);\n  }\n  const exponentTable = new NativeUint32Array(64);\n  for (let i = 1; i < 31; ++i) {\n    exponentTable[i] = i << 23;\n  }\n  exponentTable[31] = 0x47800000;\n  exponentTable[32] = 0x80000000;\n  for (let i = 33; i < 63; ++i) {\n    exponentTable[i] = 0x80000000 + (i - 32 << 23);\n  }\n  exponentTable[63] = 0xc7800000;\n  const offsetTable = new NativeUint16Array(64);\n  for (let i = 1; i < 64; ++i) {\n    if (i !== 32) {\n      offsetTable[i] = 1024;\n    }\n  }\n  function convertToNumber(float16bits) {\n    const i = float16bits >> 10;\n    uint32View[0] = mantissaTable[offsetTable[i] + (float16bits & 0x3ff)] + exponentTable[i];\n    return floatView[0];\n  }\n  function ToIntegerOrInfinity(target) {\n    const number = +target;\n    if (NumberIsNaN(number) || number === 0) {\n      return 0;\n    }\n    return MathTrunc(number);\n  }\n  function ToLength(target) {\n    const length = ToIntegerOrInfinity(target);\n    if (length < 0) {\n      return 0;\n    }\n    return length < MAX_SAFE_INTEGER ? length : MAX_SAFE_INTEGER;\n  }\n  function SpeciesConstructor(target, defaultConstructor) {\n    if (!isObject(target)) {\n      throw NativeTypeError(THIS_IS_NOT_AN_OBJECT);\n    }\n    const constructor = target.constructor;\n    if (constructor === undefined) {\n      return defaultConstructor;\n    }\n    if (!isObject(constructor)) {\n      throw NativeTypeError(THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT);\n    }\n    const species = constructor[SymbolSpecies];\n    if (species == null) {\n      return defaultConstructor;\n    }\n    return species;\n  }\n  function IsDetachedBuffer(buffer) {\n    if (isSharedArrayBuffer(buffer)) {\n      return false;\n    }\n    try {\n      ArrayBufferPrototypeSlice(buffer, 0, 0);\n      return false;\n    } catch (e) {}\n    return true;\n  }\n  function defaultCompare(x, y) {\n    const isXNaN = NumberIsNaN(x);\n    const isYNaN = NumberIsNaN(y);\n    if (isXNaN && isYNaN) {\n      return 0;\n    }\n    if (isXNaN) {\n      return 1;\n    }\n    if (isYNaN) {\n      return -1;\n    }\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    if (x === 0 && y === 0) {\n      const isXPlusZero = ObjectIs(x, 0);\n      const isYPlusZero = ObjectIs(y, 0);\n      if (!isXPlusZero && isYPlusZero) {\n        return -1;\n      }\n      if (isXPlusZero && !isYPlusZero) {\n        return 1;\n      }\n    }\n    return 0;\n  }\n  const BYTES_PER_ELEMENT = 2;\n  const float16bitsArrays = new NativeWeakMap();\n  function isFloat16Array(target) {\n    return WeakMapPrototypeHas(float16bitsArrays, target) || !ArrayBufferIsView(target) && hasFloat16ArrayBrand(target);\n  }\n  function assertFloat16Array(target) {\n    if (!isFloat16Array(target)) {\n      throw NativeTypeError(THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT);\n    }\n  }\n  function assertSpeciesTypedArray(target, count) {\n    const isTargetFloat16Array = isFloat16Array(target);\n    const isTargetTypedArray = isNativeTypedArray(target);\n    if (!isTargetFloat16Array && !isTargetTypedArray) {\n      throw NativeTypeError(SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT);\n    }\n    if (typeof count === \"number\") {\n      let length;\n      if (isTargetFloat16Array) {\n        const float16bitsArray = getFloat16BitsArray(target);\n        length = TypedArrayPrototypeGetLength(float16bitsArray);\n      } else {\n        length = TypedArrayPrototypeGetLength(target);\n      }\n      if (length < count) {\n        throw NativeTypeError(DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH);\n      }\n    }\n    if (isNativeBigIntTypedArray(target)) {\n      throw NativeTypeError(CANNOT_MIX_BIGINT_AND_OTHER_TYPES);\n    }\n  }\n  function getFloat16BitsArray(float16) {\n    const float16bitsArray = WeakMapPrototypeGet(float16bitsArrays, float16);\n    if (float16bitsArray !== undefined) {\n      const buffer = TypedArrayPrototypeGetBuffer(float16bitsArray);\n      if (IsDetachedBuffer(buffer)) {\n        throw NativeTypeError(ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);\n      }\n      return float16bitsArray;\n    }\n    const buffer = float16.buffer;\n    if (IsDetachedBuffer(buffer)) {\n      throw NativeTypeError(ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);\n    }\n    const cloned = ReflectConstruct(Float16Array, [buffer, float16.byteOffset, float16.length], float16.constructor);\n    return WeakMapPrototypeGet(float16bitsArrays, cloned);\n  }\n  function copyToArray(float16bitsArray) {\n    const length = TypedArrayPrototypeGetLength(float16bitsArray);\n    const array = [];\n    for (let i = 0; i < length; ++i) {\n      array[i] = convertToNumber(float16bitsArray[i]);\n    }\n    return array;\n  }\n  const TypedArrayPrototypeGetters = new NativeWeakSet();\n  for (const key of ReflectOwnKeys(TypedArrayPrototype)) {\n    if (key === SymbolToStringTag) {\n      continue;\n    }\n    const descriptor = ReflectGetOwnPropertyDescriptor(TypedArrayPrototype, key);\n    if (ObjectHasOwn(descriptor, \"get\") && typeof descriptor.get === \"function\") {\n      WeakSetPrototypeAdd(TypedArrayPrototypeGetters, descriptor.get);\n    }\n  }\n  const handler = ObjectFreeze({\n    get(target, key, receiver) {\n      if (isCanonicalIntegerIndexString(key) && ObjectHasOwn(target, key)) {\n        return convertToNumber(ReflectGet(target, key));\n      }\n      if (WeakSetPrototypeHas(TypedArrayPrototypeGetters, ObjectPrototype__lookupGetter__(target, key))) {\n        return ReflectGet(target, key);\n      }\n      return ReflectGet(target, key, receiver);\n    },\n    set(target, key, value, receiver) {\n      if (isCanonicalIntegerIndexString(key) && ObjectHasOwn(target, key)) {\n        return ReflectSet(target, key, roundToFloat16Bits(value));\n      }\n      return ReflectSet(target, key, value, receiver);\n    },\n    getOwnPropertyDescriptor(target, key) {\n      if (isCanonicalIntegerIndexString(key) && ObjectHasOwn(target, key)) {\n        const descriptor = ReflectGetOwnPropertyDescriptor(target, key);\n        descriptor.value = convertToNumber(descriptor.value);\n        return descriptor;\n      }\n      return ReflectGetOwnPropertyDescriptor(target, key);\n    },\n    defineProperty(target, key, descriptor) {\n      if (isCanonicalIntegerIndexString(key) && ObjectHasOwn(target, key) && ObjectHasOwn(descriptor, \"value\")) {\n        descriptor.value = roundToFloat16Bits(descriptor.value);\n        return ReflectDefineProperty(target, key, descriptor);\n      }\n      return ReflectDefineProperty(target, key, descriptor);\n    }\n  });\n  class Float16Array {\n    constructor(input, _byteOffset, _length) {\n      let float16bitsArray;\n      if (isFloat16Array(input)) {\n        float16bitsArray = ReflectConstruct(NativeUint16Array, [getFloat16BitsArray(input)], new.target);\n      } else if (isObject(input) && !isAnyArrayBuffer(input)) {\n        let list;\n        let length;\n        if (isNativeTypedArray(input)) {\n          list = input;\n          length = TypedArrayPrototypeGetLength(input);\n          const buffer = TypedArrayPrototypeGetBuffer(input);\n          if (IsDetachedBuffer(buffer)) {\n            throw NativeTypeError(ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);\n          }\n          if (isNativeBigIntTypedArray(input)) {\n            throw NativeTypeError(CANNOT_MIX_BIGINT_AND_OTHER_TYPES);\n          }\n          const data = new NativeArrayBuffer(length * BYTES_PER_ELEMENT);\n          float16bitsArray = ReflectConstruct(NativeUint16Array, [data], new.target);\n        } else {\n          const iterator = input[SymbolIterator];\n          if (iterator != null && typeof iterator !== \"function\") {\n            throw NativeTypeError(ITERATOR_PROPERTY_IS_NOT_CALLABLE);\n          }\n          if (iterator != null) {\n            if (isOrdinaryArray(input)) {\n              list = input;\n              length = input.length;\n            } else {\n              list = [...input];\n              length = list.length;\n            }\n          } else {\n            list = input;\n            length = ToLength(list.length);\n          }\n          float16bitsArray = ReflectConstruct(NativeUint16Array, [length], new.target);\n        }\n        for (let i = 0; i < length; ++i) {\n          float16bitsArray[i] = roundToFloat16Bits(list[i]);\n        }\n      } else {\n        float16bitsArray = ReflectConstruct(NativeUint16Array, arguments, new.target);\n      }\n      const proxy = new NativeProxy(float16bitsArray, handler);\n      WeakMapPrototypeSet(float16bitsArrays, proxy, float16bitsArray);\n      return proxy;\n    }\n    static from(src, ...opts) {\n      const Constructor = this;\n      if (!ReflectHas(Constructor, brand)) {\n        throw NativeTypeError(THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY);\n      }\n      if (Constructor === Float16Array) {\n        if (isFloat16Array(src) && opts.length === 0) {\n          const float16bitsArray = getFloat16BitsArray(src);\n          const uint16 = new NativeUint16Array(TypedArrayPrototypeGetBuffer(float16bitsArray), TypedArrayPrototypeGetByteOffset(float16bitsArray), TypedArrayPrototypeGetLength(float16bitsArray));\n          return new Float16Array(TypedArrayPrototypeGetBuffer(TypedArrayPrototypeSlice(uint16)));\n        }\n        if (opts.length === 0) {\n          return new Float16Array(TypedArrayPrototypeGetBuffer(Uint16ArrayFrom(src, roundToFloat16Bits)));\n        }\n        const mapFunc = opts[0];\n        const thisArg = opts[1];\n        return new Float16Array(TypedArrayPrototypeGetBuffer(Uint16ArrayFrom(src, function (val, ...args) {\n          return roundToFloat16Bits(ReflectApply(mapFunc, this, [val, ...safeIfNeeded(args)]));\n        }, thisArg)));\n      }\n      let list;\n      let length;\n      const iterator = src[SymbolIterator];\n      if (iterator != null && typeof iterator !== \"function\") {\n        throw NativeTypeError(ITERATOR_PROPERTY_IS_NOT_CALLABLE);\n      }\n      if (iterator != null) {\n        if (isOrdinaryArray(src)) {\n          list = src;\n          length = src.length;\n        } else if (isOrdinaryNativeTypedArray(src)) {\n          list = src;\n          length = TypedArrayPrototypeGetLength(src);\n        } else {\n          list = [...src];\n          length = list.length;\n        }\n      } else {\n        if (src == null) {\n          throw NativeTypeError(CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT);\n        }\n        list = NativeObject(src);\n        length = ToLength(list.length);\n      }\n      const array = new Constructor(length);\n      if (opts.length === 0) {\n        for (let i = 0; i < length; ++i) {\n          array[i] = list[i];\n        }\n      } else {\n        const mapFunc = opts[0];\n        const thisArg = opts[1];\n        for (let i = 0; i < length; ++i) {\n          array[i] = ReflectApply(mapFunc, thisArg, [list[i], i]);\n        }\n      }\n      return array;\n    }\n    static of(...items) {\n      const Constructor = this;\n      if (!ReflectHas(Constructor, brand)) {\n        throw NativeTypeError(THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY);\n      }\n      const length = items.length;\n      if (Constructor === Float16Array) {\n        const proxy = new Float16Array(length);\n        const float16bitsArray = getFloat16BitsArray(proxy);\n        for (let i = 0; i < length; ++i) {\n          float16bitsArray[i] = roundToFloat16Bits(items[i]);\n        }\n        return proxy;\n      }\n      const array = new Constructor(length);\n      for (let i = 0; i < length; ++i) {\n        array[i] = items[i];\n      }\n      return array;\n    }\n    keys() {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      return TypedArrayPrototypeKeys(float16bitsArray);\n    }\n    values() {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      return wrap(function* () {\n        for (const val of TypedArrayPrototypeValues(float16bitsArray)) {\n          yield convertToNumber(val);\n        }\n      }());\n    }\n    entries() {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      return wrap(function* () {\n        for (const [i, val] of TypedArrayPrototypeEntries(float16bitsArray)) {\n          yield [i, convertToNumber(val)];\n        }\n      }());\n    }\n    at(index) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const relativeIndex = ToIntegerOrInfinity(index);\n      const k = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n      if (k < 0 || k >= length) {\n        return;\n      }\n      return convertToNumber(float16bitsArray[k]);\n    }\n    with(index, value) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const relativeIndex = ToIntegerOrInfinity(index);\n      const k = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n      const number = +value;\n      if (k < 0 || k >= length) {\n        throw NativeRangeError(OFFSET_IS_OUT_OF_BOUNDS);\n      }\n      const uint16 = new NativeUint16Array(TypedArrayPrototypeGetBuffer(float16bitsArray), TypedArrayPrototypeGetByteOffset(float16bitsArray), TypedArrayPrototypeGetLength(float16bitsArray));\n      const cloned = new Float16Array(TypedArrayPrototypeGetBuffer(TypedArrayPrototypeSlice(uint16)));\n      const array = getFloat16BitsArray(cloned);\n      array[k] = roundToFloat16Bits(number);\n      return cloned;\n    }\n    map(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const thisArg = opts[0];\n      const Constructor = SpeciesConstructor(float16bitsArray, Float16Array);\n      if (Constructor === Float16Array) {\n        const proxy = new Float16Array(length);\n        const array = getFloat16BitsArray(proxy);\n        for (let i = 0; i < length; ++i) {\n          const val = convertToNumber(float16bitsArray[i]);\n          array[i] = roundToFloat16Bits(ReflectApply(callback, thisArg, [val, i, this]));\n        }\n        return proxy;\n      }\n      const array = new Constructor(length);\n      assertSpeciesTypedArray(array, length);\n      for (let i = 0; i < length; ++i) {\n        const val = convertToNumber(float16bitsArray[i]);\n        array[i] = ReflectApply(callback, thisArg, [val, i, this]);\n      }\n      return array;\n    }\n    filter(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const thisArg = opts[0];\n      const kept = [];\n      for (let i = 0; i < length; ++i) {\n        const val = convertToNumber(float16bitsArray[i]);\n        if (ReflectApply(callback, thisArg, [val, i, this])) {\n          ArrayPrototypePush(kept, val);\n        }\n      }\n      const Constructor = SpeciesConstructor(float16bitsArray, Float16Array);\n      const array = new Constructor(kept);\n      assertSpeciesTypedArray(array);\n      return array;\n    }\n    reduce(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      if (length === 0 && opts.length === 0) {\n        throw NativeTypeError(REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE);\n      }\n      let accumulator, start;\n      if (opts.length === 0) {\n        accumulator = convertToNumber(float16bitsArray[0]);\n        start = 1;\n      } else {\n        accumulator = opts[0];\n        start = 0;\n      }\n      for (let i = start; i < length; ++i) {\n        accumulator = callback(accumulator, convertToNumber(float16bitsArray[i]), i, this);\n      }\n      return accumulator;\n    }\n    reduceRight(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      if (length === 0 && opts.length === 0) {\n        throw NativeTypeError(REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE);\n      }\n      let accumulator, start;\n      if (opts.length === 0) {\n        accumulator = convertToNumber(float16bitsArray[length - 1]);\n        start = length - 2;\n      } else {\n        accumulator = opts[0];\n        start = length - 1;\n      }\n      for (let i = start; i >= 0; --i) {\n        accumulator = callback(accumulator, convertToNumber(float16bitsArray[i]), i, this);\n      }\n      return accumulator;\n    }\n    forEach(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const thisArg = opts[0];\n      for (let i = 0; i < length; ++i) {\n        ReflectApply(callback, thisArg, [convertToNumber(float16bitsArray[i]), i, this]);\n      }\n    }\n    find(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const thisArg = opts[0];\n      for (let i = 0; i < length; ++i) {\n        const value = convertToNumber(float16bitsArray[i]);\n        if (ReflectApply(callback, thisArg, [value, i, this])) {\n          return value;\n        }\n      }\n    }\n    findIndex(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const thisArg = opts[0];\n      for (let i = 0; i < length; ++i) {\n        const value = convertToNumber(float16bitsArray[i]);\n        if (ReflectApply(callback, thisArg, [value, i, this])) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    findLast(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const thisArg = opts[0];\n      for (let i = length - 1; i >= 0; --i) {\n        const value = convertToNumber(float16bitsArray[i]);\n        if (ReflectApply(callback, thisArg, [value, i, this])) {\n          return value;\n        }\n      }\n    }\n    findLastIndex(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const thisArg = opts[0];\n      for (let i = length - 1; i >= 0; --i) {\n        const value = convertToNumber(float16bitsArray[i]);\n        if (ReflectApply(callback, thisArg, [value, i, this])) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    every(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const thisArg = opts[0];\n      for (let i = 0; i < length; ++i) {\n        if (!ReflectApply(callback, thisArg, [convertToNumber(float16bitsArray[i]), i, this])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    some(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const thisArg = opts[0];\n      for (let i = 0; i < length; ++i) {\n        if (ReflectApply(callback, thisArg, [convertToNumber(float16bitsArray[i]), i, this])) {\n          return true;\n        }\n      }\n      return false;\n    }\n    set(input, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const targetOffset = ToIntegerOrInfinity(opts[0]);\n      if (targetOffset < 0) {\n        throw NativeRangeError(OFFSET_IS_OUT_OF_BOUNDS);\n      }\n      if (input == null) {\n        throw NativeTypeError(CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT);\n      }\n      if (isNativeBigIntTypedArray(input)) {\n        throw NativeTypeError(CANNOT_MIX_BIGINT_AND_OTHER_TYPES);\n      }\n      if (isFloat16Array(input)) {\n        return TypedArrayPrototypeSet(getFloat16BitsArray(this), getFloat16BitsArray(input), targetOffset);\n      }\n      if (isNativeTypedArray(input)) {\n        const buffer = TypedArrayPrototypeGetBuffer(input);\n        if (IsDetachedBuffer(buffer)) {\n          throw NativeTypeError(ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);\n        }\n      }\n      const targetLength = TypedArrayPrototypeGetLength(float16bitsArray);\n      const src = NativeObject(input);\n      const srcLength = ToLength(src.length);\n      if (targetOffset === Infinity || srcLength + targetOffset > targetLength) {\n        throw NativeRangeError(OFFSET_IS_OUT_OF_BOUNDS);\n      }\n      for (let i = 0; i < srcLength; ++i) {\n        float16bitsArray[i + targetOffset] = roundToFloat16Bits(src[i]);\n      }\n    }\n    reverse() {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      TypedArrayPrototypeReverse(float16bitsArray);\n      return this;\n    }\n    toReversed() {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const uint16 = new NativeUint16Array(TypedArrayPrototypeGetBuffer(float16bitsArray), TypedArrayPrototypeGetByteOffset(float16bitsArray), TypedArrayPrototypeGetLength(float16bitsArray));\n      const cloned = new Float16Array(TypedArrayPrototypeGetBuffer(TypedArrayPrototypeSlice(uint16)));\n      const clonedFloat16bitsArray = getFloat16BitsArray(cloned);\n      TypedArrayPrototypeReverse(clonedFloat16bitsArray);\n      return cloned;\n    }\n    fill(value, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      TypedArrayPrototypeFill(float16bitsArray, roundToFloat16Bits(value), ...safeIfNeeded(opts));\n      return this;\n    }\n    copyWithin(target, start, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      TypedArrayPrototypeCopyWithin(float16bitsArray, target, start, ...safeIfNeeded(opts));\n      return this;\n    }\n    sort(compareFn) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const sortCompare = compareFn !== undefined ? compareFn : defaultCompare;\n      TypedArrayPrototypeSort(float16bitsArray, (x, y) => {\n        return sortCompare(convertToNumber(x), convertToNumber(y));\n      });\n      return this;\n    }\n    toSorted(compareFn) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      if (compareFn !== undefined && typeof compareFn !== \"function\") {\n        throw new NativeTypeError(THE_COMPARISON_FUNCTION_MUST_BE_EITHER_A_FUNCTION_OR_UNDEFINED);\n      }\n      const sortCompare = compareFn !== undefined ? compareFn : defaultCompare;\n      const uint16 = new NativeUint16Array(TypedArrayPrototypeGetBuffer(float16bitsArray), TypedArrayPrototypeGetByteOffset(float16bitsArray), TypedArrayPrototypeGetLength(float16bitsArray));\n      const cloned = new Float16Array(TypedArrayPrototypeGetBuffer(TypedArrayPrototypeSlice(uint16)));\n      const clonedFloat16bitsArray = getFloat16BitsArray(cloned);\n      TypedArrayPrototypeSort(clonedFloat16bitsArray, (x, y) => {\n        return sortCompare(convertToNumber(x), convertToNumber(y));\n      });\n      return cloned;\n    }\n    slice(start, end) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const Constructor = SpeciesConstructor(float16bitsArray, Float16Array);\n      if (Constructor === Float16Array) {\n        const uint16 = new NativeUint16Array(TypedArrayPrototypeGetBuffer(float16bitsArray), TypedArrayPrototypeGetByteOffset(float16bitsArray), TypedArrayPrototypeGetLength(float16bitsArray));\n        return new Float16Array(TypedArrayPrototypeGetBuffer(TypedArrayPrototypeSlice(uint16, start, end)));\n      }\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const relativeStart = ToIntegerOrInfinity(start);\n      const relativeEnd = end === undefined ? length : ToIntegerOrInfinity(end);\n      let k;\n      if (relativeStart === -Infinity) {\n        k = 0;\n      } else if (relativeStart < 0) {\n        k = length + relativeStart > 0 ? length + relativeStart : 0;\n      } else {\n        k = length < relativeStart ? length : relativeStart;\n      }\n      let final;\n      if (relativeEnd === -Infinity) {\n        final = 0;\n      } else if (relativeEnd < 0) {\n        final = length + relativeEnd > 0 ? length + relativeEnd : 0;\n      } else {\n        final = length < relativeEnd ? length : relativeEnd;\n      }\n      const count = final - k > 0 ? final - k : 0;\n      const array = new Constructor(count);\n      assertSpeciesTypedArray(array, count);\n      if (count === 0) {\n        return array;\n      }\n      const buffer = TypedArrayPrototypeGetBuffer(float16bitsArray);\n      if (IsDetachedBuffer(buffer)) {\n        throw NativeTypeError(ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);\n      }\n      let n = 0;\n      while (k < final) {\n        array[n] = convertToNumber(float16bitsArray[k]);\n        ++k;\n        ++n;\n      }\n      return array;\n    }\n    subarray(begin, end) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const Constructor = SpeciesConstructor(float16bitsArray, Float16Array);\n      const uint16 = new NativeUint16Array(TypedArrayPrototypeGetBuffer(float16bitsArray), TypedArrayPrototypeGetByteOffset(float16bitsArray), TypedArrayPrototypeGetLength(float16bitsArray));\n      const uint16Subarray = TypedArrayPrototypeSubarray(uint16, begin, end);\n      const array = new Constructor(TypedArrayPrototypeGetBuffer(uint16Subarray), TypedArrayPrototypeGetByteOffset(uint16Subarray), TypedArrayPrototypeGetLength(uint16Subarray));\n      assertSpeciesTypedArray(array);\n      return array;\n    }\n    indexOf(element, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      let from = ToIntegerOrInfinity(opts[0]);\n      if (from === Infinity) {\n        return -1;\n      }\n      if (from < 0) {\n        from += length;\n        if (from < 0) {\n          from = 0;\n        }\n      }\n      for (let i = from; i < length; ++i) {\n        if (ObjectHasOwn(float16bitsArray, i) && convertToNumber(float16bitsArray[i]) === element) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    lastIndexOf(element, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      let from = opts.length >= 1 ? ToIntegerOrInfinity(opts[0]) : length - 1;\n      if (from === -Infinity) {\n        return -1;\n      }\n      if (from >= 0) {\n        from = from < length - 1 ? from : length - 1;\n      } else {\n        from += length;\n      }\n      for (let i = from; i >= 0; --i) {\n        if (ObjectHasOwn(float16bitsArray, i) && convertToNumber(float16bitsArray[i]) === element) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    includes(element, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      let from = ToIntegerOrInfinity(opts[0]);\n      if (from === Infinity) {\n        return false;\n      }\n      if (from < 0) {\n        from += length;\n        if (from < 0) {\n          from = 0;\n        }\n      }\n      const isNaN = NumberIsNaN(element);\n      for (let i = from; i < length; ++i) {\n        const value = convertToNumber(float16bitsArray[i]);\n        if (isNaN && NumberIsNaN(value)) {\n          return true;\n        }\n        if (value === element) {\n          return true;\n        }\n      }\n      return false;\n    }\n    join(separator) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const array = copyToArray(float16bitsArray);\n      return ArrayPrototypeJoin(array, separator);\n    }\n    toLocaleString(...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const array = copyToArray(float16bitsArray);\n      return ArrayPrototypeToLocaleString(array, ...safeIfNeeded(opts));\n    }\n    get [SymbolToStringTag]() {\n      if (isFloat16Array(this)) {\n        return \"Float16Array\";\n      }\n    }\n  }\n  ObjectDefineProperty(Float16Array, \"BYTES_PER_ELEMENT\", {\n    value: BYTES_PER_ELEMENT\n  });\n  ObjectDefineProperty(Float16Array, brand, {});\n  ReflectSetPrototypeOf(Float16Array, TypedArray);\n  const Float16ArrayPrototype = Float16Array.prototype;\n  ObjectDefineProperty(Float16ArrayPrototype, \"BYTES_PER_ELEMENT\", {\n    value: BYTES_PER_ELEMENT\n  });\n  ObjectDefineProperty(Float16ArrayPrototype, SymbolIterator, {\n    value: Float16ArrayPrototype.values,\n    writable: true,\n    configurable: true\n  });\n  ReflectSetPrototypeOf(Float16ArrayPrototype, TypedArrayPrototype);\n  function isTypedArray(target) {\n    return isNativeTypedArray(target) || isFloat16Array(target);\n  }\n  function getFloat16(dataView, byteOffset, ...opts) {\n    return convertToNumber(DataViewPrototypeGetUint16(dataView, byteOffset, ...safeIfNeeded(opts)));\n  }\n  function setFloat16(dataView, byteOffset, value, ...opts) {\n    return DataViewPrototypeSetUint16(dataView, byteOffset, roundToFloat16Bits(value), ...safeIfNeeded(opts));\n  }\n  function f16round(x) {\n    return roundToFloat16(x);\n  }\n  exports.Float16Array = Float16Array;\n  exports.f16round = f16round;\n  exports.getFloat16 = getFloat16;\n  exports.hfround = f16round;\n  exports.isFloat16Array = isFloat16Array;\n  exports.isTypedArray = isTypedArray;\n  exports.setFloat16 = setFloat16;\n  Object.defineProperty(exports, Symbol.toStringTag, {\n    value: 'Module'\n  });\n  return exports;\n}({});","map":{"version":3,"names":["float16","exports","THIS_IS_NOT_AN_OBJECT","THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT","THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY","THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT","SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT","DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH","ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER","CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT","CANNOT_MIX_BIGINT_AND_OTHER_TYPES","ITERATOR_PROPERTY_IS_NOT_CALLABLE","REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE","THE_COMPARISON_FUNCTION_MUST_BE_EITHER_A_FUNCTION_OR_UNDEFINED","OFFSET_IS_OUT_OF_BOUNDS","uncurryThis","target","thisArg","args","ReflectApply","uncurryThisGetter","key","ReflectGetOwnPropertyDescriptor","get","apply","construct","ReflectConstruct","defineProperty","ReflectDefineProperty","ReflectGet","getOwnPropertyDescriptor","getPrototypeOf","ReflectGetPrototypeOf","has","ReflectHas","ownKeys","ReflectOwnKeys","set","ReflectSet","setPrototypeOf","ReflectSetPrototypeOf","Reflect","NativeProxy","Proxy","EPSILON","MAX_SAFE_INTEGER","isFinite","NumberIsFinite","isNaN","NumberIsNaN","Number","iterator","SymbolIterator","species","SymbolSpecies","toStringTag","SymbolToStringTag","for","SymbolFor","Symbol","NativeObject","Object","create","ObjectCreate","ObjectDefineProperty","freeze","ObjectFreeze","is","ObjectIs","ObjectPrototype","prototype","ObjectPrototype__lookupGetter__","__lookupGetter__","object","NativeTypeError","descriptor","undefined","ObjectHasOwn","hasOwn","hasOwnProperty","NativeArray","Array","ArrayIsArray","isArray","ArrayPrototype","ArrayPrototypeJoin","join","ArrayPrototypePush","push","ArrayPrototypeToLocaleString","toLocaleString","NativeArrayPrototypeSymbolIterator","ArrayPrototypeSymbolIterator","abs","MathAbs","trunc","MathTrunc","Math","NativeArrayBuffer","ArrayBuffer","ArrayBufferIsView","isView","ArrayBufferPrototype","ArrayBufferPrototypeSlice","slice","ArrayBufferPrototypeGetByteLength","NativeSharedArrayBuffer","SharedArrayBuffer","SharedArrayBufferPrototypeGetByteLength","TypedArray","Uint8Array","TypedArrayFrom","from","TypedArrayPrototype","NativeTypedArrayPrototypeSymbolIterator","TypedArrayPrototypeKeys","keys","TypedArrayPrototypeValues","values","TypedArrayPrototypeEntries","entries","TypedArrayPrototypeSet","TypedArrayPrototypeReverse","reverse","TypedArrayPrototypeFill","fill","TypedArrayPrototypeCopyWithin","copyWithin","TypedArrayPrototypeSort","sort","TypedArrayPrototypeSlice","TypedArrayPrototypeSubarray","subarray","TypedArrayPrototypeGetBuffer","TypedArrayPrototypeGetByteOffset","TypedArrayPrototypeGetLength","TypedArrayPrototypeGetSymbolToStringTag","NativeUint8Array","NativeUint16Array","Uint16Array","Uint16ArrayFrom","NativeUint32Array","Uint32Array","NativeFloat32Array","Float32Array","ArrayIteratorPrototype","ArrayIteratorPrototypeNext","next","GeneratorPrototypeNext","IteratorPrototype","DataViewPrototype","DataView","DataViewPrototypeGetUint16","getUint16","DataViewPrototypeSetUint16","setUint16","TypeError","NativeRangeError","RangeError","NativeWeakSet","WeakSet","WeakSetPrototype","WeakSetPrototypeAdd","add","WeakSetPrototypeHas","NativeWeakMap","WeakMap","WeakMapPrototype","WeakMapPrototypeGet","WeakMapPrototypeHas","WeakMapPrototypeSet","arrayIterators","SafeIteratorPrototype","value","arrayIterator","safeIfNeeded","array","safe","generators","DummyArrayIteratorPrototype","generator","writable","configurable","wrap","dummy","isObject","isObjectLike","isNativeTypedArray","isNativeBigIntTypedArray","typedArrayName","isArrayBuffer","e","isSharedArrayBuffer","isAnyArrayBuffer","isOrdinaryArray","isOrdinaryNativeTypedArray","isCanonicalIntegerIndexString","number","brand","hasFloat16ArrayBrand","constructor","INVERSE_OF_EPSILON","roundTiesToEven","num","FLOAT16_MIN_VALUE","FLOAT16_MAX_VALUE","FLOAT16_EPSILON","FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE","FLOAT16_EPSILON_DEVIDED_BY_EPSILON","roundToFloat16","sign","absolute","temp","result","Infinity","buffer","floatView","uint32View","baseTable","shiftTable","i","roundToFloat16Bits","f","mantissaTable","m","exponentTable","offsetTable","convertToNumber","float16bits","ToIntegerOrInfinity","ToLength","length","SpeciesConstructor","defaultConstructor","IsDetachedBuffer","defaultCompare","x","y","isXNaN","isYNaN","isXPlusZero","isYPlusZero","BYTES_PER_ELEMENT","float16bitsArrays","isFloat16Array","assertFloat16Array","assertSpeciesTypedArray","count","isTargetFloat16Array","isTargetTypedArray","float16bitsArray","getFloat16BitsArray","cloned","Float16Array","byteOffset","copyToArray","TypedArrayPrototypeGetters","handler","receiver","input","_byteOffset","_length","new","list","data","arguments","proxy","src","opts","Constructor","uint16","mapFunc","val","of","items","at","index","relativeIndex","k","with","map","callback","filter","kept","reduce","accumulator","start","reduceRight","forEach","find","findIndex","findLast","findLastIndex","every","some","targetOffset","targetLength","srcLength","toReversed","clonedFloat16bitsArray","compareFn","sortCompare","toSorted","end","relativeStart","relativeEnd","final","n","begin","uint16Subarray","indexOf","element","lastIndexOf","includes","separator","Float16ArrayPrototype","isTypedArray","getFloat16","dataView","setFloat16","f16round","hfround"],"sources":["/Users/yantinglong/Documents/project/frogather/node_modules/@petamoriken/float16/browser/float16.js"],"sourcesContent":["/*! @petamoriken/float16 v3.9.2 | MIT License - https://github.com/petamoriken/float16 */\n\nvar float16 = (function (exports) {\n  'use strict';\n\n  const THIS_IS_NOT_AN_OBJECT = \"This is not an object\";\n  const THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT = \"This is not a Float16Array object\";\n  const THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY =\n    \"This constructor is not a subclass of Float16Array\";\n  const THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT =\n    \"The constructor property value is not an object\";\n  const SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT =\n    \"Species constructor didn't return TypedArray object\";\n  const DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH =\n    \"Derived constructor created TypedArray object which was too small length\";\n  const ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER =\n    \"Attempting to access detached ArrayBuffer\";\n  const CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT =\n    \"Cannot convert undefined or null to object\";\n  const CANNOT_MIX_BIGINT_AND_OTHER_TYPES =\n    \"Cannot mix BigInt and other types, use explicit conversions\";\n  const ITERATOR_PROPERTY_IS_NOT_CALLABLE = \"@@iterator property is not callable\";\n  const REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE =\n    \"Reduce of empty array with no initial value\";\n  const THE_COMPARISON_FUNCTION_MUST_BE_EITHER_A_FUNCTION_OR_UNDEFINED =\n    \"The comparison function must be either a function or undefined\";\n  const OFFSET_IS_OUT_OF_BOUNDS = \"Offset is out of bounds\";\n\n  function uncurryThis(target) {\n    return (thisArg, ...args) => {\n      return ReflectApply(target, thisArg, args);\n    };\n  }\n  function uncurryThisGetter(target, key) {\n    return uncurryThis(\n      ReflectGetOwnPropertyDescriptor(\n        target,\n        key\n      ).get\n    );\n  }\n  const {\n    apply: ReflectApply,\n    construct: ReflectConstruct,\n    defineProperty: ReflectDefineProperty,\n    get: ReflectGet,\n    getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor,\n    getPrototypeOf: ReflectGetPrototypeOf,\n    has: ReflectHas,\n    ownKeys: ReflectOwnKeys,\n    set: ReflectSet,\n    setPrototypeOf: ReflectSetPrototypeOf,\n  } = Reflect;\n  const NativeProxy = Proxy;\n  const {\n    EPSILON,\n    MAX_SAFE_INTEGER,\n    isFinite: NumberIsFinite,\n    isNaN: NumberIsNaN,\n  } = Number;\n  const {\n    iterator: SymbolIterator,\n    species: SymbolSpecies,\n    toStringTag: SymbolToStringTag,\n    for: SymbolFor,\n  } = Symbol;\n  const NativeObject = Object;\n  const {\n    create: ObjectCreate,\n    defineProperty: ObjectDefineProperty,\n    freeze: ObjectFreeze,\n    is: ObjectIs,\n  } = NativeObject;\n  const ObjectPrototype = NativeObject.prototype;\n  const ObjectPrototype__lookupGetter__ =  (ObjectPrototype).__lookupGetter__\n    ? uncurryThis( (ObjectPrototype).__lookupGetter__)\n    : (object, key) => {\n      if (object == null) {\n        throw NativeTypeError(\n          CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT\n        );\n      }\n      let target = NativeObject(object);\n      do {\n        const descriptor = ReflectGetOwnPropertyDescriptor(target, key);\n        if (descriptor !== undefined) {\n          if (ObjectHasOwn(descriptor, \"get\")) {\n            return descriptor.get;\n          }\n          return;\n        }\n      } while ((target = ReflectGetPrototypeOf(target)) !== null);\n    };\n  const ObjectHasOwn =  (NativeObject).hasOwn ||\n    uncurryThis(ObjectPrototype.hasOwnProperty);\n  const NativeArray = Array;\n  const ArrayIsArray = NativeArray.isArray;\n  const ArrayPrototype = NativeArray.prototype;\n  const ArrayPrototypeJoin = uncurryThis(ArrayPrototype.join);\n  const ArrayPrototypePush = uncurryThis(ArrayPrototype.push);\n  const ArrayPrototypeToLocaleString = uncurryThis(\n    ArrayPrototype.toLocaleString\n  );\n  const NativeArrayPrototypeSymbolIterator = ArrayPrototype[SymbolIterator];\n  const ArrayPrototypeSymbolIterator = uncurryThis(NativeArrayPrototypeSymbolIterator);\n  const {\n    abs: MathAbs,\n    trunc: MathTrunc,\n  } = Math;\n  const NativeArrayBuffer = ArrayBuffer;\n  const ArrayBufferIsView = NativeArrayBuffer.isView;\n  const ArrayBufferPrototype = NativeArrayBuffer.prototype;\n  const ArrayBufferPrototypeSlice = uncurryThis(ArrayBufferPrototype.slice);\n  const ArrayBufferPrototypeGetByteLength = uncurryThisGetter(ArrayBufferPrototype, \"byteLength\");\n  const NativeSharedArrayBuffer = typeof SharedArrayBuffer !== \"undefined\" ? SharedArrayBuffer : null;\n  const SharedArrayBufferPrototypeGetByteLength = NativeSharedArrayBuffer\n    && uncurryThisGetter(NativeSharedArrayBuffer.prototype, \"byteLength\");\n  const TypedArray = ReflectGetPrototypeOf(Uint8Array);\n  const TypedArrayFrom = TypedArray.from;\n  const TypedArrayPrototype = TypedArray.prototype;\n  const NativeTypedArrayPrototypeSymbolIterator = TypedArrayPrototype[SymbolIterator];\n  const TypedArrayPrototypeKeys = uncurryThis(TypedArrayPrototype.keys);\n  const TypedArrayPrototypeValues = uncurryThis(\n    TypedArrayPrototype.values\n  );\n  const TypedArrayPrototypeEntries = uncurryThis(\n    TypedArrayPrototype.entries\n  );\n  const TypedArrayPrototypeSet = uncurryThis(TypedArrayPrototype.set);\n  const TypedArrayPrototypeReverse = uncurryThis(\n    TypedArrayPrototype.reverse\n  );\n  const TypedArrayPrototypeFill = uncurryThis(TypedArrayPrototype.fill);\n  const TypedArrayPrototypeCopyWithin = uncurryThis(\n    TypedArrayPrototype.copyWithin\n  );\n  const TypedArrayPrototypeSort = uncurryThis(TypedArrayPrototype.sort);\n  const TypedArrayPrototypeSlice = uncurryThis(TypedArrayPrototype.slice);\n  const TypedArrayPrototypeSubarray = uncurryThis(\n    TypedArrayPrototype.subarray\n  );\n  const TypedArrayPrototypeGetBuffer = uncurryThisGetter(\n    TypedArrayPrototype,\n    \"buffer\"\n  );\n  const TypedArrayPrototypeGetByteOffset = uncurryThisGetter(\n    TypedArrayPrototype,\n    \"byteOffset\"\n  );\n  const TypedArrayPrototypeGetLength = uncurryThisGetter(\n    TypedArrayPrototype,\n    \"length\"\n  );\n  const TypedArrayPrototypeGetSymbolToStringTag = uncurryThisGetter(\n    TypedArrayPrototype,\n    SymbolToStringTag\n  );\n  const NativeUint8Array = Uint8Array;\n  const NativeUint16Array = Uint16Array;\n  const Uint16ArrayFrom = (...args) => {\n    return ReflectApply(TypedArrayFrom, NativeUint16Array, args);\n  };\n  const NativeUint32Array = Uint32Array;\n  const NativeFloat32Array = Float32Array;\n  const ArrayIteratorPrototype = ReflectGetPrototypeOf([][SymbolIterator]());\n  const ArrayIteratorPrototypeNext = uncurryThis(ArrayIteratorPrototype.next);\n  const GeneratorPrototypeNext = uncurryThis((function* () {})().next);\n  const IteratorPrototype = ReflectGetPrototypeOf(ArrayIteratorPrototype);\n  const DataViewPrototype = DataView.prototype;\n  const DataViewPrototypeGetUint16 = uncurryThis(\n    DataViewPrototype.getUint16\n  );\n  const DataViewPrototypeSetUint16 = uncurryThis(\n    DataViewPrototype.setUint16\n  );\n  const NativeTypeError = TypeError;\n  const NativeRangeError = RangeError;\n  const NativeWeakSet = WeakSet;\n  const WeakSetPrototype = NativeWeakSet.prototype;\n  const WeakSetPrototypeAdd = uncurryThis(WeakSetPrototype.add);\n  const WeakSetPrototypeHas = uncurryThis(WeakSetPrototype.has);\n  const NativeWeakMap = WeakMap;\n  const WeakMapPrototype = NativeWeakMap.prototype;\n  const WeakMapPrototypeGet = uncurryThis(WeakMapPrototype.get);\n  const WeakMapPrototypeHas = uncurryThis(WeakMapPrototype.has);\n  const WeakMapPrototypeSet = uncurryThis(WeakMapPrototype.set);\n\n  const arrayIterators = new NativeWeakMap();\n  const SafeIteratorPrototype = ObjectCreate(null, {\n    next: {\n      value: function next() {\n        const arrayIterator = WeakMapPrototypeGet(arrayIterators, this);\n        return ArrayIteratorPrototypeNext(arrayIterator);\n      },\n    },\n    [SymbolIterator]: {\n      value: function values() {\n        return this;\n      },\n    },\n  });\n  function safeIfNeeded(array) {\n    if (\n      array[SymbolIterator] === NativeArrayPrototypeSymbolIterator &&\n      ArrayIteratorPrototype.next === ArrayIteratorPrototypeNext\n    ) {\n      return array;\n    }\n    const safe = ObjectCreate(SafeIteratorPrototype);\n    WeakMapPrototypeSet(arrayIterators, safe, ArrayPrototypeSymbolIterator(array));\n    return safe;\n  }\n  const generators = new NativeWeakMap();\n  const DummyArrayIteratorPrototype = ObjectCreate(IteratorPrototype, {\n    next: {\n      value: function next() {\n        const generator = WeakMapPrototypeGet(generators, this);\n        return GeneratorPrototypeNext(generator);\n      },\n      writable: true,\n      configurable: true,\n    },\n  });\n  for (const key of ReflectOwnKeys(ArrayIteratorPrototype)) {\n    if (key === \"next\") {\n      continue;\n    }\n    ObjectDefineProperty(DummyArrayIteratorPrototype, key, ReflectGetOwnPropertyDescriptor(ArrayIteratorPrototype, key));\n  }\n  function wrap(generator) {\n    const dummy = ObjectCreate(DummyArrayIteratorPrototype);\n    WeakMapPrototypeSet(generators, dummy, generator);\n    return dummy;\n  }\n\n  function isObject(value) {\n    return (\n      (value !== null && typeof value === \"object\") ||\n      typeof value === \"function\"\n    );\n  }\n  function isObjectLike(value) {\n    return value !== null && typeof value === \"object\";\n  }\n  function isNativeTypedArray(value) {\n    return TypedArrayPrototypeGetSymbolToStringTag(value) !== undefined;\n  }\n  function isNativeBigIntTypedArray(value) {\n    const typedArrayName = TypedArrayPrototypeGetSymbolToStringTag(value);\n    return (\n      typedArrayName === \"BigInt64Array\" ||\n      typedArrayName === \"BigUint64Array\"\n    );\n  }\n  function isArrayBuffer(value) {\n    try {\n      if (ArrayIsArray(value)) {\n        return false;\n      }\n      ArrayBufferPrototypeGetByteLength( (value));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  function isSharedArrayBuffer(value) {\n    if (NativeSharedArrayBuffer === null) {\n      return false;\n    }\n    try {\n      SharedArrayBufferPrototypeGetByteLength( (value));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  function isAnyArrayBuffer(value) {\n    return isArrayBuffer(value) || isSharedArrayBuffer(value);\n  }\n  function isOrdinaryArray(value) {\n    if (!ArrayIsArray(value)) {\n      return false;\n    }\n    return (\n      value[SymbolIterator] === NativeArrayPrototypeSymbolIterator &&\n      ArrayIteratorPrototype.next === ArrayIteratorPrototypeNext\n    );\n  }\n  function isOrdinaryNativeTypedArray(value) {\n    if (!isNativeTypedArray(value)) {\n      return false;\n    }\n    return (\n      value[SymbolIterator] === NativeTypedArrayPrototypeSymbolIterator &&\n      ArrayIteratorPrototype.next === ArrayIteratorPrototypeNext\n    );\n  }\n  function isCanonicalIntegerIndexString(value) {\n    if (typeof value !== \"string\") {\n      return false;\n    }\n    const number = +value;\n    if (value !== number + \"\") {\n      return false;\n    }\n    if (!NumberIsFinite(number)) {\n      return false;\n    }\n    return number === MathTrunc(number);\n  }\n\n  const brand = SymbolFor(\"__Float16Array__\");\n  function hasFloat16ArrayBrand(target) {\n    if (!isObjectLike(target)) {\n      return false;\n    }\n    const prototype = ReflectGetPrototypeOf(target);\n    if (!isObjectLike(prototype)) {\n      return false;\n    }\n    const constructor = prototype.constructor;\n    if (constructor === undefined) {\n      return false;\n    }\n    if (!isObject(constructor)) {\n      throw NativeTypeError(THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT);\n    }\n    return ReflectHas(constructor, brand);\n  }\n\n  const INVERSE_OF_EPSILON = 1 / EPSILON;\n  function roundTiesToEven(num) {\n    return (num + INVERSE_OF_EPSILON) - INVERSE_OF_EPSILON;\n  }\n  const FLOAT16_MIN_VALUE = 6.103515625e-05;\n  const FLOAT16_MAX_VALUE = 65504;\n  const FLOAT16_EPSILON = 0.0009765625;\n  const FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE = FLOAT16_EPSILON * FLOAT16_MIN_VALUE;\n  const FLOAT16_EPSILON_DEVIDED_BY_EPSILON = FLOAT16_EPSILON * INVERSE_OF_EPSILON;\n  function roundToFloat16(num) {\n    const number = +num;\n    if (!NumberIsFinite(number) || number === 0) {\n      return number;\n    }\n    const sign = number > 0 ? 1 : -1;\n    const absolute = MathAbs(number);\n    if (absolute < FLOAT16_MIN_VALUE) {\n      return sign * roundTiesToEven(absolute / FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE) * FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE;\n    }\n    const temp = (1 + FLOAT16_EPSILON_DEVIDED_BY_EPSILON) * absolute;\n    const result = temp - (temp - absolute);\n    if (result > FLOAT16_MAX_VALUE || NumberIsNaN(result)) {\n      return sign * Infinity;\n    }\n    return sign * result;\n  }\n  const buffer = new NativeArrayBuffer(4);\n  const floatView = new NativeFloat32Array(buffer);\n  const uint32View = new NativeUint32Array(buffer);\n  const baseTable = new NativeUint16Array(512);\n  const shiftTable = new NativeUint8Array(512);\n  for (let i = 0; i < 256; ++i) {\n    const e = i - 127;\n    if (e < -24) {\n      baseTable[i]         = 0x0000;\n      baseTable[i | 0x100] = 0x8000;\n      shiftTable[i]         = 24;\n      shiftTable[i | 0x100] = 24;\n    } else if (e < -14) {\n      baseTable[i]         =  0x0400 >> (-e - 14);\n      baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;\n      shiftTable[i]         = -e - 1;\n      shiftTable[i | 0x100] = -e - 1;\n    } else if (e <= 15) {\n      baseTable[i]         =  (e + 15) << 10;\n      baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;\n      shiftTable[i]         = 13;\n      shiftTable[i | 0x100] = 13;\n    } else if (e < 128) {\n      baseTable[i]         = 0x7c00;\n      baseTable[i | 0x100] = 0xfc00;\n      shiftTable[i]         = 24;\n      shiftTable[i | 0x100] = 24;\n    } else {\n      baseTable[i]         = 0x7c00;\n      baseTable[i | 0x100] = 0xfc00;\n      shiftTable[i]         = 13;\n      shiftTable[i | 0x100] = 13;\n    }\n  }\n  function roundToFloat16Bits(num) {\n    floatView[0] = roundToFloat16(num);\n    const f = uint32View[0];\n    const e = (f >> 23) & 0x1ff;\n    return baseTable[e] + ((f & 0x007fffff) >> shiftTable[e]);\n  }\n  const mantissaTable = new NativeUint32Array(2048);\n  for (let i = 1; i < 1024; ++i) {\n    let m = i << 13;\n    let e = 0;\n    while ((m & 0x00800000) === 0) {\n      m <<= 1;\n      e -= 0x00800000;\n    }\n    m &= -8388609;\n    e += 0x38800000;\n    mantissaTable[i] = m | e;\n  }\n  for (let i = 1024; i < 2048; ++i) {\n    mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);\n  }\n  const exponentTable = new NativeUint32Array(64);\n  for (let i = 1; i < 31; ++i) {\n    exponentTable[i] = i << 23;\n  }\n  exponentTable[31] = 0x47800000;\n  exponentTable[32] = 0x80000000;\n  for (let i = 33; i < 63; ++i) {\n    exponentTable[i] = 0x80000000 + ((i - 32) << 23);\n  }\n  exponentTable[63] = 0xc7800000;\n  const offsetTable = new NativeUint16Array(64);\n  for (let i = 1; i < 64; ++i) {\n    if (i !== 32) {\n      offsetTable[i] = 1024;\n    }\n  }\n  function convertToNumber(float16bits) {\n    const i = float16bits >> 10;\n    uint32View[0] = mantissaTable[offsetTable[i] + (float16bits & 0x3ff)] + exponentTable[i];\n    return floatView[0];\n  }\n\n  function ToIntegerOrInfinity(target) {\n    const number = +target;\n    if (NumberIsNaN(number) || number === 0) {\n      return 0;\n    }\n    return MathTrunc(number);\n  }\n  function ToLength(target) {\n    const length = ToIntegerOrInfinity(target);\n    if (length < 0) {\n      return 0;\n    }\n    return length < MAX_SAFE_INTEGER\n      ? length\n      : MAX_SAFE_INTEGER;\n  }\n  function SpeciesConstructor(target, defaultConstructor) {\n    if (!isObject(target)) {\n      throw NativeTypeError(THIS_IS_NOT_AN_OBJECT);\n    }\n    const constructor = target.constructor;\n    if (constructor === undefined) {\n      return defaultConstructor;\n    }\n    if (!isObject(constructor)) {\n      throw NativeTypeError(THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT);\n    }\n    const species = constructor[SymbolSpecies];\n    if (species == null) {\n      return defaultConstructor;\n    }\n    return species;\n  }\n  function IsDetachedBuffer(buffer) {\n    if (isSharedArrayBuffer(buffer)) {\n      return false;\n    }\n    try {\n      ArrayBufferPrototypeSlice(buffer, 0, 0);\n      return false;\n    } catch (e) {}\n    return true;\n  }\n  function defaultCompare(x, y) {\n    const isXNaN = NumberIsNaN(x);\n    const isYNaN = NumberIsNaN(y);\n    if (isXNaN && isYNaN) {\n      return 0;\n    }\n    if (isXNaN) {\n      return 1;\n    }\n    if (isYNaN) {\n      return -1;\n    }\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    if (x === 0 && y === 0) {\n      const isXPlusZero = ObjectIs(x, 0);\n      const isYPlusZero = ObjectIs(y, 0);\n      if (!isXPlusZero && isYPlusZero) {\n        return -1;\n      }\n      if (isXPlusZero && !isYPlusZero) {\n        return 1;\n      }\n    }\n    return 0;\n  }\n\n  const BYTES_PER_ELEMENT = 2;\n  const float16bitsArrays = new NativeWeakMap();\n  function isFloat16Array(target) {\n    return WeakMapPrototypeHas(float16bitsArrays, target) ||\n      (!ArrayBufferIsView(target) && hasFloat16ArrayBrand(target));\n  }\n  function assertFloat16Array(target) {\n    if (!isFloat16Array(target)) {\n      throw NativeTypeError(THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT);\n    }\n  }\n  function assertSpeciesTypedArray(target, count) {\n    const isTargetFloat16Array = isFloat16Array(target);\n    const isTargetTypedArray = isNativeTypedArray(target);\n    if (!isTargetFloat16Array && !isTargetTypedArray) {\n      throw NativeTypeError(SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT);\n    }\n    if (typeof count === \"number\") {\n      let length;\n      if (isTargetFloat16Array) {\n        const float16bitsArray = getFloat16BitsArray(target);\n        length = TypedArrayPrototypeGetLength(float16bitsArray);\n      } else {\n        length = TypedArrayPrototypeGetLength(target);\n      }\n      if (length < count) {\n        throw NativeTypeError(\n          DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH\n        );\n      }\n    }\n    if (isNativeBigIntTypedArray(target)) {\n      throw NativeTypeError(CANNOT_MIX_BIGINT_AND_OTHER_TYPES);\n    }\n  }\n  function getFloat16BitsArray(float16) {\n    const float16bitsArray = WeakMapPrototypeGet(float16bitsArrays, float16);\n    if (float16bitsArray !== undefined) {\n      const buffer = TypedArrayPrototypeGetBuffer(float16bitsArray);\n      if (IsDetachedBuffer(buffer)) {\n        throw NativeTypeError(ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);\n      }\n      return float16bitsArray;\n    }\n    const buffer =  (float16).buffer;\n    if (IsDetachedBuffer(buffer)) {\n      throw NativeTypeError(ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);\n    }\n    const cloned = ReflectConstruct(Float16Array, [\n      buffer,\n       (float16).byteOffset,\n       (float16).length,\n    ], float16.constructor);\n    return WeakMapPrototypeGet(float16bitsArrays, cloned);\n  }\n  function copyToArray(float16bitsArray) {\n    const length = TypedArrayPrototypeGetLength(float16bitsArray);\n    const array = [];\n    for (let i = 0; i < length; ++i) {\n      array[i] = convertToNumber(float16bitsArray[i]);\n    }\n    return array;\n  }\n  const TypedArrayPrototypeGetters = new NativeWeakSet();\n  for (const key of ReflectOwnKeys(TypedArrayPrototype)) {\n    if (key === SymbolToStringTag) {\n      continue;\n    }\n    const descriptor = ReflectGetOwnPropertyDescriptor(TypedArrayPrototype, key);\n    if (ObjectHasOwn(descriptor, \"get\") && typeof descriptor.get === \"function\") {\n      WeakSetPrototypeAdd(TypedArrayPrototypeGetters, descriptor.get);\n    }\n  }\n  const handler = ObjectFreeze( ({\n    get(target, key, receiver) {\n      if (isCanonicalIntegerIndexString(key) && ObjectHasOwn(target, key)) {\n        return convertToNumber(ReflectGet(target, key));\n      }\n      if (WeakSetPrototypeHas(TypedArrayPrototypeGetters, ObjectPrototype__lookupGetter__(target, key))) {\n        return ReflectGet(target, key);\n      }\n      return ReflectGet(target, key, receiver);\n    },\n    set(target, key, value, receiver) {\n      if (isCanonicalIntegerIndexString(key) && ObjectHasOwn(target, key)) {\n        return ReflectSet(target, key, roundToFloat16Bits(value));\n      }\n      return ReflectSet(target, key, value, receiver);\n    },\n    getOwnPropertyDescriptor(target, key) {\n      if (isCanonicalIntegerIndexString(key) && ObjectHasOwn(target, key)) {\n        const descriptor = ReflectGetOwnPropertyDescriptor(target, key);\n        descriptor.value = convertToNumber(descriptor.value);\n        return descriptor;\n      }\n      return ReflectGetOwnPropertyDescriptor(target, key);\n    },\n    defineProperty(target, key, descriptor) {\n      if (\n        isCanonicalIntegerIndexString(key) &&\n        ObjectHasOwn(target, key) &&\n        ObjectHasOwn(descriptor, \"value\")\n      ) {\n        descriptor.value = roundToFloat16Bits(descriptor.value);\n        return ReflectDefineProperty(target, key, descriptor);\n      }\n      return ReflectDefineProperty(target, key, descriptor);\n    },\n  }));\n  class Float16Array {\n    constructor(input, _byteOffset, _length) {\n      let float16bitsArray;\n      if (isFloat16Array(input)) {\n        float16bitsArray = ReflectConstruct(NativeUint16Array, [getFloat16BitsArray(input)], new.target);\n      } else if (isObject(input) && !isAnyArrayBuffer(input)) {\n        let list;\n        let length;\n        if (isNativeTypedArray(input)) {\n          list = input;\n          length = TypedArrayPrototypeGetLength(input);\n          const buffer = TypedArrayPrototypeGetBuffer(input);\n          if (IsDetachedBuffer(buffer)) {\n            throw NativeTypeError(ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);\n          }\n          if (isNativeBigIntTypedArray(input)) {\n            throw NativeTypeError(CANNOT_MIX_BIGINT_AND_OTHER_TYPES);\n          }\n          const data = new NativeArrayBuffer(\n            length * BYTES_PER_ELEMENT\n          );\n          float16bitsArray = ReflectConstruct(NativeUint16Array, [data], new.target);\n        } else {\n          const iterator = input[SymbolIterator];\n          if (iterator != null && typeof iterator !== \"function\") {\n            throw NativeTypeError(ITERATOR_PROPERTY_IS_NOT_CALLABLE);\n          }\n          if (iterator != null) {\n            if (isOrdinaryArray(input)) {\n              list = input;\n              length = input.length;\n            } else {\n              list = [...  (input)];\n              length = list.length;\n            }\n          } else {\n            list =  (input);\n            length = ToLength(list.length);\n          }\n          float16bitsArray = ReflectConstruct(NativeUint16Array, [length], new.target);\n        }\n        for (let i = 0; i < length; ++i) {\n          float16bitsArray[i] = roundToFloat16Bits(list[i]);\n        }\n      } else {\n        float16bitsArray = ReflectConstruct(NativeUint16Array, arguments, new.target);\n      }\n      const proxy =  (new NativeProxy(float16bitsArray, handler));\n      WeakMapPrototypeSet(float16bitsArrays, proxy, float16bitsArray);\n      return proxy;\n    }\n    static from(src, ...opts) {\n      const Constructor = this;\n      if (!ReflectHas(Constructor, brand)) {\n        throw NativeTypeError(\n          THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY\n        );\n      }\n      if (Constructor === Float16Array) {\n        if (isFloat16Array(src) && opts.length === 0) {\n          const float16bitsArray = getFloat16BitsArray(src);\n          const uint16 = new NativeUint16Array(\n            TypedArrayPrototypeGetBuffer(float16bitsArray),\n            TypedArrayPrototypeGetByteOffset(float16bitsArray),\n            TypedArrayPrototypeGetLength(float16bitsArray)\n          );\n          return new Float16Array(\n            TypedArrayPrototypeGetBuffer(TypedArrayPrototypeSlice(uint16))\n          );\n        }\n        if (opts.length === 0) {\n          return new Float16Array(\n            TypedArrayPrototypeGetBuffer(\n              Uint16ArrayFrom(src, roundToFloat16Bits)\n            )\n          );\n        }\n        const mapFunc = opts[0];\n        const thisArg = opts[1];\n        return new Float16Array(\n          TypedArrayPrototypeGetBuffer(\n            Uint16ArrayFrom(src, function (val, ...args) {\n              return roundToFloat16Bits(\n                ReflectApply(mapFunc, this, [val, ...safeIfNeeded(args)])\n              );\n            }, thisArg)\n          )\n        );\n      }\n      let list;\n      let length;\n      const iterator = src[SymbolIterator];\n      if (iterator != null && typeof iterator !== \"function\") {\n        throw NativeTypeError(ITERATOR_PROPERTY_IS_NOT_CALLABLE);\n      }\n      if (iterator != null) {\n        if (isOrdinaryArray(src)) {\n          list = src;\n          length = src.length;\n        } else if (isOrdinaryNativeTypedArray(src)) {\n          list = src;\n          length = TypedArrayPrototypeGetLength(src);\n        } else {\n          list = [...src];\n          length = list.length;\n        }\n      } else {\n        if (src == null) {\n          throw NativeTypeError(\n            CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT\n          );\n        }\n        list = NativeObject(src);\n        length = ToLength(list.length);\n      }\n      const array = new Constructor(length);\n      if (opts.length === 0) {\n        for (let i = 0; i < length; ++i) {\n          array[i] =  (list[i]);\n        }\n      } else {\n        const mapFunc = opts[0];\n        const thisArg = opts[1];\n        for (let i = 0; i < length; ++i) {\n          array[i] = ReflectApply(mapFunc, thisArg, [list[i], i]);\n        }\n      }\n      return array;\n    }\n    static of(...items) {\n      const Constructor = this;\n      if (!ReflectHas(Constructor, brand)) {\n        throw NativeTypeError(\n          THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY\n        );\n      }\n      const length = items.length;\n      if (Constructor === Float16Array) {\n        const proxy = new Float16Array(length);\n        const float16bitsArray = getFloat16BitsArray(proxy);\n        for (let i = 0; i < length; ++i) {\n          float16bitsArray[i] = roundToFloat16Bits(items[i]);\n        }\n        return proxy;\n      }\n      const array = new Constructor(length);\n      for (let i = 0; i < length; ++i) {\n        array[i] = items[i];\n      }\n      return array;\n    }\n    keys() {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      return TypedArrayPrototypeKeys(float16bitsArray);\n    }\n    values() {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      return wrap((function* () {\n        for (const val of TypedArrayPrototypeValues(float16bitsArray)) {\n          yield convertToNumber(val);\n        }\n      })());\n    }\n    entries() {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      return wrap((function* () {\n        for (const [i, val] of TypedArrayPrototypeEntries(float16bitsArray)) {\n          yield  ([i, convertToNumber(val)]);\n        }\n      })());\n    }\n    at(index) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const relativeIndex = ToIntegerOrInfinity(index);\n      const k = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n      if (k < 0 || k >= length) {\n        return;\n      }\n      return convertToNumber(float16bitsArray[k]);\n    }\n    with(index, value) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const relativeIndex = ToIntegerOrInfinity(index);\n      const k = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n      const number = +value;\n      if (k < 0 || k >= length) {\n        throw NativeRangeError(OFFSET_IS_OUT_OF_BOUNDS);\n      }\n      const uint16 = new NativeUint16Array(\n        TypedArrayPrototypeGetBuffer(float16bitsArray),\n        TypedArrayPrototypeGetByteOffset(float16bitsArray),\n        TypedArrayPrototypeGetLength(float16bitsArray)\n      );\n      const cloned = new Float16Array(\n        TypedArrayPrototypeGetBuffer(\n          TypedArrayPrototypeSlice(uint16)\n        )\n      );\n      const array = getFloat16BitsArray(cloned);\n      array[k] = roundToFloat16Bits(number);\n      return cloned;\n    }\n    map(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const thisArg = opts[0];\n      const Constructor = SpeciesConstructor(float16bitsArray, Float16Array);\n      if (Constructor === Float16Array) {\n        const proxy = new Float16Array(length);\n        const array = getFloat16BitsArray(proxy);\n        for (let i = 0; i < length; ++i) {\n          const val = convertToNumber(float16bitsArray[i]);\n          array[i] = roundToFloat16Bits(\n            ReflectApply(callback, thisArg, [val, i, this])\n          );\n        }\n        return proxy;\n      }\n      const array = new Constructor(length);\n      assertSpeciesTypedArray(array, length);\n      for (let i = 0; i < length; ++i) {\n        const val = convertToNumber(float16bitsArray[i]);\n        array[i] = ReflectApply(callback, thisArg, [val, i, this]);\n      }\n      return  (array);\n    }\n    filter(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const thisArg = opts[0];\n      const kept = [];\n      for (let i = 0; i < length; ++i) {\n        const val = convertToNumber(float16bitsArray[i]);\n        if (ReflectApply(callback, thisArg, [val, i, this])) {\n          ArrayPrototypePush(kept, val);\n        }\n      }\n      const Constructor = SpeciesConstructor(float16bitsArray, Float16Array);\n      const array = new Constructor(kept);\n      assertSpeciesTypedArray(array);\n      return  (array);\n    }\n    reduce(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      if (length === 0 && opts.length === 0) {\n        throw NativeTypeError(REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE);\n      }\n      let accumulator, start;\n      if (opts.length === 0) {\n        accumulator = convertToNumber(float16bitsArray[0]);\n        start = 1;\n      } else {\n        accumulator = opts[0];\n        start = 0;\n      }\n      for (let i = start; i < length; ++i) {\n        accumulator = callback(\n          accumulator,\n          convertToNumber(float16bitsArray[i]),\n          i,\n          this\n        );\n      }\n      return accumulator;\n    }\n    reduceRight(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      if (length === 0 && opts.length === 0) {\n        throw NativeTypeError(REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE);\n      }\n      let accumulator, start;\n      if (opts.length === 0) {\n        accumulator = convertToNumber(float16bitsArray[length - 1]);\n        start = length - 2;\n      } else {\n        accumulator = opts[0];\n        start = length - 1;\n      }\n      for (let i = start; i >= 0; --i) {\n        accumulator = callback(\n          accumulator,\n          convertToNumber(float16bitsArray[i]),\n          i,\n          this\n        );\n      }\n      return accumulator;\n    }\n    forEach(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const thisArg = opts[0];\n      for (let i = 0; i < length; ++i) {\n        ReflectApply(callback, thisArg, [\n          convertToNumber(float16bitsArray[i]),\n          i,\n          this,\n        ]);\n      }\n    }\n    find(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const thisArg = opts[0];\n      for (let i = 0; i < length; ++i) {\n        const value = convertToNumber(float16bitsArray[i]);\n        if (ReflectApply(callback, thisArg, [value, i, this])) {\n          return value;\n        }\n      }\n    }\n    findIndex(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const thisArg = opts[0];\n      for (let i = 0; i < length; ++i) {\n        const value = convertToNumber(float16bitsArray[i]);\n        if (ReflectApply(callback, thisArg, [value, i, this])) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    findLast(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const thisArg = opts[0];\n      for (let i = length - 1; i >= 0; --i) {\n        const value = convertToNumber(float16bitsArray[i]);\n        if (ReflectApply(callback, thisArg, [value, i, this])) {\n          return value;\n        }\n      }\n    }\n    findLastIndex(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const thisArg = opts[0];\n      for (let i = length - 1; i >= 0; --i) {\n        const value = convertToNumber(float16bitsArray[i]);\n        if (ReflectApply(callback, thisArg, [value, i, this])) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    every(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const thisArg = opts[0];\n      for (let i = 0; i < length; ++i) {\n        if (\n          !ReflectApply(callback, thisArg, [\n            convertToNumber(float16bitsArray[i]),\n            i,\n            this,\n          ])\n        ) {\n          return false;\n        }\n      }\n      return true;\n    }\n    some(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const thisArg = opts[0];\n      for (let i = 0; i < length; ++i) {\n        if (\n          ReflectApply(callback, thisArg, [\n            convertToNumber(float16bitsArray[i]),\n            i,\n            this,\n          ])\n        ) {\n          return true;\n        }\n      }\n      return false;\n    }\n    set(input, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const targetOffset = ToIntegerOrInfinity(opts[0]);\n      if (targetOffset < 0) {\n        throw NativeRangeError(OFFSET_IS_OUT_OF_BOUNDS);\n      }\n      if (input == null) {\n        throw NativeTypeError(\n          CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT\n        );\n      }\n      if (isNativeBigIntTypedArray(input)) {\n        throw NativeTypeError(\n          CANNOT_MIX_BIGINT_AND_OTHER_TYPES\n        );\n      }\n      if (isFloat16Array(input)) {\n        return TypedArrayPrototypeSet(\n          getFloat16BitsArray(this),\n          getFloat16BitsArray(input),\n          targetOffset\n        );\n      }\n      if (isNativeTypedArray(input)) {\n        const buffer = TypedArrayPrototypeGetBuffer(input);\n        if (IsDetachedBuffer(buffer)) {\n          throw NativeTypeError(ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);\n        }\n      }\n      const targetLength = TypedArrayPrototypeGetLength(float16bitsArray);\n      const src = NativeObject(input);\n      const srcLength = ToLength(src.length);\n      if (targetOffset === Infinity || srcLength + targetOffset > targetLength) {\n        throw NativeRangeError(OFFSET_IS_OUT_OF_BOUNDS);\n      }\n      for (let i = 0; i < srcLength; ++i) {\n        float16bitsArray[i + targetOffset] = roundToFloat16Bits(src[i]);\n      }\n    }\n    reverse() {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      TypedArrayPrototypeReverse(float16bitsArray);\n      return this;\n    }\n    toReversed() {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const uint16 = new NativeUint16Array(\n        TypedArrayPrototypeGetBuffer(float16bitsArray),\n        TypedArrayPrototypeGetByteOffset(float16bitsArray),\n        TypedArrayPrototypeGetLength(float16bitsArray)\n      );\n      const cloned = new Float16Array(\n        TypedArrayPrototypeGetBuffer(\n          TypedArrayPrototypeSlice(uint16)\n        )\n      );\n      const clonedFloat16bitsArray = getFloat16BitsArray(cloned);\n      TypedArrayPrototypeReverse(clonedFloat16bitsArray);\n      return cloned;\n    }\n    fill(value, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      TypedArrayPrototypeFill(\n        float16bitsArray,\n        roundToFloat16Bits(value),\n        ...safeIfNeeded(opts)\n      );\n      return this;\n    }\n    copyWithin(target, start, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      TypedArrayPrototypeCopyWithin(float16bitsArray, target, start, ...safeIfNeeded(opts));\n      return this;\n    }\n    sort(compareFn) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const sortCompare = compareFn !== undefined ? compareFn : defaultCompare;\n      TypedArrayPrototypeSort(float16bitsArray, (x, y) => {\n        return sortCompare(convertToNumber(x), convertToNumber(y));\n      });\n      return this;\n    }\n    toSorted(compareFn) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      if (compareFn !== undefined && typeof compareFn !== \"function\") {\n        throw new NativeTypeError(THE_COMPARISON_FUNCTION_MUST_BE_EITHER_A_FUNCTION_OR_UNDEFINED);\n      }\n      const sortCompare = compareFn !== undefined ? compareFn : defaultCompare;\n      const uint16 = new NativeUint16Array(\n        TypedArrayPrototypeGetBuffer(float16bitsArray),\n        TypedArrayPrototypeGetByteOffset(float16bitsArray),\n        TypedArrayPrototypeGetLength(float16bitsArray)\n      );\n      const cloned = new Float16Array(\n        TypedArrayPrototypeGetBuffer(\n          TypedArrayPrototypeSlice(uint16)\n        )\n      );\n      const clonedFloat16bitsArray = getFloat16BitsArray(cloned);\n      TypedArrayPrototypeSort(clonedFloat16bitsArray, (x, y) => {\n        return sortCompare(convertToNumber(x), convertToNumber(y));\n      });\n      return cloned;\n    }\n    slice(start, end) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const Constructor = SpeciesConstructor(float16bitsArray, Float16Array);\n      if (Constructor === Float16Array) {\n        const uint16 = new NativeUint16Array(\n          TypedArrayPrototypeGetBuffer(float16bitsArray),\n          TypedArrayPrototypeGetByteOffset(float16bitsArray),\n          TypedArrayPrototypeGetLength(float16bitsArray)\n        );\n        return new Float16Array(\n          TypedArrayPrototypeGetBuffer(\n            TypedArrayPrototypeSlice(uint16, start, end)\n          )\n        );\n      }\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const relativeStart = ToIntegerOrInfinity(start);\n      const relativeEnd = end === undefined ? length : ToIntegerOrInfinity(end);\n      let k;\n      if (relativeStart === -Infinity) {\n        k = 0;\n      } else if (relativeStart < 0) {\n        k = length + relativeStart > 0 ? length + relativeStart : 0;\n      } else {\n        k = length < relativeStart ? length : relativeStart;\n      }\n      let final;\n      if (relativeEnd === -Infinity) {\n        final = 0;\n      } else if (relativeEnd < 0) {\n        final = length + relativeEnd > 0 ? length + relativeEnd : 0;\n      } else {\n        final = length < relativeEnd ? length : relativeEnd;\n      }\n      const count = final - k > 0 ? final - k : 0;\n      const array = new Constructor(count);\n      assertSpeciesTypedArray(array, count);\n      if (count === 0) {\n        return array;\n      }\n      const buffer = TypedArrayPrototypeGetBuffer(float16bitsArray);\n      if (IsDetachedBuffer(buffer)) {\n        throw NativeTypeError(ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);\n      }\n      let n = 0;\n      while (k < final) {\n        array[n] = convertToNumber(float16bitsArray[k]);\n        ++k;\n        ++n;\n      }\n      return  (array);\n    }\n    subarray(begin, end) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const Constructor = SpeciesConstructor(float16bitsArray, Float16Array);\n      const uint16 = new NativeUint16Array(\n        TypedArrayPrototypeGetBuffer(float16bitsArray),\n        TypedArrayPrototypeGetByteOffset(float16bitsArray),\n        TypedArrayPrototypeGetLength(float16bitsArray)\n      );\n      const uint16Subarray = TypedArrayPrototypeSubarray(uint16, begin, end);\n      const array = new Constructor(\n        TypedArrayPrototypeGetBuffer(uint16Subarray),\n        TypedArrayPrototypeGetByteOffset(uint16Subarray),\n        TypedArrayPrototypeGetLength(uint16Subarray)\n      );\n      assertSpeciesTypedArray(array);\n      return  (array);\n    }\n    indexOf(element, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      let from = ToIntegerOrInfinity(opts[0]);\n      if (from === Infinity) {\n        return -1;\n      }\n      if (from < 0) {\n        from += length;\n        if (from < 0) {\n          from = 0;\n        }\n      }\n      for (let i = from; i < length; ++i) {\n        if (\n          ObjectHasOwn(float16bitsArray, i) &&\n          convertToNumber(float16bitsArray[i]) === element\n        ) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    lastIndexOf(element, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      let from = opts.length >= 1 ? ToIntegerOrInfinity(opts[0]) : length - 1;\n      if (from === -Infinity) {\n        return -1;\n      }\n      if (from >= 0) {\n        from = from < length - 1 ? from : length - 1;\n      } else {\n        from += length;\n      }\n      for (let i = from; i >= 0; --i) {\n        if (\n          ObjectHasOwn(float16bitsArray, i) &&\n          convertToNumber(float16bitsArray[i]) === element\n        ) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    includes(element, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      let from = ToIntegerOrInfinity(opts[0]);\n      if (from === Infinity) {\n        return false;\n      }\n      if (from < 0) {\n        from += length;\n        if (from < 0) {\n          from = 0;\n        }\n      }\n      const isNaN = NumberIsNaN(element);\n      for (let i = from; i < length; ++i) {\n        const value = convertToNumber(float16bitsArray[i]);\n        if (isNaN && NumberIsNaN(value)) {\n          return true;\n        }\n        if (value === element) {\n          return true;\n        }\n      }\n      return false;\n    }\n    join(separator) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const array = copyToArray(float16bitsArray);\n      return ArrayPrototypeJoin(array, separator);\n    }\n    toLocaleString(...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const array = copyToArray(float16bitsArray);\n      return ArrayPrototypeToLocaleString(array, ...safeIfNeeded(opts));\n    }\n    get [SymbolToStringTag]() {\n      if (isFloat16Array(this)) {\n        return  (\"Float16Array\");\n      }\n    }\n  }\n  ObjectDefineProperty(Float16Array, \"BYTES_PER_ELEMENT\", {\n    value: BYTES_PER_ELEMENT,\n  });\n  ObjectDefineProperty(Float16Array, brand, {});\n  ReflectSetPrototypeOf(Float16Array, TypedArray);\n  const Float16ArrayPrototype = Float16Array.prototype;\n  ObjectDefineProperty(Float16ArrayPrototype, \"BYTES_PER_ELEMENT\", {\n    value: BYTES_PER_ELEMENT,\n  });\n  ObjectDefineProperty(Float16ArrayPrototype, SymbolIterator, {\n    value: Float16ArrayPrototype.values,\n    writable: true,\n    configurable: true,\n  });\n  ReflectSetPrototypeOf(Float16ArrayPrototype, TypedArrayPrototype);\n\n  function isTypedArray(target) {\n    return isNativeTypedArray(target) || isFloat16Array(target);\n  }\n\n  function getFloat16(dataView, byteOffset, ...opts) {\n    return convertToNumber(\n      DataViewPrototypeGetUint16(dataView, byteOffset, ...safeIfNeeded(opts))\n    );\n  }\n  function setFloat16(dataView, byteOffset, value, ...opts) {\n    return DataViewPrototypeSetUint16(\n      dataView,\n      byteOffset,\n      roundToFloat16Bits(value),\n      ...safeIfNeeded(opts)\n    );\n  }\n\n  function f16round(x) {\n    return roundToFloat16(x);\n  }\n\n  exports.Float16Array = Float16Array;\n  exports.f16round = f16round;\n  exports.getFloat16 = getFloat16;\n  exports.hfround = f16round;\n  exports.isFloat16Array = isFloat16Array;\n  exports.isTypedArray = isTypedArray;\n  exports.setFloat16 = setFloat16;\n\n  Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\n  return exports;\n\n})({});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}
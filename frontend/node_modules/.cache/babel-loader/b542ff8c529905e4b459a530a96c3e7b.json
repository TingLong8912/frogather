{"ast":null,"code":"/**\n * Utilities for parsing literal style objects\n * @module ol/webgl/styleparser\n */\nimport { ShaderBuilder } from './ShaderBuilder.js';\nimport { ValueTypes, expressionToGlsl, getStringNumberEquivalent, uniformNameForVariable } from '../style/expressions.js';\nimport { asArray } from '../color.js';\n\n/**\n * @param {import('../style/literal.js').SymbolType} type Symbol type\n * @param {string} sizeExpressionGlsl Size expression\n * @return {string} The GLSL opacity function\n */\nexport function getSymbolOpacityGlslFunction(type, sizeExpressionGlsl) {\n  switch (type) {\n    case 'square':\n    case 'image':\n      return '1.0';\n    // taken from https://thebookofshaders.com/07/\n    case 'circle':\n      return `(1.0-smoothstep(1.-4./${sizeExpressionGlsl},1.,dot(v_quadCoord-.5,v_quadCoord-.5)*4.))`;\n    case 'triangle':\n      const st = '(v_quadCoord*2.-1.)';\n      const a = `(atan(${st}.x,${st}.y))`;\n      return `(1.0-smoothstep(.5-3./${sizeExpressionGlsl},.5,cos(floor(.5+${a}/2.094395102)*2.094395102-${a})*length(${st})))`;\n    default:\n      throw new Error(`Unexpected symbol type: ${type}`);\n  }\n}\n\n/**\n * Packs all components of a color into a two-floats array\n * @param {import(\"../color.js\").Color|string} color Color as array of numbers or string\n * @return {Array<number>} Vec2 array containing the color in compressed form\n */\nexport function packColor(color) {\n  const array = asArray(color);\n  const r = array[0] * 256;\n  const g = array[1];\n  const b = array[2] * 256;\n  const a = Math.round(array[3] * 255);\n  return [r + g, b + a];\n}\nconst UNPACK_COLOR_FN = `vec4 unpackColor(vec2 packedColor) {\n  return fract(packedColor[1] / 256.0) * vec4(\n    fract(floor(packedColor[0] / 256.0) / 256.0),\n    fract(packedColor[0] / 256.0),\n    fract(floor(packedColor[1] / 256.0) / 256.0),\n    1.0\n  );\n}`;\n\n/**\n * @param {ValueTypes} type Value type\n * @return {1|2|3|4} The amount of components for this value\n */\nfunction getGlslSizeFromType(type) {\n  if (type === ValueTypes.COLOR) {\n    return 2;\n  }\n  if (type === ValueTypes.NUMBER_ARRAY) {\n    return 4;\n  }\n  return 1;\n}\n\n/**\n * @param {ValueTypes} type Value type\n * @return {'float'|'vec2'|'vec3'|'vec4'} The corresponding GLSL type for this value\n */\nfunction getGlslTypeFromType(type) {\n  const size = getGlslSizeFromType(type);\n  if (size > 1) {\n    return /** @type {'vec2'|'vec3'|'vec4'} */`vec${size}`;\n  }\n  return 'float';\n}\n\n/**\n * @param {import(\"../style/literal\").LiteralStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../style/expressions.js\").ParsingContext} vertContext Vertex shader parsing context\n * @param {import(\"../style/expressions.js\").ParsingContext} fragContext Fragment shader parsing context\n */\nfunction parseSymbolProperties(style, builder, uniforms, vertContext, fragContext) {\n  if (!('symbol' in style)) {\n    return;\n  }\n  const symbolStyle = style.symbol;\n  if ('color' in symbolStyle) {\n    const color = symbolStyle.color;\n    const opacity = symbolStyle.opacity !== undefined ? symbolStyle.opacity : 1;\n    const parsedColor = expressionToGlsl(fragContext, color, ValueTypes.COLOR);\n    const parsedOpacity = expressionToGlsl(fragContext, opacity, ValueTypes.NUMBER);\n    builder.setSymbolColorExpression(`vec4(${parsedColor}.rgb, ${parsedColor}.a * ${parsedOpacity})`);\n  }\n  if (symbolStyle.symbolType === 'image' && symbolStyle.src) {\n    const texture = new Image();\n    texture.crossOrigin = symbolStyle.crossOrigin === undefined ? 'anonymous' : symbolStyle.crossOrigin;\n    texture.src = symbolStyle.src;\n    builder.addUniform('sampler2D u_texture').setSymbolColorExpression(`${builder.getSymbolColorExpression()} * texture2D(u_texture, v_texCoord)`);\n    uniforms['u_texture'] = texture;\n  } else if ('symbolType' in symbolStyle) {\n    let visibleSize = builder.getSymbolSizeExpression();\n    if ('size' in symbolStyle) {\n      visibleSize = expressionToGlsl(fragContext, symbolStyle.size, ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER);\n    }\n    const symbolOpacity = getSymbolOpacityGlslFunction(symbolStyle.symbolType, `vec2(${visibleSize}).x`);\n    builder.setSymbolColorExpression(`${builder.getSymbolColorExpression()} * vec4(1.0, 1.0, 1.0, ${symbolOpacity})`);\n  }\n  if ('size' in symbolStyle) {\n    const size = symbolStyle.size;\n    const parsedSize = expressionToGlsl(vertContext, size, ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER);\n    builder.setSymbolSizeExpression(`vec2(${parsedSize})`);\n  }\n  if ('textureCoord' in symbolStyle) {\n    builder.setTextureCoordinateExpression(expressionToGlsl(vertContext, symbolStyle.textureCoord, ValueTypes.NUMBER_ARRAY));\n  }\n  if ('offset' in symbolStyle) {\n    builder.setSymbolOffsetExpression(expressionToGlsl(vertContext, symbolStyle.offset, ValueTypes.NUMBER_ARRAY));\n  }\n  if ('rotation' in symbolStyle) {\n    builder.setSymbolRotationExpression(expressionToGlsl(vertContext, symbolStyle.rotation, ValueTypes.NUMBER));\n  }\n  if ('rotateWithView' in symbolStyle) {\n    builder.setSymbolRotateWithView(!!symbolStyle.rotateWithView);\n  }\n}\n\n/**\n * @param {import(\"../style/literal\").LiteralStyle} style Style\n * @param {ShaderBuilder} builder Shader Builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../style/expressions.js\").ParsingContext} vertContext Vertex shader parsing context\n * @param {import(\"../style/expressions.js\").ParsingContext} fragContext Fragment shader parsing context\n */\nfunction parseStrokeProperties(style, builder, uniforms, vertContext, fragContext) {\n  if ('stroke-color' in style) {\n    builder.setStrokeColorExpression(expressionToGlsl(fragContext, style['stroke-color'], ValueTypes.COLOR));\n  }\n  if ('stroke-width' in style) {\n    builder.setStrokeWidthExpression(expressionToGlsl(vertContext, style['stroke-width'], ValueTypes.NUMBER));\n  }\n}\n\n/**\n * @param {import(\"../style/literal\").LiteralStyle} style Style\n * @param {ShaderBuilder} builder Shader Builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../style/expressions.js\").ParsingContext} vertContext Vertex shader parsing context\n * @param {import(\"../style/expressions.js\").ParsingContext} fragContext Fragment shader parsing context\n */\nfunction parseFillProperties(style, builder, uniforms, vertContext, fragContext) {\n  if ('fill-color' in style) {\n    builder.setFillColorExpression(expressionToGlsl(fragContext, style['fill-color'], ValueTypes.COLOR));\n  }\n}\n\n/**\n * @typedef {Object} StyleParseResult\n * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").UniformDefinitions} uniforms Uniform definitions\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").AttributeDefinitions} attributes Attribute definitions\n */\n\n/**\n * Parses a {@link import(\"../style/literal\").LiteralStyle} object and returns a {@link ShaderBuilder}\n * object that has been configured according to the given style, as well as `attributes` and `uniforms`\n * arrays to be fed to the `WebGLPointsRenderer` class.\n *\n * Also returns `uniforms` and `attributes` properties as expected by the\n * {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n *\n * @param {import(\"../style/literal\").LiteralStyle} style Literal style.\n * @return {StyleParseResult} Result containing shader params, attributes and uniforms.\n */\nexport function parseLiteralStyle(style) {\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n  const vertContext = {\n    inFragmentShader: false,\n    variables: [],\n    attributes: [],\n    stringLiteralsMap: {},\n    functions: {},\n    style: style\n  };\n\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n  const fragContext = {\n    inFragmentShader: true,\n    variables: vertContext.variables,\n    attributes: [],\n    stringLiteralsMap: vertContext.stringLiteralsMap,\n    functions: {},\n    style: style\n  };\n  const builder = new ShaderBuilder();\n\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n  const uniforms = {};\n  parseSymbolProperties(style, builder, uniforms, vertContext, fragContext);\n  parseStrokeProperties(style, builder, uniforms, vertContext, fragContext);\n  parseFillProperties(style, builder, uniforms, vertContext, fragContext);\n  if (style.filter) {\n    const parsedFilter = expressionToGlsl(fragContext, style.filter, ValueTypes.BOOLEAN);\n    builder.setFragmentDiscardExpression(`!${parsedFilter}`);\n  }\n\n  // define one uniform per variable\n  fragContext.variables.forEach(function (variable) {\n    const uniformName = uniformNameForVariable(variable.name);\n    builder.addUniform(`${getGlslTypeFromType(variable.type)} ${uniformName}`);\n    let callback;\n    if (variable.type === ValueTypes.STRING) {\n      callback = () => getStringNumberEquivalent(vertContext, /** @type {string} */style.variables[variable.name]);\n    } else if (variable.type === ValueTypes.COLOR) {\n      callback = () => packColor([...asArray(/** @type {string|Array<number>} */style.variables[variable.name] || '#eee')]);\n    } else if (variable.type === ValueTypes.BOOLEAN) {\n      callback = () => /** @type {boolean} */style.variables[variable.name] ? 1.0 : 0.0;\n    } else {\n      callback = () => (/** @type {number} */style.variables[variable.name]);\n    }\n    uniforms[uniformName] = callback;\n  });\n\n  // for each feature attribute used in the fragment shader, define a varying that will be used to pass data\n  // from the vertex to the fragment shader, as well as an attribute in the vertex shader (if not already present)\n  fragContext.attributes.forEach(function (attribute) {\n    if (!vertContext.attributes.find(a => a.name === attribute.name)) {\n      vertContext.attributes.push(attribute);\n    }\n    let type = getGlslTypeFromType(attribute.type);\n    let expression = `a_${attribute.name}`;\n    if (attribute.type === ValueTypes.COLOR) {\n      type = 'vec4';\n      expression = `unpackColor(${expression})`;\n      builder.addVertexShaderFunction(UNPACK_COLOR_FN);\n    }\n    builder.addVarying(`v_${attribute.name}`, type, expression);\n  });\n\n  // for each feature attribute used in the vertex shader, define an attribute in the vertex shader.\n  vertContext.attributes.forEach(function (attribute) {\n    builder.addAttribute(`${getGlslTypeFromType(attribute.type)} a_${attribute.name}`);\n  });\n  const attributes = vertContext.attributes.map(function (attribute) {\n    let callback;\n    if (attribute.callback) {\n      callback = attribute.callback;\n    } else if (attribute.type === ValueTypes.STRING) {\n      callback = feature => getStringNumberEquivalent(vertContext, feature.get(attribute.name));\n    } else if (attribute.type === ValueTypes.COLOR) {\n      callback = feature => packColor([...asArray(feature.get(attribute.name) || '#eee')]);\n    } else if (attribute.type === ValueTypes.BOOLEAN) {\n      callback = feature => feature.get(attribute.name) ? 1.0 : 0.0;\n    } else {\n      callback = feature => feature.get(attribute.name);\n    }\n    return {\n      name: attribute.name,\n      size: getGlslSizeFromType(attribute.type),\n      callback\n    };\n  });\n\n  // add functions that were collected in the parsing contexts\n  for (const functionName in vertContext.functions) {\n    builder.addVertexShaderFunction(vertContext.functions[functionName]);\n  }\n  for (const functionName in fragContext.functions) {\n    builder.addFragmentShaderFunction(fragContext.functions[functionName]);\n  }\n  return {\n    builder: builder,\n    attributes: attributes.reduce((prev, curr) => ({\n      ...prev,\n      [curr.name]: {\n        callback: curr.callback,\n        size: curr.size\n      }\n    }), {}),\n    uniforms: uniforms\n  };\n}","map":{"version":3,"names":["ShaderBuilder","ValueTypes","expressionToGlsl","getStringNumberEquivalent","uniformNameForVariable","asArray","getSymbolOpacityGlslFunction","type","sizeExpressionGlsl","st","a","Error","packColor","color","array","r","g","b","Math","round","UNPACK_COLOR_FN","getGlslSizeFromType","COLOR","NUMBER_ARRAY","getGlslTypeFromType","size","parseSymbolProperties","style","builder","uniforms","vertContext","fragContext","symbolStyle","symbol","opacity","undefined","parsedColor","parsedOpacity","NUMBER","setSymbolColorExpression","symbolType","src","texture","Image","crossOrigin","addUniform","getSymbolColorExpression","visibleSize","getSymbolSizeExpression","symbolOpacity","parsedSize","setSymbolSizeExpression","setTextureCoordinateExpression","textureCoord","setSymbolOffsetExpression","offset","setSymbolRotationExpression","rotation","setSymbolRotateWithView","rotateWithView","parseStrokeProperties","setStrokeColorExpression","setStrokeWidthExpression","parseFillProperties","setFillColorExpression","parseLiteralStyle","inFragmentShader","variables","attributes","stringLiteralsMap","functions","filter","parsedFilter","BOOLEAN","setFragmentDiscardExpression","forEach","variable","uniformName","name","callback","STRING","attribute","find","push","expression","addVertexShaderFunction","addVarying","addAttribute","map","feature","get","functionName","addFragmentShaderFunction","reduce","prev","curr"],"sources":["/Users/yantinglong/Documents/project/frogather/node_modules/ol/webgl/styleparser.js"],"sourcesContent":["/**\n * Utilities for parsing literal style objects\n * @module ol/webgl/styleparser\n */\nimport {ShaderBuilder} from './ShaderBuilder.js';\nimport {\n  ValueTypes,\n  expressionToGlsl,\n  getStringNumberEquivalent,\n  uniformNameForVariable,\n} from '../style/expressions.js';\nimport {asArray} from '../color.js';\n\n/**\n * @param {import('../style/literal.js').SymbolType} type Symbol type\n * @param {string} sizeExpressionGlsl Size expression\n * @return {string} The GLSL opacity function\n */\nexport function getSymbolOpacityGlslFunction(type, sizeExpressionGlsl) {\n  switch (type) {\n    case 'square':\n    case 'image':\n      return '1.0';\n    // taken from https://thebookofshaders.com/07/\n    case 'circle':\n      return `(1.0-smoothstep(1.-4./${sizeExpressionGlsl},1.,dot(v_quadCoord-.5,v_quadCoord-.5)*4.))`;\n    case 'triangle':\n      const st = '(v_quadCoord*2.-1.)';\n      const a = `(atan(${st}.x,${st}.y))`;\n      return `(1.0-smoothstep(.5-3./${sizeExpressionGlsl},.5,cos(floor(.5+${a}/2.094395102)*2.094395102-${a})*length(${st})))`;\n    default:\n      throw new Error(`Unexpected symbol type: ${type}`);\n  }\n}\n\n/**\n * Packs all components of a color into a two-floats array\n * @param {import(\"../color.js\").Color|string} color Color as array of numbers or string\n * @return {Array<number>} Vec2 array containing the color in compressed form\n */\nexport function packColor(color) {\n  const array = asArray(color);\n  const r = array[0] * 256;\n  const g = array[1];\n  const b = array[2] * 256;\n  const a = Math.round(array[3] * 255);\n  return [r + g, b + a];\n}\n\nconst UNPACK_COLOR_FN = `vec4 unpackColor(vec2 packedColor) {\n  return fract(packedColor[1] / 256.0) * vec4(\n    fract(floor(packedColor[0] / 256.0) / 256.0),\n    fract(packedColor[0] / 256.0),\n    fract(floor(packedColor[1] / 256.0) / 256.0),\n    1.0\n  );\n}`;\n\n/**\n * @param {ValueTypes} type Value type\n * @return {1|2|3|4} The amount of components for this value\n */\nfunction getGlslSizeFromType(type) {\n  if (type === ValueTypes.COLOR) {\n    return 2;\n  }\n  if (type === ValueTypes.NUMBER_ARRAY) {\n    return 4;\n  }\n  return 1;\n}\n\n/**\n * @param {ValueTypes} type Value type\n * @return {'float'|'vec2'|'vec3'|'vec4'} The corresponding GLSL type for this value\n */\nfunction getGlslTypeFromType(type) {\n  const size = getGlslSizeFromType(type);\n  if (size > 1) {\n    return /** @type {'vec2'|'vec3'|'vec4'} */ (`vec${size}`);\n  }\n  return 'float';\n}\n\n/**\n * @param {import(\"../style/literal\").LiteralStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../style/expressions.js\").ParsingContext} vertContext Vertex shader parsing context\n * @param {import(\"../style/expressions.js\").ParsingContext} fragContext Fragment shader parsing context\n */\nfunction parseSymbolProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext\n) {\n  if (!('symbol' in style)) {\n    return;\n  }\n\n  const symbolStyle = style.symbol;\n  if ('color' in symbolStyle) {\n    const color = symbolStyle.color;\n    const opacity = symbolStyle.opacity !== undefined ? symbolStyle.opacity : 1;\n    const parsedColor = expressionToGlsl(fragContext, color, ValueTypes.COLOR);\n    const parsedOpacity = expressionToGlsl(\n      fragContext,\n      opacity,\n      ValueTypes.NUMBER\n    );\n    builder.setSymbolColorExpression(\n      `vec4(${parsedColor}.rgb, ${parsedColor}.a * ${parsedOpacity})`\n    );\n  }\n  if (symbolStyle.symbolType === 'image' && symbolStyle.src) {\n    const texture = new Image();\n    texture.crossOrigin =\n      symbolStyle.crossOrigin === undefined\n        ? 'anonymous'\n        : symbolStyle.crossOrigin;\n    texture.src = symbolStyle.src;\n    builder\n      .addUniform('sampler2D u_texture')\n      .setSymbolColorExpression(\n        `${builder.getSymbolColorExpression()} * texture2D(u_texture, v_texCoord)`\n      );\n    uniforms['u_texture'] = texture;\n  } else if ('symbolType' in symbolStyle) {\n    let visibleSize = builder.getSymbolSizeExpression();\n    if ('size' in symbolStyle) {\n      visibleSize = expressionToGlsl(\n        fragContext,\n        symbolStyle.size,\n        ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER\n      );\n    }\n    const symbolOpacity = getSymbolOpacityGlslFunction(\n      symbolStyle.symbolType,\n      `vec2(${visibleSize}).x`\n    );\n    builder.setSymbolColorExpression(\n      `${builder.getSymbolColorExpression()} * vec4(1.0, 1.0, 1.0, ${symbolOpacity})`\n    );\n  }\n  if ('size' in symbolStyle) {\n    const size = symbolStyle.size;\n    const parsedSize = expressionToGlsl(\n      vertContext,\n      size,\n      ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER\n    );\n    builder.setSymbolSizeExpression(`vec2(${parsedSize})`);\n  }\n  if ('textureCoord' in symbolStyle) {\n    builder.setTextureCoordinateExpression(\n      expressionToGlsl(\n        vertContext,\n        symbolStyle.textureCoord,\n        ValueTypes.NUMBER_ARRAY\n      )\n    );\n  }\n  if ('offset' in symbolStyle) {\n    builder.setSymbolOffsetExpression(\n      expressionToGlsl(vertContext, symbolStyle.offset, ValueTypes.NUMBER_ARRAY)\n    );\n  }\n  if ('rotation' in symbolStyle) {\n    builder.setSymbolRotationExpression(\n      expressionToGlsl(vertContext, symbolStyle.rotation, ValueTypes.NUMBER)\n    );\n  }\n  if ('rotateWithView' in symbolStyle) {\n    builder.setSymbolRotateWithView(!!symbolStyle.rotateWithView);\n  }\n}\n\n/**\n * @param {import(\"../style/literal\").LiteralStyle} style Style\n * @param {ShaderBuilder} builder Shader Builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../style/expressions.js\").ParsingContext} vertContext Vertex shader parsing context\n * @param {import(\"../style/expressions.js\").ParsingContext} fragContext Fragment shader parsing context\n */\nfunction parseStrokeProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext\n) {\n  if ('stroke-color' in style) {\n    builder.setStrokeColorExpression(\n      expressionToGlsl(fragContext, style['stroke-color'], ValueTypes.COLOR)\n    );\n  }\n\n  if ('stroke-width' in style) {\n    builder.setStrokeWidthExpression(\n      expressionToGlsl(vertContext, style['stroke-width'], ValueTypes.NUMBER)\n    );\n  }\n}\n\n/**\n * @param {import(\"../style/literal\").LiteralStyle} style Style\n * @param {ShaderBuilder} builder Shader Builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../style/expressions.js\").ParsingContext} vertContext Vertex shader parsing context\n * @param {import(\"../style/expressions.js\").ParsingContext} fragContext Fragment shader parsing context\n */\nfunction parseFillProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext\n) {\n  if ('fill-color' in style) {\n    builder.setFillColorExpression(\n      expressionToGlsl(fragContext, style['fill-color'], ValueTypes.COLOR)\n    );\n  }\n}\n\n/**\n * @typedef {Object} StyleParseResult\n * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").UniformDefinitions} uniforms Uniform definitions\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").AttributeDefinitions} attributes Attribute definitions\n */\n\n/**\n * Parses a {@link import(\"../style/literal\").LiteralStyle} object and returns a {@link ShaderBuilder}\n * object that has been configured according to the given style, as well as `attributes` and `uniforms`\n * arrays to be fed to the `WebGLPointsRenderer` class.\n *\n * Also returns `uniforms` and `attributes` properties as expected by the\n * {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n *\n * @param {import(\"../style/literal\").LiteralStyle} style Literal style.\n * @return {StyleParseResult} Result containing shader params, attributes and uniforms.\n */\nexport function parseLiteralStyle(style) {\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n  const vertContext = {\n    inFragmentShader: false,\n    variables: [],\n    attributes: [],\n    stringLiteralsMap: {},\n    functions: {},\n    style: style,\n  };\n\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n  const fragContext = {\n    inFragmentShader: true,\n    variables: vertContext.variables,\n    attributes: [],\n    stringLiteralsMap: vertContext.stringLiteralsMap,\n    functions: {},\n    style: style,\n  };\n\n  const builder = new ShaderBuilder();\n\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n  const uniforms = {};\n\n  parseSymbolProperties(style, builder, uniforms, vertContext, fragContext);\n  parseStrokeProperties(style, builder, uniforms, vertContext, fragContext);\n  parseFillProperties(style, builder, uniforms, vertContext, fragContext);\n\n  if (style.filter) {\n    const parsedFilter = expressionToGlsl(\n      fragContext,\n      style.filter,\n      ValueTypes.BOOLEAN\n    );\n    builder.setFragmentDiscardExpression(`!${parsedFilter}`);\n  }\n\n  // define one uniform per variable\n  fragContext.variables.forEach(function (variable) {\n    const uniformName = uniformNameForVariable(variable.name);\n    builder.addUniform(`${getGlslTypeFromType(variable.type)} ${uniformName}`);\n\n    let callback;\n    if (variable.type === ValueTypes.STRING) {\n      callback = () =>\n        getStringNumberEquivalent(\n          vertContext,\n          /** @type {string} */ (style.variables[variable.name])\n        );\n    } else if (variable.type === ValueTypes.COLOR) {\n      callback = () =>\n        packColor([\n          ...asArray(\n            /** @type {string|Array<number>} */ (\n              style.variables[variable.name]\n            ) || '#eee'\n          ),\n        ]);\n    } else if (variable.type === ValueTypes.BOOLEAN) {\n      callback = () =>\n        /** @type {boolean} */ (style.variables[variable.name]) ? 1.0 : 0.0;\n    } else {\n      callback = () => /** @type {number} */ (style.variables[variable.name]);\n    }\n    uniforms[uniformName] = callback;\n  });\n\n  // for each feature attribute used in the fragment shader, define a varying that will be used to pass data\n  // from the vertex to the fragment shader, as well as an attribute in the vertex shader (if not already present)\n  fragContext.attributes.forEach(function (attribute) {\n    if (!vertContext.attributes.find((a) => a.name === attribute.name)) {\n      vertContext.attributes.push(attribute);\n    }\n    let type = getGlslTypeFromType(attribute.type);\n    let expression = `a_${attribute.name}`;\n    if (attribute.type === ValueTypes.COLOR) {\n      type = 'vec4';\n      expression = `unpackColor(${expression})`;\n      builder.addVertexShaderFunction(UNPACK_COLOR_FN);\n    }\n    builder.addVarying(`v_${attribute.name}`, type, expression);\n  });\n\n  // for each feature attribute used in the vertex shader, define an attribute in the vertex shader.\n  vertContext.attributes.forEach(function (attribute) {\n    builder.addAttribute(\n      `${getGlslTypeFromType(attribute.type)} a_${attribute.name}`\n    );\n  });\n\n  const attributes = vertContext.attributes.map(function (attribute) {\n    let callback;\n    if (attribute.callback) {\n      callback = attribute.callback;\n    } else if (attribute.type === ValueTypes.STRING) {\n      callback = (feature) =>\n        getStringNumberEquivalent(vertContext, feature.get(attribute.name));\n    } else if (attribute.type === ValueTypes.COLOR) {\n      callback = (feature) =>\n        packColor([...asArray(feature.get(attribute.name) || '#eee')]);\n    } else if (attribute.type === ValueTypes.BOOLEAN) {\n      callback = (feature) => (feature.get(attribute.name) ? 1.0 : 0.0);\n    } else {\n      callback = (feature) => feature.get(attribute.name);\n    }\n\n    return {\n      name: attribute.name,\n      size: getGlslSizeFromType(attribute.type),\n      callback,\n    };\n  });\n\n  // add functions that were collected in the parsing contexts\n  for (const functionName in vertContext.functions) {\n    builder.addVertexShaderFunction(vertContext.functions[functionName]);\n  }\n  for (const functionName in fragContext.functions) {\n    builder.addFragmentShaderFunction(fragContext.functions[functionName]);\n  }\n\n  return {\n    builder: builder,\n    attributes: attributes.reduce(\n      (prev, curr) => ({\n        ...prev,\n        [curr.name]: {callback: curr.callback, size: curr.size},\n      }),\n      {}\n    ),\n    uniforms: uniforms,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}
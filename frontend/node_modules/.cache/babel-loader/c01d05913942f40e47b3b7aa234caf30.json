{"ast":null,"code":"import LRUCache from 'lru-cache';\nimport { BaseSource } from './basesource.js';\nimport { AbortError, AggregateError, wait, zip } from '../utils.js';\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  get top() {\n    return this.offset + this.length;\n  }\n}\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n}\nexport class BlockedSource extends BaseSource {\n  /**\n   *\n   * @param {Source} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   */\n  constructor(source, {\n    blockSize = 65536,\n    cacheSize = 100\n  } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n    this.blockCache = new LRUCache({\n      max: cacheSize\n    });\n\n    // mapping blockId -> Block instance\n    this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    this.blockIdsToFetch = new Set();\n  }\n  get fileSize() {\n    return this.source.fileSize;\n  }\n\n  /**\n   *\n   * @param {basesource/Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    const cachedBlocks = new Map();\n    const blockRequests = new Map();\n    const missingBlockIds = new Set();\n    for (const {\n      offset,\n      length\n    } of slices) {\n      let top = offset + length;\n      const {\n        fileSize\n      } = this;\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n      // chunk the current slice into blocks\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        // check if the block is cached, being requested or still missing\n        const blockId = Math.floor(current / this.blockSize);\n        if (this.blockCache.has(blockId)) {\n          cachedBlocks.set(blockId, this.blockCache.get(blockId));\n        } else if (this.blockRequests.has(blockId)) {\n          blockRequests.set(blockId, this.blockRequests.get(blockId));\n        } else if (this.blockIdsToFetch.has(blockId)) {\n          missingBlockIds.add(blockId);\n        } else {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.add(blockId);\n        }\n      }\n    }\n\n    // allow additional block requests to accumulate\n    await wait();\n    this.fetchBlocks(signal);\n    for (const blockId of missingBlockIds) {\n      const block = this.blockRequests.get(blockId);\n      const cachedBlock = this.blockCache.get(blockId);\n      if (block) {\n        blockRequests.set(blockId, block);\n      } else if (cachedBlock) {\n        cachedBlocks.set(blockId, cachedBlock);\n      } else {\n        throw new Error(`Block ${blockId} is not in the block requests`);\n      }\n    }\n\n    // actually await all pending requests\n    let results = await Promise.allSettled(Array.from(blockRequests.values()));\n\n    // perform retries if a block was interrupted by a previous signal\n    if (results.some(result => result.status === 'rejected')) {\n      const retriedBlockRequests = new Set();\n      for (const [blockId, result] of zip(blockRequests.keys(), results)) {\n        const {\n          rejected,\n          reason\n        } = result;\n        if (rejected) {\n          // push some blocks back to the to-fetch list if they were\n          // aborted, but only when a different signal was used\n          if (reason.name === 'AbortError' && reason.signal !== signal) {\n            this.blockIdsToFetch.add(blockId);\n            retriedBlockRequests.add(blockId);\n          }\n        }\n      }\n\n      // start the retry of some blocks if required\n      if (this.blockIdsToFetch.length > 0) {\n        this.fetchBlocks(signal);\n        for (const blockId of retriedBlockRequests) {\n          const block = this.blockRequests.get(blockId);\n          if (!block) {\n            throw new Error(`Block ${blockId} is not in the block requests`);\n          }\n          blockRequests.set(blockId, block);\n        }\n        results = await Promise.allSettled(Array.from(blockRequests.values()));\n      }\n    }\n\n    // throw an error (either abort error or AggregateError if no abort was done)\n    if (results.some(result => result.status === 'rejected')) {\n      if (signal && signal.aborted) {\n        throw new AbortError('Request was aborted');\n      }\n      throw new AggregateError(results.filter(result => result.status === 'rejected').map(result => result.reason), 'Request failed');\n    }\n\n    // extract the actual block responses\n    const values = results.map(result => result.value);\n\n    // create a final Map, with all required blocks for this request to satisfy\n    const requiredBlocks = new Map(zip(Array.from(blockRequests.keys()), values));\n    for (const [blockId, block] of cachedBlocks) {\n      requiredBlocks.set(blockId, block);\n    }\n\n    // TODO: satisfy each slice\n    return this.readSliceData(slices, requiredBlocks);\n  }\n\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch);\n\n      // start requesting slices of data\n      const groupRequests = this.source.fetch(groups, signal);\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          const blockRequest = (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(blockOffset, data.byteLength, data);\n              this.blockCache.set(blockId, block);\n              return block;\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n              }\n              throw err;\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })();\n          this.blockRequests.set(blockId, blockRequest);\n        }\n      }\n      this.blockIdsToFetch.clear();\n    }\n  }\n\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(current[0] * this.blockSize, current.length * this.blockSize, current));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n    groups.push(new BlockGroup(current[0] * this.blockSize, current.length * this.blockSize, current));\n    return groups;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   * @param {Map} blocks\n   */\n  readSliceData(slices, blocks) {\n    return slices.map(slice => {\n      const top = slice.offset + slice.length;\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor((slice.offset + slice.length) / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n      return sliceData;\n    });\n  }\n}","map":{"version":3,"names":["LRUCache","BaseSource","AbortError","AggregateError","wait","zip","Block","constructor","offset","length","data","top","BlockGroup","blockIds","BlockedSource","source","blockSize","cacheSize","blockCache","max","blockRequests","Map","blockIdsToFetch","Set","fileSize","fetch","slices","signal","cachedBlocks","missingBlockIds","Math","min","firstBlockOffset","floor","current","blockId","has","set","get","add","fetchBlocks","block","cachedBlock","Error","results","Promise","allSettled","Array","from","values","some","result","status","retriedBlockRequests","keys","rejected","reason","name","aborted","filter","map","value","requiredBlocks","readSliceData","size","groups","groupBlocks","groupRequests","groupIndex","group","blockRequest","response","blockOffset","o","t","byteLength","slice","err","delete","clear","sortedBlockIds","sort","a","b","lastBlockId","push","blocks","blockIdLow","blockIdHigh","sliceData","ArrayBuffer","sliceView","Uint8Array","delta","topDelta","blockInnerOffset","rangeInnerOffset","usedBlockLength","blockView"],"sources":["/Users/yantinglong/Documents/project/frogather/node_modules/geotiff/dist-module/source/blockedsource.js"],"sourcesContent":["import LRUCache from 'lru-cache';\nimport { BaseSource } from './basesource.js';\nimport { AbortError, AggregateError, wait, zip } from '../utils.js';\n\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  get top() {\n    return this.offset + this.length;\n  }\n}\n\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n}\n\nexport class BlockedSource extends BaseSource {\n  /**\n   *\n   * @param {Source} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   */\n  constructor(source, { blockSize = 65536, cacheSize = 100 } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n\n    this.blockCache = new LRUCache({ max: cacheSize });\n\n    // mapping blockId -> Block instance\n    this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    this.blockIdsToFetch = new Set();\n  }\n\n  get fileSize() {\n    return this.source.fileSize;\n  }\n\n  /**\n   *\n   * @param {basesource/Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    const cachedBlocks = new Map();\n    const blockRequests = new Map();\n    const missingBlockIds = new Set();\n\n    for (const { offset, length } of slices) {\n      let top = offset + length;\n\n      const { fileSize } = this;\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n      // chunk the current slice into blocks\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        // check if the block is cached, being requested or still missing\n        const blockId = Math.floor(current / this.blockSize);\n\n        if (this.blockCache.has(blockId)) {\n          cachedBlocks.set(blockId, this.blockCache.get(blockId));\n        } else if (this.blockRequests.has(blockId)) {\n          blockRequests.set(blockId, this.blockRequests.get(blockId));\n        } else if (this.blockIdsToFetch.has(blockId)) {\n          missingBlockIds.add(blockId);\n        } else {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.add(blockId);\n        }\n      }\n    }\n\n    // allow additional block requests to accumulate\n    await wait();\n    this.fetchBlocks(signal);\n\n    for (const blockId of missingBlockIds) {\n      const block = this.blockRequests.get(blockId);\n      const cachedBlock = this.blockCache.get(blockId);\n\n      if (block) {\n        blockRequests.set(blockId, block);\n      } else if (cachedBlock) {\n        cachedBlocks.set(blockId, cachedBlock);\n      } else {\n        throw new Error(`Block ${blockId} is not in the block requests`);\n      }\n    }\n\n    // actually await all pending requests\n    let results = await Promise.allSettled(Array.from(blockRequests.values()));\n\n    // perform retries if a block was interrupted by a previous signal\n    if (results.some((result) => result.status === 'rejected')) {\n      const retriedBlockRequests = new Set();\n      for (const [blockId, result] of zip(blockRequests.keys(), results)) {\n        const { rejected, reason } = result;\n        if (rejected) {\n          // push some blocks back to the to-fetch list if they were\n          // aborted, but only when a different signal was used\n          if (reason.name === 'AbortError' && reason.signal !== signal) {\n            this.blockIdsToFetch.add(blockId);\n            retriedBlockRequests.add(blockId);\n          }\n        }\n      }\n\n      // start the retry of some blocks if required\n      if (this.blockIdsToFetch.length > 0) {\n        this.fetchBlocks(signal);\n        for (const blockId of retriedBlockRequests) {\n          const block = this.blockRequests.get(blockId);\n          if (!block) {\n            throw new Error(`Block ${blockId} is not in the block requests`);\n          }\n          blockRequests.set(blockId, block);\n        }\n        results = await Promise.allSettled(Array.from(blockRequests.values()));\n      }\n    }\n\n    // throw an error (either abort error or AggregateError if no abort was done)\n    if (results.some((result) => result.status === 'rejected')) {\n      if (signal && signal.aborted) {\n        throw new AbortError('Request was aborted');\n      }\n      throw new AggregateError(\n        results.filter((result) => result.status === 'rejected').map((result) => result.reason),\n        'Request failed',\n      );\n    }\n\n    // extract the actual block responses\n    const values = results.map((result) => result.value);\n\n    // create a final Map, with all required blocks for this request to satisfy\n    const requiredBlocks = new Map(zip(Array.from(blockRequests.keys()), values));\n    for (const [blockId, block] of cachedBlocks) {\n      requiredBlocks.set(blockId, block);\n    }\n\n    // TODO: satisfy each slice\n    return this.readSliceData(slices, requiredBlocks);\n  }\n\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch);\n\n      // start requesting slices of data\n      const groupRequests = this.source.fetch(groups, signal);\n\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          const blockRequest = (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(\n                blockOffset,\n                data.byteLength,\n                data,\n              );\n              this.blockCache.set(blockId, block);\n              return block;\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n              }\n              throw err;\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })();\n          this.blockRequests.set(blockId, blockRequest);\n        }\n      }\n      this.blockIdsToFetch.clear();\n    }\n  }\n\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(\n          current[0] * this.blockSize,\n          current.length * this.blockSize,\n          current,\n        ));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n\n    groups.push(new BlockGroup(\n      current[0] * this.blockSize,\n      current.length * this.blockSize,\n      current,\n    ));\n\n    return groups;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   * @param {Map} blocks\n   */\n  readSliceData(slices, blocks) {\n    return slices.map((slice) => {\n      const top = slice.offset + slice.length;\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor((slice.offset + slice.length) / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n\n      return sliceData;\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}
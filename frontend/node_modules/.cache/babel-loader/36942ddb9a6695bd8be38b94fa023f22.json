{"ast":null,"code":"/**\n * Operators and utilities used for style expressions\n * @module ol/style/expressions\n */\nimport PaletteTexture from '../webgl/PaletteTexture.js';\nimport { Uniforms } from '../renderer/webgl/TileLayer.js';\nimport { asArray, fromString, isStringColor } from '../color.js';\nimport { log2 } from '../math.js';\n/**\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\n * which in turns takes {@link import(\"./expressions.js\").ExpressionValue} arguments.\n *\n * The following operators can be used:\n *\n * * Reading operators:\n *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band\n *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values\n *     are in the 0..1 range. {@link import(\"../source/TileImage.js\").default} sources have 4 bands: red,\n *     green, blue and alpha. {@link import(\"../source/DataTile.js\").default} sources can have any number\n *     of bands, depending on the underlying data source and\n *     {@link import(\"../source/GeoTIFF.js\").Options configuration}. `xOffset` and `yOffset` are optional\n *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels.\n *   * `['get', 'attributeName']` fetches a feature attribute (it will be prefixed by `a_` in the shader)\n *     Note: those will be taken from the attributes provided to the renderer\n *   * `['resolution']` returns the current resolution\n *   * `['time']` returns the time in seconds since the creation of the layer\n *   * `['var', 'varName']` fetches a value from the style variables, or 0 if undefined\n *   * `['zoom']` returns the current zoom level\n *\n * * Math operators:\n *   * `['*', value1, value2]` multiplies `value1` by `value2`\n *   * `['/', value1, value2]` divides `value1` by `value2`\n *   * `['+', value1, value2]` adds `value1` and `value2`\n *   * `['-', value1, value2]` subtracts `value2` from `value1`\n *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`\n *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\n *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\n *   * `['abs', value1]` returns the absolute value of `value1`\n *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`\n *   * `['round', value1]` returns the nearest integer to `value1`\n *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`\n *   * `['sin', value1]` returns the sine of `value1`\n *   * `['cos', value1]` returns the cosine of `value1`\n *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`\n *\n * * Transform operators:\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\n *     All conditions should be `boolean`, output and fallback can be any kind.\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\n *     returns the `fallback` value.\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\n *     `fallback` values must be of the same type, and can be of any kind.\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\n *     of 1 is equivalent to `['linear']`.\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\n *     between `output1` and `outputN`.\n *\n * * Logical operators:\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\n *     (inclusively), or `false` otherwise.\n *\n * * Conversion operators:\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\n *     values can currently only be 2, 3 or 4.\n *   * `['color', red, green, blue, alpha]` creates a `color` value from `number` values; the `alpha` parameter is\n *     optional; if not specified, it will be set to 1.\n *     Note: `red`, `green` and `blue` components must be values between 0 and 255; `alpha` between 0 and 1.\n *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`\n *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors\n *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),\n *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b\n *     in the 0-255 range and a in the 0-1 range).\n *\n * Values can either be literals or another operator, as they will be evaluated recursively.\n * Literal values can be of the following types:\n * * `boolean`\n * * `number`\n * * `string`\n * * {@link module:ol/color~Color}\n *\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\n * @api\n */\n/**\n * Possible inferred types from a given value or expression.\n * Note: these are binary flags.\n * @enum {number}\n */\nexport var ValueTypes = {\n  NUMBER: 1,\n  STRING: 2,\n  COLOR: 4,\n  BOOLEAN: 8,\n  NUMBER_ARRAY: 16,\n  ANY: 31,\n  NONE: 0\n};\n/**\n * An operator declaration must contain two methods: `getReturnType` which returns a type based on\n * the operator arguments, and `toGlsl` which returns a GLSL-compatible string.\n * Note: both methods can process arguments recursively.\n * @typedef {Object} Operator\n * @property {function(Array<ExpressionValue>): ValueTypes|number} getReturnType Returns one or several types\n * @property {function(ParsingContext, Array<ExpressionValue>, ValueTypes=): string} toGlsl Returns a GLSL-compatible string\n * Note: takes in an optional type hint as 3rd parameter\n */\n/**\n * Operator declarations\n * @type {Object<string, Operator>}\n */\nexport var Operators = {};\n/**\n * Returns the possible types for a given value (each type being a binary flag)\n * To test a value use e.g. `getValueType(v) & ValueTypes.BOOLEAN`\n * @param {ExpressionValue} value Value\n * @return {ValueTypes|number} Type or types inferred from the value\n */\nexport function getValueType(value) {\n  if (typeof value === 'number') {\n    return ValueTypes.NUMBER;\n  }\n  if (typeof value === 'boolean') {\n    return ValueTypes.BOOLEAN;\n  }\n  if (typeof value === 'string') {\n    if (isStringColor(value)) {\n      return ValueTypes.COLOR | ValueTypes.STRING;\n    }\n    return ValueTypes.STRING;\n  }\n  if (!Array.isArray(value)) {\n    throw new Error(\"Unhandled value type: \".concat(JSON.stringify(value)));\n  }\n  var valueArr = /** @type {Array<*>} */value;\n  var onlyNumbers = valueArr.every(function (v) {\n    return typeof v === 'number';\n  });\n  if (onlyNumbers) {\n    if (valueArr.length === 3 || valueArr.length === 4) {\n      return ValueTypes.COLOR | ValueTypes.NUMBER_ARRAY;\n    }\n    return ValueTypes.NUMBER_ARRAY;\n  }\n  if (typeof valueArr[0] !== 'string') {\n    throw new Error(\"Expected an expression operator but received: \".concat(JSON.stringify(valueArr)));\n  }\n  var operator = Operators[valueArr[0]];\n  if (operator === undefined) {\n    throw new Error(\"Unrecognized expression operator: \".concat(JSON.stringify(valueArr)));\n  }\n  return operator.getReturnType(valueArr.slice(1));\n}\n/**\n * Checks if only one value type is enabled in the input number.\n * @param {ValueTypes|number} valueType Number containing value type binary flags\n * @return {boolean} True if only one type flag is enabled, false if zero or multiple\n */\nexport function isTypeUnique(valueType) {\n  return log2(valueType) % 1 === 0;\n}\n/**\n * Context available during the parsing of an expression.\n * @typedef {Object} ParsingContext\n * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader\n * @property {Array<string>} variables List of variables used in the expression; contains **unprefixed names**\n * @property {Array<string>} attributes List of attributes used in the expression; contains **unprefixed names**\n * @property {Object<string, number>} stringLiteralsMap This object maps all encountered string values to a number\n * @property {Object<string, string>} functions Lookup of functions used by the style.\n * @property {number} [bandCount] Number of bands per pixel.\n * @property {Array<PaletteTexture>} [paletteTextures] List of palettes used by the style.\n */\n/**\n * Will return the number as a float with a dot separator, which is required by GLSL.\n * @param {number} v Numerical value.\n * @return {string} The value as string.\n */\nexport function numberToGlsl(v) {\n  var s = v.toString();\n  return s.indexOf('.') === -1 ? s + '.0' : s;\n}\n/**\n * Will return the number array as a float with a dot separator, concatenated with ', '.\n * @param {Array<number>} array Numerical values array.\n * @return {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.\n */\nexport function arrayToGlsl(array) {\n  if (array.length < 2 || array.length > 4) {\n    throw new Error('`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.');\n  }\n  return \"vec\".concat(array.length, \"(\").concat(array.map(numberToGlsl).join(', '), \")\");\n}\n/**\n * Will normalize and converts to string a `vec4` color array compatible with GLSL.\n * @param {string|import(\"../color.js\").Color} color Color either in string format or [r, g, b, a] array format,\n * with RGB components in the 0..255 range and the alpha component in the 0..1 range.\n * Note that the final array will always have 4 components.\n * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\n */\nexport function colorToGlsl(color) {\n  var array = asArray(color).slice();\n  if (array.length < 4) {\n    array.push(1);\n  }\n  return arrayToGlsl(array.map(function (c, i) {\n    return i < 3 ? c / 255 : c;\n  }));\n}\n/**\n * Returns a stable equivalent number for the string literal.\n * @param {ParsingContext} context Parsing context\n * @param {string} string String literal value\n * @return {number} Number equivalent\n */\nexport function getStringNumberEquivalent(context, string) {\n  if (context.stringLiteralsMap[string] === undefined) {\n    context.stringLiteralsMap[string] = Object.keys(context.stringLiteralsMap).length;\n  }\n  return context.stringLiteralsMap[string];\n}\n/**\n * Returns a stable equivalent number for the string literal, for use in shaders. This number is then\n * converted to be a GLSL-compatible string.\n * @param {ParsingContext} context Parsing context\n * @param {string} string String literal value\n * @return {string} GLSL-compatible string containing a number\n */\nexport function stringToGlsl(context, string) {\n  return numberToGlsl(getStringNumberEquivalent(context, string));\n}\n/**\n * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a parsing context that\n * will be read and modified during the parsing operation.\n * @param {ParsingContext} context Parsing context\n * @param {ExpressionValue} value Value\n * @param {ValueTypes|number} [typeHint] Hint for the expected final type (can be several types combined)\n * @return {string} GLSL-compatible output\n */\nexport function expressionToGlsl(context, value, typeHint) {\n  // operator\n  if (Array.isArray(value) && typeof value[0] === 'string') {\n    var operator = Operators[value[0]];\n    if (operator === undefined) {\n      throw new Error(\"Unrecognized expression operator: \".concat(JSON.stringify(value)));\n    }\n    return operator.toGlsl(context, value.slice(1), typeHint);\n  }\n  var valueType = getValueType(value);\n  if ((valueType & ValueTypes.NUMBER) > 0) {\n    return numberToGlsl(/** @type {number} */value);\n  }\n  if ((valueType & ValueTypes.BOOLEAN) > 0) {\n    return value.toString();\n  }\n  if ((valueType & ValueTypes.STRING) > 0 && (typeHint === undefined || typeHint == ValueTypes.STRING)) {\n    return stringToGlsl(context, value.toString());\n  }\n  if ((valueType & ValueTypes.COLOR) > 0 && (typeHint === undefined || typeHint == ValueTypes.COLOR)) {\n    return colorToGlsl(/** @type {Array<number> | string} */value);\n  }\n  if ((valueType & ValueTypes.NUMBER_ARRAY) > 0) {\n    return arrayToGlsl(/** @type {Array<number>} */value);\n  }\n  throw new Error(\"Unexpected expression \".concat(value, \" (expected type \").concat(typeHint, \")\"));\n}\nfunction assertNumber(value) {\n  if (!(getValueType(value) & ValueTypes.NUMBER)) {\n    throw new Error(\"A numeric value was expected, got \".concat(JSON.stringify(value), \" instead\"));\n  }\n}\nfunction assertNumbers(values) {\n  for (var i = 0; i < values.length; i++) {\n    assertNumber(values[i]);\n  }\n}\nfunction assertString(value) {\n  if (!(getValueType(value) & ValueTypes.STRING)) {\n    throw new Error(\"A string value was expected, got \".concat(JSON.stringify(value), \" instead\"));\n  }\n}\nfunction assertBoolean(value) {\n  if (!(getValueType(value) & ValueTypes.BOOLEAN)) {\n    throw new Error(\"A boolean value was expected, got \".concat(JSON.stringify(value), \" instead\"));\n  }\n}\nfunction assertArgsCount(args, count) {\n  if (args.length !== count) {\n    throw new Error(\"Exactly \".concat(count, \" arguments were expected, got \").concat(args.length, \" instead\"));\n  }\n}\nfunction assertArgsMinCount(args, count) {\n  if (args.length < count) {\n    throw new Error(\"At least \".concat(count, \" arguments were expected, got \").concat(args.length, \" instead\"));\n  }\n}\nfunction assertArgsMaxCount(args, count) {\n  if (args.length > count) {\n    throw new Error(\"At most \".concat(count, \" arguments were expected, got \").concat(args.length, \" instead\"));\n  }\n}\nfunction assertArgsEven(args) {\n  if (args.length % 2 !== 0) {\n    throw new Error(\"An even amount of arguments was expected, got \".concat(args, \" instead\"));\n  }\n}\nfunction assertArgsOdd(args) {\n  if (args.length % 2 === 0) {\n    throw new Error(\"An odd amount of arguments was expected, got \".concat(args, \" instead\"));\n  }\n}\nfunction assertUniqueInferredType(args, types) {\n  if (!isTypeUnique(types)) {\n    throw new Error(\"Could not infer only one type from the following expression: \".concat(JSON.stringify(args)));\n  }\n}\nOperators['get'] = {\n  getReturnType: function (args) {\n    return ValueTypes.ANY;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertString(args[0]);\n    var value = args[0].toString();\n    if (context.attributes.indexOf(value) === -1) {\n      context.attributes.push(value);\n    }\n    var prefix = context.inFragmentShader ? 'v_' : 'a_';\n    return prefix + value;\n  }\n};\n/**\n * Get the uniform name given a variable name.\n * @param {string} variableName The variable name.\n * @return {string} The uniform name.\n */\nexport function uniformNameForVariable(variableName) {\n  return 'u_var_' + variableName;\n}\nOperators['var'] = {\n  getReturnType: function (args) {\n    return ValueTypes.ANY;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertString(args[0]);\n    var value = args[0].toString();\n    if (context.variables.indexOf(value) === -1) {\n      context.variables.push(value);\n    }\n    return uniformNameForVariable(value);\n  }\n};\nexport var PALETTE_TEXTURE_ARRAY = 'u_paletteTextures';\n// ['palette', index, colors]\nOperators['palette'] = {\n  getReturnType: function (args) {\n    return ValueTypes.COLOR;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumber(args[0]);\n    var index = expressionToGlsl(context, args[0]);\n    var colors = args[1];\n    if (!Array.isArray(colors)) {\n      throw new Error('The second argument of palette must be an array');\n    }\n    var numColors = colors.length;\n    var palette = new Uint8Array(numColors * 4);\n    for (var i = 0; i < numColors; i++) {\n      var candidate = colors[i];\n      /**\n       * @type {import('../color.js').Color}\n       */\n      var color = void 0;\n      if (typeof candidate === 'string') {\n        color = fromString(candidate);\n      } else {\n        if (!Array.isArray(candidate)) {\n          throw new Error('The second argument of palette must be an array of strings or colors');\n        }\n        var length_1 = candidate.length;\n        if (length_1 === 4) {\n          color = candidate;\n        } else {\n          if (length_1 !== 3) {\n            throw new Error(\"Expected palette color to have 3 or 4 values, got \".concat(length_1));\n          }\n          color = [candidate[0], candidate[1], candidate[2], 1];\n        }\n      }\n      var offset = i * 4;\n      palette[offset] = color[0];\n      palette[offset + 1] = color[1];\n      palette[offset + 2] = color[2];\n      palette[offset + 3] = color[3] * 255;\n    }\n    if (!context.paletteTextures) {\n      context.paletteTextures = [];\n    }\n    var paletteName = \"\".concat(PALETTE_TEXTURE_ARRAY, \"[\").concat(context.paletteTextures.length, \"]\");\n    var paletteTexture = new PaletteTexture(paletteName, palette);\n    context.paletteTextures.push(paletteTexture);\n    return \"texture2D(\".concat(paletteName, \", vec2((\").concat(index, \" + 0.5) / \").concat(numColors, \".0, 0.5))\");\n  }\n};\nvar GET_BAND_VALUE_FUNC = 'getBandValue';\nOperators['band'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 1);\n    assertArgsMaxCount(args, 3);\n    var band = args[0];\n    if (!(GET_BAND_VALUE_FUNC in context.functions)) {\n      var ifBlocks = '';\n      var bandCount = context.bandCount || 1;\n      for (var i = 0; i < bandCount; i++) {\n        var colorIndex = Math.floor(i / 4);\n        var bandIndex = i % 4;\n        if (bandIndex === bandCount - 1 && bandIndex === 1) {\n          // LUMINANCE_ALPHA - band 1 assigned to rgb and band 2 assigned to alpha\n          bandIndex = 3;\n        }\n        var textureName = \"\".concat(Uniforms.TILE_TEXTURE_ARRAY, \"[\").concat(colorIndex, \"]\");\n        ifBlocks += \"\\n          if (band == \".concat(i + 1, \".0) {\\n            return texture2D(\").concat(textureName, \", v_textureCoord + vec2(dx, dy))[\").concat(bandIndex, \"];\\n          }\\n        \");\n      }\n      context.functions[GET_BAND_VALUE_FUNC] = \"\\n        float getBandValue(float band, float xOffset, float yOffset) {\\n          float dx = xOffset / \".concat(Uniforms.TEXTURE_PIXEL_WIDTH, \";\\n          float dy = yOffset / \").concat(Uniforms.TEXTURE_PIXEL_HEIGHT, \";\\n          \").concat(ifBlocks, \"\\n        }\\n      \");\n    }\n    var bandExpression = expressionToGlsl(context, band);\n    var xOffsetExpression = expressionToGlsl(context, args[1] || 0);\n    var yOffsetExpression = expressionToGlsl(context, args[2] || 0);\n    return \"\".concat(GET_BAND_VALUE_FUNC, \"(\").concat(bandExpression, \", \").concat(xOffsetExpression, \", \").concat(yOffsetExpression, \")\");\n  }\n};\nOperators['time'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_time';\n  }\n};\nOperators['zoom'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_zoom';\n  }\n};\nOperators['resolution'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_resolution';\n  }\n};\nOperators['*'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\".concat(expressionToGlsl(context, args[0]), \" * \").concat(expressionToGlsl(context, args[1]), \")\");\n  }\n};\nOperators['/'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\".concat(expressionToGlsl(context, args[0]), \" / \").concat(expressionToGlsl(context, args[1]), \")\");\n  }\n};\nOperators['+'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\".concat(expressionToGlsl(context, args[0]), \" + \").concat(expressionToGlsl(context, args[1]), \")\");\n  }\n};\nOperators['-'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\".concat(expressionToGlsl(context, args[0]), \" - \").concat(expressionToGlsl(context, args[1]), \")\");\n  }\n};\nOperators['clamp'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 3);\n    assertNumbers(args);\n    var min = expressionToGlsl(context, args[1]);\n    var max = expressionToGlsl(context, args[2]);\n    return \"clamp(\".concat(expressionToGlsl(context, args[0]), \", \").concat(min, \", \").concat(max, \")\");\n  }\n};\nOperators['%'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"mod(\".concat(expressionToGlsl(context, args[0]), \", \").concat(expressionToGlsl(context, args[1]), \")\");\n  }\n};\nOperators['^'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"pow(\".concat(expressionToGlsl(context, args[0]), \", \").concat(expressionToGlsl(context, args[1]), \")\");\n  }\n};\nOperators['abs'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return \"abs(\".concat(expressionToGlsl(context, args[0]), \")\");\n  }\n};\nOperators['floor'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return \"floor(\".concat(expressionToGlsl(context, args[0]), \")\");\n  }\n};\nOperators['round'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return \"floor(\".concat(expressionToGlsl(context, args[0]), \" + 0.5)\");\n  }\n};\nOperators['ceil'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return \"ceil(\".concat(expressionToGlsl(context, args[0]), \")\");\n  }\n};\nOperators['sin'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return \"sin(\".concat(expressionToGlsl(context, args[0]), \")\");\n  }\n};\nOperators['cos'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return \"cos(\".concat(expressionToGlsl(context, args[0]), \")\");\n  }\n};\nOperators['atan'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 1);\n    assertArgsMaxCount(args, 2);\n    assertNumbers(args);\n    return args.length === 2 ? \"atan(\".concat(expressionToGlsl(context, args[0]), \", \").concat(expressionToGlsl(context, args[1]), \")\") : \"atan(\".concat(expressionToGlsl(context, args[0]), \")\");\n  }\n};\nOperators['>'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\".concat(expressionToGlsl(context, args[0]), \" > \").concat(expressionToGlsl(context, args[1]), \")\");\n  }\n};\nOperators['>='] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\".concat(expressionToGlsl(context, args[0]), \" >= \").concat(expressionToGlsl(context, args[1]), \")\");\n  }\n};\nOperators['<'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\".concat(expressionToGlsl(context, args[0]), \" < \").concat(expressionToGlsl(context, args[1]), \")\");\n  }\n};\nOperators['<='] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\".concat(expressionToGlsl(context, args[0]), \" <= \").concat(expressionToGlsl(context, args[1]), \")\");\n  }\n};\nfunction getEqualOperator(operator) {\n  return {\n    getReturnType: function (args) {\n      return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n      assertArgsCount(args, 2);\n      // find common type\n      var type = ValueTypes.ANY;\n      for (var i = 0; i < args.length; i++) {\n        type &= getValueType(args[i]);\n      }\n      if (type === ValueTypes.NONE) {\n        throw new Error(\"All arguments should be of compatible type, got \".concat(JSON.stringify(args), \" instead\"));\n      }\n      // Since it's not possible to have color types here, we can leave it out\n      // This fixes issues in case the value type is ambiguously detected as a color (e.g. the string 'red')\n      type &= ~ValueTypes.COLOR;\n      return \"(\".concat(expressionToGlsl(context, args[0], type), \" \").concat(operator, \" \").concat(expressionToGlsl(context, args[1], type), \")\");\n    }\n  };\n}\nOperators['=='] = getEqualOperator('==');\nOperators['!='] = getEqualOperator('!=');\nOperators['!'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertBoolean(args[0]);\n    return \"(!\".concat(expressionToGlsl(context, args[0]), \")\");\n  }\n};\nfunction getDecisionOperator(operator) {\n  return {\n    getReturnType: function (args) {\n      return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n      assertArgsMinCount(args, 2);\n      for (var i = 0; i < args.length; i++) {\n        assertBoolean(args[i]);\n      }\n      var result = '';\n      result = args.map(function (arg) {\n        return expressionToGlsl(context, arg);\n      }).join(\" \".concat(operator, \" \"));\n      result = \"(\".concat(result, \")\");\n      return result;\n    }\n  };\n}\nOperators['all'] = getDecisionOperator('&&');\nOperators['any'] = getDecisionOperator('||');\nOperators['between'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 3);\n    assertNumbers(args);\n    var min = expressionToGlsl(context, args[1]);\n    var max = expressionToGlsl(context, args[2]);\n    var value = expressionToGlsl(context, args[0]);\n    return \"(\".concat(value, \" >= \").concat(min, \" && \").concat(value, \" <= \").concat(max, \")\");\n  }\n};\nOperators['array'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER_ARRAY;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 2);\n    assertArgsMaxCount(args, 4);\n    assertNumbers(args);\n    var parsedArgs = args.map(function (val) {\n      return expressionToGlsl(context, val, ValueTypes.NUMBER);\n    });\n    return \"vec\".concat(args.length, \"(\").concat(parsedArgs.join(', '), \")\");\n  }\n};\nOperators['color'] = {\n  getReturnType: function (args) {\n    return ValueTypes.COLOR;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 3);\n    assertArgsMaxCount(args, 4);\n    assertNumbers(args);\n    var array = /** @type {Array<number>} */args;\n    if (args.length === 3) {\n      array.push(1);\n    }\n    var parsedArgs = args.map(function (val, i) {\n      return expressionToGlsl(context, val, ValueTypes.NUMBER) + (i < 3 ? ' / 255.0' : '');\n    });\n    return \"vec\".concat(args.length, \"(\").concat(parsedArgs.join(', '), \")\");\n  }\n};\nOperators['interpolate'] = {\n  getReturnType: function (args) {\n    var type = ValueTypes.COLOR | ValueTypes.NUMBER;\n    for (var i = 3; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    return type;\n  },\n  toGlsl: function (context, args, opt_typeHint) {\n    assertArgsEven(args);\n    assertArgsMinCount(args, 6);\n    // validate interpolation type\n    var type = args[0];\n    var interpolation;\n    switch (type[0]) {\n      case 'linear':\n        interpolation = 1;\n        break;\n      case 'exponential':\n        interpolation = type[1];\n        break;\n      default:\n        interpolation = null;\n    }\n    if (!interpolation) {\n      throw new Error(\"Invalid interpolation type for \\\"interpolate\\\" operator, received: \".concat(JSON.stringify(type)));\n    }\n    // compute input/output types\n    var typeHint = opt_typeHint !== undefined ? opt_typeHint : ValueTypes.ANY;\n    var outputType = Operators['interpolate'].getReturnType(args) & typeHint;\n    assertUniqueInferredType(args, outputType);\n    var input = expressionToGlsl(context, args[1]);\n    var exponent = numberToGlsl(interpolation);\n    var result = '';\n    for (var i = 2; i < args.length - 2; i += 2) {\n      var stop1 = expressionToGlsl(context, args[i]);\n      var output1 = result || expressionToGlsl(context, args[i + 1], outputType);\n      var stop2 = expressionToGlsl(context, args[i + 2]);\n      var output2 = expressionToGlsl(context, args[i + 3], outputType);\n      result = \"mix(\".concat(output1, \", \").concat(output2, \", pow(clamp((\").concat(input, \" - \").concat(stop1, \") / (\").concat(stop2, \" - \").concat(stop1, \"), 0.0, 1.0), \").concat(exponent, \"))\");\n    }\n    return result;\n  }\n};\nOperators['match'] = {\n  getReturnType: function (args) {\n    var type = ValueTypes.ANY;\n    for (var i = 2; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    type = type & getValueType(args[args.length - 1]);\n    return type;\n  },\n  toGlsl: function (context, args, opt_typeHint) {\n    assertArgsEven(args);\n    assertArgsMinCount(args, 4);\n    var typeHint = opt_typeHint !== undefined ? opt_typeHint : ValueTypes.ANY;\n    var outputType = Operators['match'].getReturnType(args) & typeHint;\n    assertUniqueInferredType(args, outputType);\n    var input = expressionToGlsl(context, args[0]);\n    var fallback = expressionToGlsl(context, args[args.length - 1], outputType);\n    var result = null;\n    for (var i = args.length - 3; i >= 1; i -= 2) {\n      var match = expressionToGlsl(context, args[i]);\n      var output = expressionToGlsl(context, args[i + 1], outputType);\n      result = \"(\".concat(input, \" == \").concat(match, \" ? \").concat(output, \" : \").concat(result || fallback, \")\");\n    }\n    return result;\n  }\n};\nOperators['case'] = {\n  getReturnType: function (args) {\n    var type = ValueTypes.ANY;\n    for (var i = 1; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    type = type & getValueType(args[args.length - 1]);\n    return type;\n  },\n  toGlsl: function (context, args, opt_typeHint) {\n    assertArgsOdd(args);\n    assertArgsMinCount(args, 3);\n    var typeHint = opt_typeHint !== undefined ? opt_typeHint : ValueTypes.ANY;\n    var outputType = Operators['case'].getReturnType(args) & typeHint;\n    assertUniqueInferredType(args, outputType);\n    for (var i = 0; i < args.length - 1; i += 2) {\n      assertBoolean(args[i]);\n    }\n    var fallback = expressionToGlsl(context, args[args.length - 1], outputType);\n    var result = null;\n    for (var i = args.length - 3; i >= 0; i -= 2) {\n      var condition = expressionToGlsl(context, args[i]);\n      var output = expressionToGlsl(context, args[i + 1], outputType);\n      result = \"(\".concat(condition, \" ? \").concat(output, \" : \").concat(result || fallback, \")\");\n    }\n    return result;\n  }\n};","map":{"version":3,"names":["PaletteTexture","Uniforms","asArray","fromString","isStringColor","log2","ValueTypes","NUMBER","STRING","COLOR","BOOLEAN","NUMBER_ARRAY","ANY","NONE","Operators","getValueType","value","Array","isArray","Error","concat","JSON","stringify","valueArr","onlyNumbers","every","v","length","operator","undefined","getReturnType","slice","isTypeUnique","valueType","numberToGlsl","s","toString","indexOf","arrayToGlsl","array","map","join","colorToGlsl","color","push","c","i","getStringNumberEquivalent","context","string","stringLiteralsMap","Object","keys","stringToGlsl","expressionToGlsl","typeHint","toGlsl","assertNumber","assertNumbers","values","assertString","assertBoolean","assertArgsCount","args","count","assertArgsMinCount","assertArgsMaxCount","assertArgsEven","assertArgsOdd","assertUniqueInferredType","types","attributes","prefix","inFragmentShader","uniformNameForVariable","variableName","variables","PALETTE_TEXTURE_ARRAY","index","colors","numColors","palette","Uint8Array","candidate","length_1","offset","paletteTextures","paletteName","paletteTexture","GET_BAND_VALUE_FUNC","band","functions","ifBlocks","bandCount","colorIndex","Math","floor","bandIndex","textureName","TILE_TEXTURE_ARRAY","TEXTURE_PIXEL_WIDTH","TEXTURE_PIXEL_HEIGHT","bandExpression","xOffsetExpression","yOffsetExpression","min","max","getEqualOperator","type","getDecisionOperator","result","arg","parsedArgs","val","opt_typeHint","interpolation","outputType","input","exponent","stop1","output1","stop2","output2","fallback","match","output","condition"],"sources":["../src/style/expressions.js"],"sourcesContent":[null],"mappings":"AAAA;;;;AAKA,OAAOA,cAAc,MAAM,4BAA4B;AACvD,SAAQC,QAAQ,QAAO,gCAAgC;AACvD,SAAQC,OAAO,EAAEC,UAAU,EAAEC,aAAa,QAAO,aAAa;AAC9D,SAAQC,IAAI,QAAO,YAAY;AAE/B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0FA;;;;;AAKA,OAAO,IAAMC,UAAU,GAAG;EACxBC,MAAM,EAAE,CAAO;EACfC,MAAM,EAAE,CAAO;EACfC,KAAK,EAAE,CAAO;EACdC,OAAO,EAAE,CAAO;EAChBC,YAAY,EAAE,EAAO;EACrBC,GAAG,EAAE,EAAO;EACZC,IAAI,EAAE;CACP;AAED;;;;;;;;;AAUA;;;;AAIA,OAAO,IAAMC,SAAS,GAAG,EAAE;AAE3B;;;;;;AAMA,OAAM,SAAUC,YAAYA,CAACC,KAAK;EAChC,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAC7B,OAAOV,UAAU,CAACC,MAAM;;EAE1B,IAAI,OAAOS,KAAK,KAAK,SAAS,EAAE;IAC9B,OAAOV,UAAU,CAACI,OAAO;;EAE3B,IAAI,OAAOM,KAAK,KAAK,QAAQ,EAAE;IAC7B,IAAIZ,aAAa,CAACY,KAAK,CAAC,EAAE;MACxB,OAAOV,UAAU,CAACG,KAAK,GAAGH,UAAU,CAACE,MAAM;;IAE7C,OAAOF,UAAU,CAACE,MAAM;;EAE1B,IAAI,CAACS,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE;IACzB,MAAM,IAAIG,KAAK,CAAC,yBAAAC,MAAA,CAAyBC,IAAI,CAACC,SAAS,CAACN,KAAK,CAAC,CAAE,CAAC;;EAEnE,IAAMO,QAAQ,GAAG,uBAAyBP,KAAM;EAChD,IAAMQ,WAAW,GAAGD,QAAQ,CAACE,KAAK,CAAC,UAAUC,CAAC;IAC5C,OAAO,OAAOA,CAAC,KAAK,QAAQ;EAC9B,CAAC,CAAC;EACF,IAAIF,WAAW,EAAE;IACf,IAAID,QAAQ,CAACI,MAAM,KAAK,CAAC,IAAIJ,QAAQ,CAACI,MAAM,KAAK,CAAC,EAAE;MAClD,OAAOrB,UAAU,CAACG,KAAK,GAAGH,UAAU,CAACK,YAAY;;IAEnD,OAAOL,UAAU,CAACK,YAAY;;EAEhC,IAAI,OAAOY,QAAQ,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;IACnC,MAAM,IAAIJ,KAAK,CACb,iDAAAC,MAAA,CAAiDC,IAAI,CAACC,SAAS,CAC7DC,QAAQ,CACT,CAAE,CACJ;;EAEH,IAAMK,QAAQ,GAAGd,SAAS,CAACS,QAAQ,CAAC,CAAC,CAAC,CAAC;EACvC,IAAIK,QAAQ,KAAKC,SAAS,EAAE;IAC1B,MAAM,IAAIV,KAAK,CACb,qCAAAC,MAAA,CAAqCC,IAAI,CAACC,SAAS,CAACC,QAAQ,CAAC,CAAE,CAChE;;EAEH,OAAOK,QAAQ,CAACE,aAAa,CAACP,QAAQ,CAACQ,KAAK,CAAC,CAAC,CAAC,CAAC;AAClD;AAEA;;;;;AAKA,OAAM,SAAUC,YAAYA,CAACC,SAAS;EACpC,OAAO5B,IAAI,CAAC4B,SAAS,CAAC,GAAG,CAAC,KAAK,CAAC;AAClC;AAEA;;;;;;;;;;;AAYA;;;;;AAKA,OAAM,SAAUC,YAAYA,CAACR,CAAC;EAC5B,IAAMS,CAAC,GAAGT,CAAC,CAACU,QAAQ,EAAE;EACtB,OAAOD,CAAC,CAACE,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,GAAGF,CAAC,GAAG,IAAI,GAAGA,CAAC;AAC7C;AAEA;;;;;AAKA,OAAM,SAAUG,WAAWA,CAACC,KAAK;EAC/B,IAAIA,KAAK,CAACZ,MAAM,GAAG,CAAC,IAAIY,KAAK,CAACZ,MAAM,GAAG,CAAC,EAAE;IACxC,MAAM,IAAIR,KAAK,CACb,gEAAgE,CACjE;;EAEH,OAAO,MAAAC,MAAA,CAAMmB,KAAK,CAACZ,MAAM,OAAAP,MAAA,CAAImB,KAAK,CAACC,GAAG,CAACN,YAAY,CAAC,CAACO,IAAI,CAAC,IAAI,CAAC,MAAG;AACpE;AAEA;;;;;;;AAOA,OAAM,SAAUC,WAAWA,CAACC,KAAK;EAC/B,IAAMJ,KAAK,GAAGrC,OAAO,CAACyC,KAAK,CAAC,CAACZ,KAAK,EAAE;EACpC,IAAIQ,KAAK,CAACZ,MAAM,GAAG,CAAC,EAAE;IACpBY,KAAK,CAACK,IAAI,CAAC,CAAC,CAAC;;EAEf,OAAON,WAAW,CAChBC,KAAK,CAACC,GAAG,CAAC,UAAUK,CAAC,EAAEC,CAAC;IACtB,OAAOA,CAAC,GAAG,CAAC,GAAGD,CAAC,GAAG,GAAG,GAAGA,CAAC;EAC5B,CAAC,CAAC,CACH;AACH;AAEA;;;;;;AAMA,OAAM,SAAUE,yBAAyBA,CAACC,OAAO,EAAEC,MAAM;EACvD,IAAID,OAAO,CAACE,iBAAiB,CAACD,MAAM,CAAC,KAAKpB,SAAS,EAAE;IACnDmB,OAAO,CAACE,iBAAiB,CAACD,MAAM,CAAC,GAAGE,MAAM,CAACC,IAAI,CAC7CJ,OAAO,CAACE,iBAAiB,CAC1B,CAACvB,MAAM;;EAEV,OAAOqB,OAAO,CAACE,iBAAiB,CAACD,MAAM,CAAC;AAC1C;AAEA;;;;;;;AAOA,OAAM,SAAUI,YAAYA,CAACL,OAAO,EAAEC,MAAM;EAC1C,OAAOf,YAAY,CAACa,yBAAyB,CAACC,OAAO,EAAEC,MAAM,CAAC,CAAC;AACjE;AAEA;;;;;;;;AAQA,OAAM,SAAUK,gBAAgBA,CAACN,OAAO,EAAEhC,KAAK,EAAEuC,QAAQ;EACvD;EACA,IAAItC,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,IAAI,OAAOA,KAAK,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;IACxD,IAAMY,QAAQ,GAAGd,SAAS,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC;IACpC,IAAIY,QAAQ,KAAKC,SAAS,EAAE;MAC1B,MAAM,IAAIV,KAAK,CACb,qCAAAC,MAAA,CAAqCC,IAAI,CAACC,SAAS,CAACN,KAAK,CAAC,CAAE,CAC7D;;IAEH,OAAOY,QAAQ,CAAC4B,MAAM,CAACR,OAAO,EAAEhC,KAAK,CAACe,KAAK,CAAC,CAAC,CAAC,EAAEwB,QAAQ,CAAC;;EAG3D,IAAMtB,SAAS,GAAGlB,YAAY,CAACC,KAAK,CAAC;EACrC,IAAI,CAACiB,SAAS,GAAG3B,UAAU,CAACC,MAAM,IAAI,CAAC,EAAE;IACvC,OAAO2B,YAAY,CAAC,qBAAuBlB,KAAM,CAAC;;EAGpD,IAAI,CAACiB,SAAS,GAAG3B,UAAU,CAACI,OAAO,IAAI,CAAC,EAAE;IACxC,OAAOM,KAAK,CAACoB,QAAQ,EAAE;;EAGzB,IACE,CAACH,SAAS,GAAG3B,UAAU,CAACE,MAAM,IAAI,CAAC,KAClC+C,QAAQ,KAAK1B,SAAS,IAAI0B,QAAQ,IAAIjD,UAAU,CAACE,MAAM,CAAC,EACzD;IACA,OAAO6C,YAAY,CAACL,OAAO,EAAEhC,KAAK,CAACoB,QAAQ,EAAE,CAAC;;EAGhD,IACE,CAACH,SAAS,GAAG3B,UAAU,CAACG,KAAK,IAAI,CAAC,KACjC8C,QAAQ,KAAK1B,SAAS,IAAI0B,QAAQ,IAAIjD,UAAU,CAACG,KAAK,CAAC,EACxD;IACA,OAAOiC,WAAW,CAAC,qCAAuC1B,KAAM,CAAC;;EAGnE,IAAI,CAACiB,SAAS,GAAG3B,UAAU,CAACK,YAAY,IAAI,CAAC,EAAE;IAC7C,OAAO2B,WAAW,CAAC,4BAA8BtB,KAAM,CAAC;;EAG1D,MAAM,IAAIG,KAAK,CAAC,yBAAAC,MAAA,CAAyBJ,KAAK,sBAAAI,MAAA,CAAmBmC,QAAQ,MAAG,CAAC;AAC/E;AAEA,SAASE,YAAYA,CAACzC,KAAK;EACzB,IAAI,EAAED,YAAY,CAACC,KAAK,CAAC,GAAGV,UAAU,CAACC,MAAM,CAAC,EAAE;IAC9C,MAAM,IAAIY,KAAK,CACb,qCAAAC,MAAA,CAAqCC,IAAI,CAACC,SAAS,CAACN,KAAK,CAAC,aAAU,CACrE;;AAEL;AACA,SAAS0C,aAAaA,CAACC,MAAM;EAC3B,KAAK,IAAIb,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGa,MAAM,CAAChC,MAAM,EAAEmB,CAAC,EAAE,EAAE;IACtCW,YAAY,CAACE,MAAM,CAACb,CAAC,CAAC,CAAC;;AAE3B;AACA,SAASc,YAAYA,CAAC5C,KAAK;EACzB,IAAI,EAAED,YAAY,CAACC,KAAK,CAAC,GAAGV,UAAU,CAACE,MAAM,CAAC,EAAE;IAC9C,MAAM,IAAIW,KAAK,CACb,oCAAAC,MAAA,CAAoCC,IAAI,CAACC,SAAS,CAACN,KAAK,CAAC,aAAU,CACpE;;AAEL;AACA,SAAS6C,aAAaA,CAAC7C,KAAK;EAC1B,IAAI,EAAED,YAAY,CAACC,KAAK,CAAC,GAAGV,UAAU,CAACI,OAAO,CAAC,EAAE;IAC/C,MAAM,IAAIS,KAAK,CACb,qCAAAC,MAAA,CAAqCC,IAAI,CAACC,SAAS,CAACN,KAAK,CAAC,aAAU,CACrE;;AAEL;AACA,SAAS8C,eAAeA,CAACC,IAAI,EAAEC,KAAK;EAClC,IAAID,IAAI,CAACpC,MAAM,KAAKqC,KAAK,EAAE;IACzB,MAAM,IAAI7C,KAAK,CACb,WAAAC,MAAA,CAAW4C,KAAK,oCAAA5C,MAAA,CAAiC2C,IAAI,CAACpC,MAAM,aAAU,CACvE;;AAEL;AACA,SAASsC,kBAAkBA,CAACF,IAAI,EAAEC,KAAK;EACrC,IAAID,IAAI,CAACpC,MAAM,GAAGqC,KAAK,EAAE;IACvB,MAAM,IAAI7C,KAAK,CACb,YAAAC,MAAA,CAAY4C,KAAK,oCAAA5C,MAAA,CAAiC2C,IAAI,CAACpC,MAAM,aAAU,CACxE;;AAEL;AACA,SAASuC,kBAAkBA,CAACH,IAAI,EAAEC,KAAK;EACrC,IAAID,IAAI,CAACpC,MAAM,GAAGqC,KAAK,EAAE;IACvB,MAAM,IAAI7C,KAAK,CACb,WAAAC,MAAA,CAAW4C,KAAK,oCAAA5C,MAAA,CAAiC2C,IAAI,CAACpC,MAAM,aAAU,CACvE;;AAEL;AACA,SAASwC,cAAcA,CAACJ,IAAI;EAC1B,IAAIA,IAAI,CAACpC,MAAM,GAAG,CAAC,KAAK,CAAC,EAAE;IACzB,MAAM,IAAIR,KAAK,CACb,iDAAAC,MAAA,CAAiD2C,IAAI,aAAU,CAChE;;AAEL;AACA,SAASK,aAAaA,CAACL,IAAI;EACzB,IAAIA,IAAI,CAACpC,MAAM,GAAG,CAAC,KAAK,CAAC,EAAE;IACzB,MAAM,IAAIR,KAAK,CACb,gDAAAC,MAAA,CAAgD2C,IAAI,aAAU,CAC/D;;AAEL;AACA,SAASM,wBAAwBA,CAACN,IAAI,EAAEO,KAAK;EAC3C,IAAI,CAACtC,YAAY,CAACsC,KAAK,CAAC,EAAE;IACxB,MAAM,IAAInD,KAAK,CACb,gEAAAC,MAAA,CAAgEC,IAAI,CAACC,SAAS,CAC5EyC,IAAI,CACL,CAAE,CACJ;;AAEL;AAEAjD,SAAS,CAAC,KAAK,CAAC,GAAG;EACjBgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,OAAOzD,UAAU,CAACM,GAAG;EACvB,CAAC;EACD4C,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;IAC7BD,eAAe,CAACC,IAAI,EAAE,CAAC,CAAC;IACxBH,YAAY,CAACG,IAAI,CAAC,CAAC,CAAC,CAAC;IACrB,IAAM/C,KAAK,GAAG+C,IAAI,CAAC,CAAC,CAAC,CAAC3B,QAAQ,EAAE;IAChC,IAAIY,OAAO,CAACuB,UAAU,CAAClC,OAAO,CAACrB,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;MAC5CgC,OAAO,CAACuB,UAAU,CAAC3B,IAAI,CAAC5B,KAAK,CAAC;;IAEhC,IAAMwD,MAAM,GAAGxB,OAAO,CAACyB,gBAAgB,GAAG,IAAI,GAAG,IAAI;IACrD,OAAOD,MAAM,GAAGxD,KAAK;EACvB;CACD;AAED;;;;;AAKA,OAAM,SAAU0D,sBAAsBA,CAACC,YAAY;EACjD,OAAO,QAAQ,GAAGA,YAAY;AAChC;AAEA7D,SAAS,CAAC,KAAK,CAAC,GAAG;EACjBgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,OAAOzD,UAAU,CAACM,GAAG;EACvB,CAAC;EACD4C,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;IAC7BD,eAAe,CAACC,IAAI,EAAE,CAAC,CAAC;IACxBH,YAAY,CAACG,IAAI,CAAC,CAAC,CAAC,CAAC;IACrB,IAAM/C,KAAK,GAAG+C,IAAI,CAAC,CAAC,CAAC,CAAC3B,QAAQ,EAAE;IAChC,IAAIY,OAAO,CAAC4B,SAAS,CAACvC,OAAO,CAACrB,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;MAC3CgC,OAAO,CAAC4B,SAAS,CAAChC,IAAI,CAAC5B,KAAK,CAAC;;IAE/B,OAAO0D,sBAAsB,CAAC1D,KAAK,CAAC;EACtC;CACD;AAED,OAAO,IAAM6D,qBAAqB,GAAG,mBAAmB;AAExD;AACA/D,SAAS,CAAC,SAAS,CAAC,GAAG;EACrBgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,OAAOzD,UAAU,CAACG,KAAK;EACzB,CAAC;EACD+C,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;IAC7BD,eAAe,CAACC,IAAI,EAAE,CAAC,CAAC;IACxBN,YAAY,CAACM,IAAI,CAAC,CAAC,CAAC,CAAC;IACrB,IAAMe,KAAK,GAAGxB,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,CAAC;IAChD,IAAMgB,MAAM,GAAGhB,IAAI,CAAC,CAAC,CAAC;IACtB,IAAI,CAAC9C,KAAK,CAACC,OAAO,CAAC6D,MAAM,CAAC,EAAE;MAC1B,MAAM,IAAI5D,KAAK,CAAC,iDAAiD,CAAC;;IAEpE,IAAM6D,SAAS,GAAGD,MAAM,CAACpD,MAAM;IAC/B,IAAMsD,OAAO,GAAG,IAAIC,UAAU,CAACF,SAAS,GAAG,CAAC,CAAC;IAC7C,KAAK,IAAIlC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkC,SAAS,EAAElC,CAAC,EAAE,EAAE;MAClC,IAAMqC,SAAS,GAAGJ,MAAM,CAACjC,CAAC,CAAC;MAC3B;;;MAGA,IAAIH,KAAK;MACT,IAAI,OAAOwC,SAAS,KAAK,QAAQ,EAAE;QACjCxC,KAAK,GAAGxC,UAAU,CAACgF,SAAS,CAAC;OAC9B,MAAM;QACL,IAAI,CAAClE,KAAK,CAACC,OAAO,CAACiE,SAAS,CAAC,EAAE;UAC7B,MAAM,IAAIhE,KAAK,CACb,sEAAsE,CACvE;;QAEH,IAAMiE,QAAM,GAAGD,SAAS,CAACxD,MAAM;QAC/B,IAAIyD,QAAM,KAAK,CAAC,EAAE;UAChBzC,KAAK,GAAGwC,SAAS;SAClB,MAAM;UACL,IAAIC,QAAM,KAAK,CAAC,EAAE;YAChB,MAAM,IAAIjE,KAAK,CACb,qDAAAC,MAAA,CAAqDgE,QAAM,CAAE,CAC9D;;UAEHzC,KAAK,GAAG,CAACwC,SAAS,CAAC,CAAC,CAAC,EAAEA,SAAS,CAAC,CAAC,CAAC,EAAEA,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;;;MAGzD,IAAME,MAAM,GAAGvC,CAAC,GAAG,CAAC;MACpBmC,OAAO,CAACI,MAAM,CAAC,GAAG1C,KAAK,CAAC,CAAC,CAAC;MAC1BsC,OAAO,CAACI,MAAM,GAAG,CAAC,CAAC,GAAG1C,KAAK,CAAC,CAAC,CAAC;MAC9BsC,OAAO,CAACI,MAAM,GAAG,CAAC,CAAC,GAAG1C,KAAK,CAAC,CAAC,CAAC;MAC9BsC,OAAO,CAACI,MAAM,GAAG,CAAC,CAAC,GAAG1C,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG;;IAEtC,IAAI,CAACK,OAAO,CAACsC,eAAe,EAAE;MAC5BtC,OAAO,CAACsC,eAAe,GAAG,EAAE;;IAE9B,IAAMC,WAAW,GAAG,GAAAnE,MAAA,CAAGyD,qBAAqB,OAAAzD,MAAA,CAAI4B,OAAO,CAACsC,eAAe,CAAC3D,MAAM,MAAG;IACjF,IAAM6D,cAAc,GAAG,IAAIxF,cAAc,CAACuF,WAAW,EAAEN,OAAO,CAAC;IAC/DjC,OAAO,CAACsC,eAAe,CAAC1C,IAAI,CAAC4C,cAAc,CAAC;IAC5C,OAAO,aAAApE,MAAA,CAAamE,WAAW,cAAAnE,MAAA,CAAW0D,KAAK,gBAAA1D,MAAA,CAAa4D,SAAS,cAAW;EAClF;CACD;AAED,IAAMS,mBAAmB,GAAG,cAAc;AAE1C3E,SAAS,CAAC,MAAM,CAAC,GAAG;EAClBgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,OAAOzD,UAAU,CAACC,MAAM;EAC1B,CAAC;EACDiD,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;IAC7BE,kBAAkB,CAACF,IAAI,EAAE,CAAC,CAAC;IAC3BG,kBAAkB,CAACH,IAAI,EAAE,CAAC,CAAC;IAC3B,IAAM2B,IAAI,GAAG3B,IAAI,CAAC,CAAC,CAAC;IAEpB,IAAI,EAAE0B,mBAAmB,IAAIzC,OAAO,CAAC2C,SAAS,CAAC,EAAE;MAC/C,IAAIC,QAAQ,GAAG,EAAE;MACjB,IAAMC,SAAS,GAAG7C,OAAO,CAAC6C,SAAS,IAAI,CAAC;MACxC,KAAK,IAAI/C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+C,SAAS,EAAE/C,CAAC,EAAE,EAAE;QAClC,IAAMgD,UAAU,GAAGC,IAAI,CAACC,KAAK,CAAClD,CAAC,GAAG,CAAC,CAAC;QACpC,IAAImD,SAAS,GAAGnD,CAAC,GAAG,CAAC;QACrB,IAAImD,SAAS,KAAKJ,SAAS,GAAG,CAAC,IAAII,SAAS,KAAK,CAAC,EAAE;UAClD;UACAA,SAAS,GAAG,CAAC;;QAEf,IAAMC,WAAW,GAAG,GAAA9E,MAAA,CAAGnB,QAAQ,CAACkG,kBAAkB,OAAA/E,MAAA,CAAI0E,UAAU,MAAG;QACnEF,QAAQ,IAAI,2BAAAxE,MAAA,CACI0B,CAAC,GAAG,CAAC,0CAAA1B,MAAA,CACE8E,WAAW,uCAAA9E,MAAA,CAAoC6E,SAAS,8BAE9E;;MAGHjD,OAAO,CAAC2C,SAAS,CAACF,mBAAmB,CAAC,GAAG,4GAAArE,MAAA,CAEdnB,QAAQ,CAACmG,mBAAmB,wCAAAhF,MAAA,CAC5BnB,QAAQ,CAACoG,oBAAoB,mBAAAjF,MAAA,CAClDwE,QAAQ,wBAEb;;IAGH,IAAMU,cAAc,GAAGhD,gBAAgB,CAACN,OAAO,EAAE0C,IAAI,CAAC;IACtD,IAAMa,iBAAiB,GAAGjD,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;IACjE,IAAMyC,iBAAiB,GAAGlD,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;IACjE,OAAO,GAAA3C,MAAA,CAAGqE,mBAAmB,OAAArE,MAAA,CAAIkF,cAAc,QAAAlF,MAAA,CAAKmF,iBAAiB,QAAAnF,MAAA,CAAKoF,iBAAiB,MAAG;EAChG;CACD;AAED1F,SAAS,CAAC,MAAM,CAAC,GAAG;EAClBgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,OAAOzD,UAAU,CAACC,MAAM;EAC1B,CAAC;EACDiD,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;IAC7BD,eAAe,CAACC,IAAI,EAAE,CAAC,CAAC;IACxB,OAAO,QAAQ;EACjB;CACD;AAEDjD,SAAS,CAAC,MAAM,CAAC,GAAG;EAClBgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,OAAOzD,UAAU,CAACC,MAAM;EAC1B,CAAC;EACDiD,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;IAC7BD,eAAe,CAACC,IAAI,EAAE,CAAC,CAAC;IACxB,OAAO,QAAQ;EACjB;CACD;AAEDjD,SAAS,CAAC,YAAY,CAAC,GAAG;EACxBgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,OAAOzD,UAAU,CAACC,MAAM;EAC1B,CAAC;EACDiD,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;IAC7BD,eAAe,CAACC,IAAI,EAAE,CAAC,CAAC;IACxB,OAAO,cAAc;EACvB;CACD;AAEDjD,SAAS,CAAC,GAAG,CAAC,GAAG;EACfgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,OAAOzD,UAAU,CAACC,MAAM;EAC1B,CAAC;EACDiD,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;IAC7BD,eAAe,CAACC,IAAI,EAAE,CAAC,CAAC;IACxBL,aAAa,CAACK,IAAI,CAAC;IACnB,OAAO,IAAA3C,MAAA,CAAIkC,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,CAAC,SAAA3C,MAAA,CAAMkC,gBAAgB,CACjEN,OAAO,EACPe,IAAI,CAAC,CAAC,CAAC,CACR,MAAG;EACN;CACD;AAEDjD,SAAS,CAAC,GAAG,CAAC,GAAG;EACfgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,OAAOzD,UAAU,CAACC,MAAM;EAC1B,CAAC;EACDiD,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;IAC7BD,eAAe,CAACC,IAAI,EAAE,CAAC,CAAC;IACxBL,aAAa,CAACK,IAAI,CAAC;IACnB,OAAO,IAAA3C,MAAA,CAAIkC,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,CAAC,SAAA3C,MAAA,CAAMkC,gBAAgB,CACjEN,OAAO,EACPe,IAAI,CAAC,CAAC,CAAC,CACR,MAAG;EACN;CACD;AAEDjD,SAAS,CAAC,GAAG,CAAC,GAAG;EACfgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,OAAOzD,UAAU,CAACC,MAAM;EAC1B,CAAC;EACDiD,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;IAC7BD,eAAe,CAACC,IAAI,EAAE,CAAC,CAAC;IACxBL,aAAa,CAACK,IAAI,CAAC;IACnB,OAAO,IAAA3C,MAAA,CAAIkC,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,CAAC,SAAA3C,MAAA,CAAMkC,gBAAgB,CACjEN,OAAO,EACPe,IAAI,CAAC,CAAC,CAAC,CACR,MAAG;EACN;CACD;AAEDjD,SAAS,CAAC,GAAG,CAAC,GAAG;EACfgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,OAAOzD,UAAU,CAACC,MAAM;EAC1B,CAAC;EACDiD,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;IAC7BD,eAAe,CAACC,IAAI,EAAE,CAAC,CAAC;IACxBL,aAAa,CAACK,IAAI,CAAC;IACnB,OAAO,IAAA3C,MAAA,CAAIkC,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,CAAC,SAAA3C,MAAA,CAAMkC,gBAAgB,CACjEN,OAAO,EACPe,IAAI,CAAC,CAAC,CAAC,CACR,MAAG;EACN;CACD;AAEDjD,SAAS,CAAC,OAAO,CAAC,GAAG;EACnBgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,OAAOzD,UAAU,CAACC,MAAM;EAC1B,CAAC;EACDiD,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;IAC7BD,eAAe,CAACC,IAAI,EAAE,CAAC,CAAC;IACxBL,aAAa,CAACK,IAAI,CAAC;IACnB,IAAM0C,GAAG,GAAGnD,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,CAAC;IAC9C,IAAM2C,GAAG,GAAGpD,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,CAAC;IAC9C,OAAO,SAAA3C,MAAA,CAASkC,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,CAAC,QAAA3C,MAAA,CAAKqF,GAAG,QAAArF,MAAA,CAAKsF,GAAG,MAAG;EACvE;CACD;AAED5F,SAAS,CAAC,GAAG,CAAC,GAAG;EACfgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,OAAOzD,UAAU,CAACC,MAAM;EAC1B,CAAC;EACDiD,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;IAC7BD,eAAe,CAACC,IAAI,EAAE,CAAC,CAAC;IACxBL,aAAa,CAACK,IAAI,CAAC;IACnB,OAAO,OAAA3C,MAAA,CAAOkC,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,CAAC,QAAA3C,MAAA,CAAKkC,gBAAgB,CACnEN,OAAO,EACPe,IAAI,CAAC,CAAC,CAAC,CACR,MAAG;EACN;CACD;AAEDjD,SAAS,CAAC,GAAG,CAAC,GAAG;EACfgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,OAAOzD,UAAU,CAACC,MAAM;EAC1B,CAAC;EACDiD,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;IAC7BD,eAAe,CAACC,IAAI,EAAE,CAAC,CAAC;IACxBL,aAAa,CAACK,IAAI,CAAC;IACnB,OAAO,OAAA3C,MAAA,CAAOkC,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,CAAC,QAAA3C,MAAA,CAAKkC,gBAAgB,CACnEN,OAAO,EACPe,IAAI,CAAC,CAAC,CAAC,CACR,MAAG;EACN;CACD;AAEDjD,SAAS,CAAC,KAAK,CAAC,GAAG;EACjBgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,OAAOzD,UAAU,CAACC,MAAM;EAC1B,CAAC;EACDiD,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;IAC7BD,eAAe,CAACC,IAAI,EAAE,CAAC,CAAC;IACxBL,aAAa,CAACK,IAAI,CAAC;IACnB,OAAO,OAAA3C,MAAA,CAAOkC,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,CAAC,MAAG;EACrD;CACD;AAEDjD,SAAS,CAAC,OAAO,CAAC,GAAG;EACnBgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,OAAOzD,UAAU,CAACC,MAAM;EAC1B,CAAC;EACDiD,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;IAC7BD,eAAe,CAACC,IAAI,EAAE,CAAC,CAAC;IACxBL,aAAa,CAACK,IAAI,CAAC;IACnB,OAAO,SAAA3C,MAAA,CAASkC,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,CAAC,MAAG;EACvD;CACD;AAEDjD,SAAS,CAAC,OAAO,CAAC,GAAG;EACnBgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,OAAOzD,UAAU,CAACC,MAAM;EAC1B,CAAC;EACDiD,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;IAC7BD,eAAe,CAACC,IAAI,EAAE,CAAC,CAAC;IACxBL,aAAa,CAACK,IAAI,CAAC;IACnB,OAAO,SAAA3C,MAAA,CAASkC,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,CAAC,YAAS;EAC7D;CACD;AAEDjD,SAAS,CAAC,MAAM,CAAC,GAAG;EAClBgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,OAAOzD,UAAU,CAACC,MAAM;EAC1B,CAAC;EACDiD,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;IAC7BD,eAAe,CAACC,IAAI,EAAE,CAAC,CAAC;IACxBL,aAAa,CAACK,IAAI,CAAC;IACnB,OAAO,QAAA3C,MAAA,CAAQkC,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,CAAC,MAAG;EACtD;CACD;AAEDjD,SAAS,CAAC,KAAK,CAAC,GAAG;EACjBgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,OAAOzD,UAAU,CAACC,MAAM;EAC1B,CAAC;EACDiD,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;IAC7BD,eAAe,CAACC,IAAI,EAAE,CAAC,CAAC;IACxBL,aAAa,CAACK,IAAI,CAAC;IACnB,OAAO,OAAA3C,MAAA,CAAOkC,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,CAAC,MAAG;EACrD;CACD;AAEDjD,SAAS,CAAC,KAAK,CAAC,GAAG;EACjBgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,OAAOzD,UAAU,CAACC,MAAM;EAC1B,CAAC;EACDiD,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;IAC7BD,eAAe,CAACC,IAAI,EAAE,CAAC,CAAC;IACxBL,aAAa,CAACK,IAAI,CAAC;IACnB,OAAO,OAAA3C,MAAA,CAAOkC,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,CAAC,MAAG;EACrD;CACD;AAEDjD,SAAS,CAAC,MAAM,CAAC,GAAG;EAClBgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,OAAOzD,UAAU,CAACC,MAAM;EAC1B,CAAC;EACDiD,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;IAC7BE,kBAAkB,CAACF,IAAI,EAAE,CAAC,CAAC;IAC3BG,kBAAkB,CAACH,IAAI,EAAE,CAAC,CAAC;IAC3BL,aAAa,CAACK,IAAI,CAAC;IACnB,OAAOA,IAAI,CAACpC,MAAM,KAAK,CAAC,GACpB,QAAAP,MAAA,CAAQkC,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,CAAC,QAAA3C,MAAA,CAAKkC,gBAAgB,CAC7DN,OAAO,EACPe,IAAI,CAAC,CAAC,CAAC,CACR,MAAG,GACJ,QAAA3C,MAAA,CAAQkC,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,CAAC,MAAG;EACnD;CACD;AAEDjD,SAAS,CAAC,GAAG,CAAC,GAAG;EACfgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,OAAOzD,UAAU,CAACI,OAAO;EAC3B,CAAC;EACD8C,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;IAC7BD,eAAe,CAACC,IAAI,EAAE,CAAC,CAAC;IACxBL,aAAa,CAACK,IAAI,CAAC;IACnB,OAAO,IAAA3C,MAAA,CAAIkC,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,CAAC,SAAA3C,MAAA,CAAMkC,gBAAgB,CACjEN,OAAO,EACPe,IAAI,CAAC,CAAC,CAAC,CACR,MAAG;EACN;CACD;AAEDjD,SAAS,CAAC,IAAI,CAAC,GAAG;EAChBgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,OAAOzD,UAAU,CAACI,OAAO;EAC3B,CAAC;EACD8C,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;IAC7BD,eAAe,CAACC,IAAI,EAAE,CAAC,CAAC;IACxBL,aAAa,CAACK,IAAI,CAAC;IACnB,OAAO,IAAA3C,MAAA,CAAIkC,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,CAAC,UAAA3C,MAAA,CAAOkC,gBAAgB,CAClEN,OAAO,EACPe,IAAI,CAAC,CAAC,CAAC,CACR,MAAG;EACN;CACD;AAEDjD,SAAS,CAAC,GAAG,CAAC,GAAG;EACfgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,OAAOzD,UAAU,CAACI,OAAO;EAC3B,CAAC;EACD8C,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;IAC7BD,eAAe,CAACC,IAAI,EAAE,CAAC,CAAC;IACxBL,aAAa,CAACK,IAAI,CAAC;IACnB,OAAO,IAAA3C,MAAA,CAAIkC,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,CAAC,SAAA3C,MAAA,CAAMkC,gBAAgB,CACjEN,OAAO,EACPe,IAAI,CAAC,CAAC,CAAC,CACR,MAAG;EACN;CACD;AAEDjD,SAAS,CAAC,IAAI,CAAC,GAAG;EAChBgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,OAAOzD,UAAU,CAACI,OAAO;EAC3B,CAAC;EACD8C,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;IAC7BD,eAAe,CAACC,IAAI,EAAE,CAAC,CAAC;IACxBL,aAAa,CAACK,IAAI,CAAC;IACnB,OAAO,IAAA3C,MAAA,CAAIkC,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,CAAC,UAAA3C,MAAA,CAAOkC,gBAAgB,CAClEN,OAAO,EACPe,IAAI,CAAC,CAAC,CAAC,CACR,MAAG;EACN;CACD;AAED,SAAS4C,gBAAgBA,CAAC/E,QAAQ;EAChC,OAAO;IACLE,aAAa,EAAE,SAAAA,CAAUiC,IAAI;MAC3B,OAAOzD,UAAU,CAACI,OAAO;IAC3B,CAAC;IACD8C,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;MAC7BD,eAAe,CAACC,IAAI,EAAE,CAAC,CAAC;MAExB;MACA,IAAI6C,IAAI,GAAGtG,UAAU,CAACM,GAAG;MACzB,KAAK,IAAIkC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiB,IAAI,CAACpC,MAAM,EAAEmB,CAAC,EAAE,EAAE;QACpC8D,IAAI,IAAI7F,YAAY,CAACgD,IAAI,CAACjB,CAAC,CAAC,CAAC;;MAE/B,IAAI8D,IAAI,KAAKtG,UAAU,CAACO,IAAI,EAAE;QAC5B,MAAM,IAAIM,KAAK,CACb,mDAAAC,MAAA,CAAmDC,IAAI,CAACC,SAAS,CAC/DyC,IAAI,CACL,aAAU,CACZ;;MAGH;MACA;MACA6C,IAAI,IAAI,CAACtG,UAAU,CAACG,KAAK;MAEzB,OAAO,IAAAW,MAAA,CAAIkC,gBAAgB,CACzBN,OAAO,EACPe,IAAI,CAAC,CAAC,CAAC,EACP6C,IAAI,CACL,OAAAxF,MAAA,CAAIQ,QAAQ,OAAAR,MAAA,CAAIkC,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,EAAE6C,IAAI,CAAC,MAAG;IAC9D;GACD;AACH;AAEA9F,SAAS,CAAC,IAAI,CAAC,GAAG6F,gBAAgB,CAAC,IAAI,CAAC;AAExC7F,SAAS,CAAC,IAAI,CAAC,GAAG6F,gBAAgB,CAAC,IAAI,CAAC;AAExC7F,SAAS,CAAC,GAAG,CAAC,GAAG;EACfgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,OAAOzD,UAAU,CAACI,OAAO;EAC3B,CAAC;EACD8C,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;IAC7BD,eAAe,CAACC,IAAI,EAAE,CAAC,CAAC;IACxBF,aAAa,CAACE,IAAI,CAAC,CAAC,CAAC,CAAC;IACtB,OAAO,KAAA3C,MAAA,CAAKkC,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,CAAC,MAAG;EACnD;CACD;AAED,SAAS8C,mBAAmBA,CAACjF,QAAQ;EACnC,OAAO;IACLE,aAAa,EAAE,SAAAA,CAAUiC,IAAI;MAC3B,OAAOzD,UAAU,CAACI,OAAO;IAC3B,CAAC;IACD8C,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;MAC7BE,kBAAkB,CAACF,IAAI,EAAE,CAAC,CAAC;MAC3B,KAAK,IAAIjB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiB,IAAI,CAACpC,MAAM,EAAEmB,CAAC,EAAE,EAAE;QACpCe,aAAa,CAACE,IAAI,CAACjB,CAAC,CAAC,CAAC;;MAExB,IAAIgE,MAAM,GAAG,EAAE;MACfA,MAAM,GAAG/C,IAAI,CACVvB,GAAG,CAAC,UAACuE,GAAG;QAAK,OAAAzD,gBAAgB,CAACN,OAAO,EAAE+D,GAAG,CAAC;MAA9B,CAA8B,CAAC,CAC5CtE,IAAI,CAAC,IAAArB,MAAA,CAAIQ,QAAQ,MAAG,CAAC;MACxBkF,MAAM,GAAG,IAAA1F,MAAA,CAAI0F,MAAM,MAAG;MACtB,OAAOA,MAAM;IACf;GACD;AACH;AAEAhG,SAAS,CAAC,KAAK,CAAC,GAAG+F,mBAAmB,CAAC,IAAI,CAAC;AAE5C/F,SAAS,CAAC,KAAK,CAAC,GAAG+F,mBAAmB,CAAC,IAAI,CAAC;AAE5C/F,SAAS,CAAC,SAAS,CAAC,GAAG;EACrBgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,OAAOzD,UAAU,CAACI,OAAO;EAC3B,CAAC;EACD8C,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;IAC7BD,eAAe,CAACC,IAAI,EAAE,CAAC,CAAC;IACxBL,aAAa,CAACK,IAAI,CAAC;IACnB,IAAM0C,GAAG,GAAGnD,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,CAAC;IAC9C,IAAM2C,GAAG,GAAGpD,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,CAAC;IAC9C,IAAM/C,KAAK,GAAGsC,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,CAAC;IAChD,OAAO,IAAA3C,MAAA,CAAIJ,KAAK,UAAAI,MAAA,CAAOqF,GAAG,UAAArF,MAAA,CAAOJ,KAAK,UAAAI,MAAA,CAAOsF,GAAG,MAAG;EACrD;CACD;AAED5F,SAAS,CAAC,OAAO,CAAC,GAAG;EACnBgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,OAAOzD,UAAU,CAACK,YAAY;EAChC,CAAC;EACD6C,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;IAC7BE,kBAAkB,CAACF,IAAI,EAAE,CAAC,CAAC;IAC3BG,kBAAkB,CAACH,IAAI,EAAE,CAAC,CAAC;IAC3BL,aAAa,CAACK,IAAI,CAAC;IACnB,IAAMiD,UAAU,GAAGjD,IAAI,CAACvB,GAAG,CAAC,UAAUyE,GAAG;MACvC,OAAO3D,gBAAgB,CAACN,OAAO,EAAEiE,GAAG,EAAE3G,UAAU,CAACC,MAAM,CAAC;IAC1D,CAAC,CAAC;IACF,OAAO,MAAAa,MAAA,CAAM2C,IAAI,CAACpC,MAAM,OAAAP,MAAA,CAAI4F,UAAU,CAACvE,IAAI,CAAC,IAAI,CAAC,MAAG;EACtD;CACD;AAED3B,SAAS,CAAC,OAAO,CAAC,GAAG;EACnBgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,OAAOzD,UAAU,CAACG,KAAK;EACzB,CAAC;EACD+C,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI;IAC7BE,kBAAkB,CAACF,IAAI,EAAE,CAAC,CAAC;IAC3BG,kBAAkB,CAACH,IAAI,EAAE,CAAC,CAAC;IAC3BL,aAAa,CAACK,IAAI,CAAC;IACnB,IAAMxB,KAAK,GAAG,4BAA8BwB,IAAK;IACjD,IAAIA,IAAI,CAACpC,MAAM,KAAK,CAAC,EAAE;MACrBY,KAAK,CAACK,IAAI,CAAC,CAAC,CAAC;;IAEf,IAAMoE,UAAU,GAAGjD,IAAI,CAACvB,GAAG,CAAC,UAAUyE,GAAG,EAAEnE,CAAC;MAC1C,OACEQ,gBAAgB,CAACN,OAAO,EAAEiE,GAAG,EAAE3G,UAAU,CAACC,MAAM,CAAC,IAChDuC,CAAC,GAAG,CAAC,GAAG,UAAU,GAAG,EAAE,CAAC;IAE7B,CAAC,CAAC;IACF,OAAO,MAAA1B,MAAA,CAAM2C,IAAI,CAACpC,MAAM,OAAAP,MAAA,CAAI4F,UAAU,CAACvE,IAAI,CAAC,IAAI,CAAC,MAAG;EACtD;CACD;AAED3B,SAAS,CAAC,aAAa,CAAC,GAAG;EACzBgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,IAAI6C,IAAI,GAAGtG,UAAU,CAACG,KAAK,GAAGH,UAAU,CAACC,MAAM;IAC/C,KAAK,IAAIuC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiB,IAAI,CAACpC,MAAM,EAAEmB,CAAC,IAAI,CAAC,EAAE;MACvC8D,IAAI,GAAGA,IAAI,GAAG7F,YAAY,CAACgD,IAAI,CAACjB,CAAC,CAAC,CAAC;;IAErC,OAAO8D,IAAI;EACb,CAAC;EACDpD,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI,EAAEmD,YAAY;IAC3C/C,cAAc,CAACJ,IAAI,CAAC;IACpBE,kBAAkB,CAACF,IAAI,EAAE,CAAC,CAAC;IAE3B;IACA,IAAM6C,IAAI,GAAG7C,IAAI,CAAC,CAAC,CAAC;IACpB,IAAIoD,aAAa;IACjB,QAAQP,IAAI,CAAC,CAAC,CAAC;MACb,KAAK,QAAQ;QACXO,aAAa,GAAG,CAAC;QACjB;MACF,KAAK,aAAa;QAChBA,aAAa,GAAGP,IAAI,CAAC,CAAC,CAAC;QACvB;MACF;QACEO,aAAa,GAAG,IAAI;;IAExB,IAAI,CAACA,aAAa,EAAE;MAClB,MAAM,IAAIhG,KAAK,CACb,sEAAAC,MAAA,CAAoEC,IAAI,CAACC,SAAS,CAChFsF,IAAI,CACL,CAAE,CACJ;;IAGH;IACA,IAAMrD,QAAQ,GAAG2D,YAAY,KAAKrF,SAAS,GAAGqF,YAAY,GAAG5G,UAAU,CAACM,GAAG;IAC3E,IAAMwG,UAAU,GAAGtG,SAAS,CAAC,aAAa,CAAC,CAACgB,aAAa,CAACiC,IAAI,CAAC,GAAGR,QAAQ;IAC1Ec,wBAAwB,CAACN,IAAI,EAAEqD,UAAU,CAAC;IAE1C,IAAMC,KAAK,GAAG/D,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,CAAC;IAChD,IAAMuD,QAAQ,GAAGpF,YAAY,CAACiF,aAAa,CAAC;IAE5C,IAAIL,MAAM,GAAG,EAAE;IACf,KAAK,IAAIhE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiB,IAAI,CAACpC,MAAM,GAAG,CAAC,EAAEmB,CAAC,IAAI,CAAC,EAAE;MAC3C,IAAMyE,KAAK,GAAGjE,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAACjB,CAAC,CAAC,CAAC;MAChD,IAAM0E,OAAO,GACXV,MAAM,IAAIxD,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAACjB,CAAC,GAAG,CAAC,CAAC,EAAEsE,UAAU,CAAC;MAC9D,IAAMK,KAAK,GAAGnE,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAACjB,CAAC,GAAG,CAAC,CAAC,CAAC;MACpD,IAAM4E,OAAO,GAAGpE,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAACjB,CAAC,GAAG,CAAC,CAAC,EAAEsE,UAAU,CAAC;MAClEN,MAAM,GAAG,OAAA1F,MAAA,CAAOoG,OAAO,QAAApG,MAAA,CAAKsG,OAAO,mBAAAtG,MAAA,CAAgBiG,KAAK,SAAAjG,MAAA,CAAMmG,KAAK,WAAAnG,MAAA,CAAQqG,KAAK,SAAArG,MAAA,CAAMmG,KAAK,oBAAAnG,MAAA,CAAiBkG,QAAQ,OAAI;;IAE1H,OAAOR,MAAM;EACf;CACD;AAEDhG,SAAS,CAAC,OAAO,CAAC,GAAG;EACnBgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,IAAI6C,IAAI,GAAGtG,UAAU,CAACM,GAAG;IACzB,KAAK,IAAIkC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiB,IAAI,CAACpC,MAAM,EAAEmB,CAAC,IAAI,CAAC,EAAE;MACvC8D,IAAI,GAAGA,IAAI,GAAG7F,YAAY,CAACgD,IAAI,CAACjB,CAAC,CAAC,CAAC;;IAErC8D,IAAI,GAAGA,IAAI,GAAG7F,YAAY,CAACgD,IAAI,CAACA,IAAI,CAACpC,MAAM,GAAG,CAAC,CAAC,CAAC;IACjD,OAAOiF,IAAI;EACb,CAAC;EACDpD,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI,EAAEmD,YAAY;IAC3C/C,cAAc,CAACJ,IAAI,CAAC;IACpBE,kBAAkB,CAACF,IAAI,EAAE,CAAC,CAAC;IAE3B,IAAMR,QAAQ,GAAG2D,YAAY,KAAKrF,SAAS,GAAGqF,YAAY,GAAG5G,UAAU,CAACM,GAAG;IAC3E,IAAMwG,UAAU,GAAGtG,SAAS,CAAC,OAAO,CAAC,CAACgB,aAAa,CAACiC,IAAI,CAAC,GAAGR,QAAQ;IACpEc,wBAAwB,CAACN,IAAI,EAAEqD,UAAU,CAAC;IAE1C,IAAMC,KAAK,GAAG/D,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAAC,CAAC,CAAC,CAAC;IAChD,IAAM4D,QAAQ,GAAGrE,gBAAgB,CAC/BN,OAAO,EACPe,IAAI,CAACA,IAAI,CAACpC,MAAM,GAAG,CAAC,CAAC,EACrByF,UAAU,CACX;IACD,IAAIN,MAAM,GAAG,IAAI;IACjB,KAAK,IAAIhE,CAAC,GAAGiB,IAAI,CAACpC,MAAM,GAAG,CAAC,EAAEmB,CAAC,IAAI,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAE;MAC5C,IAAM8E,KAAK,GAAGtE,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAACjB,CAAC,CAAC,CAAC;MAChD,IAAM+E,MAAM,GAAGvE,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAACjB,CAAC,GAAG,CAAC,CAAC,EAAEsE,UAAU,CAAC;MACjEN,MAAM,GAAG,IAAA1F,MAAA,CAAIiG,KAAK,UAAAjG,MAAA,CAAOwG,KAAK,SAAAxG,MAAA,CAAMyG,MAAM,SAAAzG,MAAA,CAAM0F,MAAM,IAAIa,QAAQ,MAAG;;IAEvE,OAAOb,MAAM;EACf;CACD;AAEDhG,SAAS,CAAC,MAAM,CAAC,GAAG;EAClBgB,aAAa,EAAE,SAAAA,CAAUiC,IAAI;IAC3B,IAAI6C,IAAI,GAAGtG,UAAU,CAACM,GAAG;IACzB,KAAK,IAAIkC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiB,IAAI,CAACpC,MAAM,EAAEmB,CAAC,IAAI,CAAC,EAAE;MACvC8D,IAAI,GAAGA,IAAI,GAAG7F,YAAY,CAACgD,IAAI,CAACjB,CAAC,CAAC,CAAC;;IAErC8D,IAAI,GAAGA,IAAI,GAAG7F,YAAY,CAACgD,IAAI,CAACA,IAAI,CAACpC,MAAM,GAAG,CAAC,CAAC,CAAC;IACjD,OAAOiF,IAAI;EACb,CAAC;EACDpD,MAAM,EAAE,SAAAA,CAAUR,OAAO,EAAEe,IAAI,EAAEmD,YAAY;IAC3C9C,aAAa,CAACL,IAAI,CAAC;IACnBE,kBAAkB,CAACF,IAAI,EAAE,CAAC,CAAC;IAE3B,IAAMR,QAAQ,GAAG2D,YAAY,KAAKrF,SAAS,GAAGqF,YAAY,GAAG5G,UAAU,CAACM,GAAG;IAC3E,IAAMwG,UAAU,GAAGtG,SAAS,CAAC,MAAM,CAAC,CAACgB,aAAa,CAACiC,IAAI,CAAC,GAAGR,QAAQ;IACnEc,wBAAwB,CAACN,IAAI,EAAEqD,UAAU,CAAC;IAC1C,KAAK,IAAItE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiB,IAAI,CAACpC,MAAM,GAAG,CAAC,EAAEmB,CAAC,IAAI,CAAC,EAAE;MAC3Ce,aAAa,CAACE,IAAI,CAACjB,CAAC,CAAC,CAAC;;IAGxB,IAAM6E,QAAQ,GAAGrE,gBAAgB,CAC/BN,OAAO,EACPe,IAAI,CAACA,IAAI,CAACpC,MAAM,GAAG,CAAC,CAAC,EACrByF,UAAU,CACX;IACD,IAAIN,MAAM,GAAG,IAAI;IACjB,KAAK,IAAIhE,CAAC,GAAGiB,IAAI,CAACpC,MAAM,GAAG,CAAC,EAAEmB,CAAC,IAAI,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAE;MAC5C,IAAMgF,SAAS,GAAGxE,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAACjB,CAAC,CAAC,CAAC;MACpD,IAAM+E,MAAM,GAAGvE,gBAAgB,CAACN,OAAO,EAAEe,IAAI,CAACjB,CAAC,GAAG,CAAC,CAAC,EAAEsE,UAAU,CAAC;MACjEN,MAAM,GAAG,IAAA1F,MAAA,CAAI0G,SAAS,SAAA1G,MAAA,CAAMyG,MAAM,SAAAzG,MAAA,CAAM0F,MAAM,IAAIa,QAAQ,MAAG;;IAE/D,OAAOb,MAAM;EACf;CACD","ignoreList":[]},"metadata":{},"sourceType":"module"}
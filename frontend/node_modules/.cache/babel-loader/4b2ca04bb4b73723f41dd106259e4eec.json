{"ast":null,"code":"/**\n * Classes and utilities for generating shaders from literal style objects\n * @module ol/webgl/ShaderBuilder\n */\nimport { ValueTypes, expressionToGlsl, getStringNumberEquivalent, uniformNameForVariable } from '../style/expressions.js';\n/**\n * @typedef {Object} VaryingDescription\n * @property {string} name Varying name, as will be declared in the header.\n * @property {string} type Varying type, either `float`, `vec2`, `vec4`...\n * @property {string} expression Expression which will be assigned to the varying in the vertex shader, and\n * passed on to the fragment shader.\n */\n/**\n * @classdesc\n * This class implements a classic builder pattern for generating many different types of shaders.\n * Methods can be chained, e. g.:\n *\n * ```js\n * const shader = new ShaderBuilder()\n *   .addVarying('v_width', 'float', 'a_width')\n *   .addUniform('u_time')\n *   .setColorExpression('...')\n *   .setSizeExpression('...')\n *   .outputSymbolFragmentShader();\n * ```\n */\nvar ShaderBuilder = /** @class */function () {\n  function ShaderBuilder() {\n    /**\n     * Uniforms; these will be declared in the header (should include the type).\n     * @type {Array<string>}\n     * @private\n     */\n    this.uniforms = [];\n    /**\n     * Attributes; these will be declared in the header (should include the type).\n     * @type {Array<string>}\n     * @private\n     */\n    this.attributes = [];\n    /**\n     * Varyings with a name, a type and an expression.\n     * @type {Array<VaryingDescription>}\n     * @private\n     */\n    this.varyings = [];\n    /**\n     * @type {string}\n     * @private\n     */\n    this.sizeExpression = 'vec2(1.0)';\n    /**\n     * @type {string}\n     * @private\n     */\n    this.rotationExpression = '0.0';\n    /**\n     * @type {string}\n     * @private\n     */\n    this.offsetExpression = 'vec2(0.0)';\n    /**\n     * @type {string}\n     * @private\n     */\n    this.colorExpression = 'vec4(1.0)';\n    /**\n     * @type {string}\n     * @private\n     */\n    this.texCoordExpression = 'vec4(0.0, 0.0, 1.0, 1.0)';\n    /**\n     * @type {string}\n     * @private\n     */\n    this.discardExpression = 'false';\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.rotateWithView = false;\n  }\n  /**\n   * Adds a uniform accessible in both fragment and vertex shaders.\n   * The given name should include a type, such as `sampler2D u_texture`.\n   * @param {string} name Uniform name\n   * @return {ShaderBuilder} the builder object\n   */\n  ShaderBuilder.prototype.addUniform = function (name) {\n    this.uniforms.push(name);\n    return this;\n  };\n  /**\n   * Adds an attribute accessible in the vertex shader, read from the geometry buffer.\n   * The given name should include a type, such as `vec2 a_position`.\n   * @param {string} name Attribute name\n   * @return {ShaderBuilder} the builder object\n   */\n  ShaderBuilder.prototype.addAttribute = function (name) {\n    this.attributes.push(name);\n    return this;\n  };\n  /**\n   * Adds a varying defined in the vertex shader and accessible from the fragment shader.\n   * The type and expression of the varying have to be specified separately.\n   * @param {string} name Varying name\n   * @param {'float'|'vec2'|'vec3'|'vec4'} type Type\n   * @param {string} expression Expression used to assign a value to the varying.\n   * @return {ShaderBuilder} the builder object\n   */\n  ShaderBuilder.prototype.addVarying = function (name, type, expression) {\n    this.varyings.push({\n      name: name,\n      type: type,\n      expression: expression\n    });\n    return this;\n  };\n  /**\n   * Sets an expression to compute the size of the shape.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec2` value.\n   * @param {string} expression Size expression\n   * @return {ShaderBuilder} the builder object\n   */\n  ShaderBuilder.prototype.setSizeExpression = function (expression) {\n    this.sizeExpression = expression;\n    return this;\n  };\n  /**\n   * Sets an expression to compute the rotation of the shape.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `float` value in radians.\n   * @param {string} expression Size expression\n   * @return {ShaderBuilder} the builder object\n   */\n  ShaderBuilder.prototype.setRotationExpression = function (expression) {\n    this.rotationExpression = expression;\n    return this;\n  };\n  /**\n   * Sets an expression to compute the offset of the symbol from the point center.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec2` value.\n   * Note: will only be used for point geometry shaders.\n   * @param {string} expression Offset expression\n   * @return {ShaderBuilder} the builder object\n   */\n  ShaderBuilder.prototype.setSymbolOffsetExpression = function (expression) {\n    this.offsetExpression = expression;\n    return this;\n  };\n  /**\n   * Sets an expression to compute the color of the shape.\n   * This expression can use all the uniforms, varyings and attributes available\n   * in the fragment shader, and should evaluate to a `vec4` value.\n   * @param {string} expression Color expression\n   * @return {ShaderBuilder} the builder object\n   */\n  ShaderBuilder.prototype.setColorExpression = function (expression) {\n    this.colorExpression = expression;\n    return this;\n  };\n  /**\n   * Sets an expression to compute the texture coordinates of the vertices.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec4` value.\n   * @param {string} expression Texture coordinate expression\n   * @return {ShaderBuilder} the builder object\n   */\n  ShaderBuilder.prototype.setTextureCoordinateExpression = function (expression) {\n    this.texCoordExpression = expression;\n    return this;\n  };\n  /**\n   * Sets an expression to determine whether a fragment (pixel) should be discarded,\n   * i.e. not drawn at all.\n   * This expression can use all the uniforms, varyings and attributes available\n   * in the fragment shader, and should evaluate to a `bool` value (it will be\n   * used in an `if` statement)\n   * @param {string} expression Fragment discard expression\n   * @return {ShaderBuilder} the builder object\n   */\n  ShaderBuilder.prototype.setFragmentDiscardExpression = function (expression) {\n    this.discardExpression = expression;\n    return this;\n  };\n  /**\n   * Sets whether the symbols should rotate with the view or stay aligned with the map.\n   * Note: will only be used for point geometry shaders.\n   * @param {boolean} rotateWithView Rotate with view\n   * @return {ShaderBuilder} the builder object\n   */\n  ShaderBuilder.prototype.setSymbolRotateWithView = function (rotateWithView) {\n    this.rotateWithView = rotateWithView;\n    return this;\n  };\n  /**\n   * @return {string} Previously set size expression\n   */\n  ShaderBuilder.prototype.getSizeExpression = function () {\n    return this.sizeExpression;\n  };\n  /**\n   * @return {string} Previously set symbol offset expression\n   */\n  ShaderBuilder.prototype.getOffsetExpression = function () {\n    return this.offsetExpression;\n  };\n  /**\n   * @return {string} Previously set color expression\n   */\n  ShaderBuilder.prototype.getColorExpression = function () {\n    return this.colorExpression;\n  };\n  /**\n   * @return {string} Previously set texture coordinate expression\n   */\n  ShaderBuilder.prototype.getTextureCoordinateExpression = function () {\n    return this.texCoordExpression;\n  };\n  /**\n   * @return {string} Previously set fragment discard expression\n   */\n  ShaderBuilder.prototype.getFragmentDiscardExpression = function () {\n    return this.discardExpression;\n  };\n  /**\n   * Generates a symbol vertex shader from the builder parameters,\n   * intended to be used on point geometries.\n   *\n   * Three uniforms are hardcoded in all shaders: `u_projectionMatrix`, `u_offsetScaleMatrix`,\n   * `u_offsetRotateMatrix`, `u_time`.\n   *\n   * The following attributes are hardcoded and expected to be present in the vertex buffers:\n   * `vec2 a_position`, `float a_index` (being the index of the vertex in the quad, 0 to 3).\n   *\n   * The following varyings are hardcoded and gives the coordinate of the pixel both in the quad and on the texture:\n   * `vec2 v_quadCoord`, `vec2 v_texCoord`\n   *\n   * @param {boolean} [forHitDetection] If true, the shader will be modified to include hit detection variables\n   * (namely, hit color with encoded feature id).\n   * @return {string} The full shader as a string.\n   */\n  ShaderBuilder.prototype.getSymbolVertexShader = function (forHitDetection) {\n    var offsetMatrix = this.rotateWithView ? 'u_offsetScaleMatrix * u_offsetRotateMatrix' : 'u_offsetScaleMatrix';\n    var attributes = this.attributes;\n    var varyings = this.varyings;\n    if (forHitDetection) {\n      attributes = attributes.concat('vec4 a_hitColor');\n      varyings = varyings.concat({\n        name: 'v_hitColor',\n        type: 'vec4',\n        expression: 'a_hitColor'\n      });\n    }\n    return \"precision mediump float;\\nuniform mat4 u_projectionMatrix;\\nuniform mat4 u_offsetScaleMatrix;\\nuniform mat4 u_offsetRotateMatrix;\\nuniform float u_time;\\nuniform float u_zoom;\\nuniform float u_resolution;\\n\".concat(this.uniforms.map(function (uniform) {\n      return 'uniform ' + uniform + ';';\n    }).join('\\n'), \"\\nattribute vec2 a_position;\\nattribute float a_index;\\n\").concat(attributes.map(function (attribute) {\n      return 'attribute ' + attribute + ';';\n    }).join('\\n'), \"\\nvarying vec2 v_texCoord;\\nvarying vec2 v_quadCoord;\\n\").concat(varyings.map(function (varying) {\n      return 'varying ' + varying.type + ' ' + varying.name + ';';\n    }).join('\\n'), \"\\nvoid main(void) {\\n  mat4 offsetMatrix = \").concat(offsetMatrix, \";\\n  vec2 halfSize = \").concat(this.sizeExpression, \" * 0.5;\\n  vec2 offset = \").concat(this.offsetExpression, \";\\n  float angle = \").concat(this.rotationExpression, \";\\n  float offsetX;\\n  float offsetY;\\n  if (a_index == 0.0) {\\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\\n  } else if (a_index == 1.0) {\\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\\n  } else if (a_index == 2.0) {\\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\\n  } else {\\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\\n  }\\n  vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\\n  vec4 texCoord = \").concat(this.texCoordExpression, \";\\n  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;\\n  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;\\n  v_texCoord = vec2(u, v);\\n  u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\\n  v = a_index == 2.0 || a_index == 3.0 ? 0.0 : 1.0;\\n  v_quadCoord = vec2(u, v);\\n\").concat(varyings.map(function (varying) {\n      return '  ' + varying.name + ' = ' + varying.expression + ';';\n    }).join('\\n'), \"\\n}\");\n  };\n  /**\n   * Generates a symbol fragment shader from the builder parameters,\n   * intended to be used on point geometries.\n   *\n   * Expects the following varyings to be transmitted by the vertex shader:\n   * `vec2 v_quadCoord`, `vec2 v_texCoord`\n   *\n   * @param {boolean} [forHitDetection] If true, the shader will be modified to include hit detection variables\n   * (namely, hit color with encoded feature id).\n   * @return {string} The full shader as a string.\n   */\n  ShaderBuilder.prototype.getSymbolFragmentShader = function (forHitDetection) {\n    var hitDetectionBypass = forHitDetection ? '  if (gl_FragColor.a < 0.1) { discard; } gl_FragColor = v_hitColor;' : '';\n    var varyings = this.varyings;\n    if (forHitDetection) {\n      varyings = varyings.concat({\n        name: 'v_hitColor',\n        type: 'vec4',\n        expression: 'a_hitColor'\n      });\n    }\n    return \"precision mediump float;\\nuniform float u_time;\\nuniform float u_zoom;\\nuniform float u_resolution;\\n\".concat(this.uniforms.map(function (uniform) {\n      return 'uniform ' + uniform + ';';\n    }).join('\\n'), \"\\nvarying vec2 v_texCoord;\\nvarying vec2 v_quadCoord;\\n\").concat(varyings.map(function (varying) {\n      return 'varying ' + varying.type + ' ' + varying.name + ';';\n    }).join('\\n'), \"\\nvoid main(void) {\\n  if (\").concat(this.discardExpression, \") { discard; }\\n  gl_FragColor = \").concat(this.colorExpression, \";\\n  gl_FragColor.rgb *= gl_FragColor.a;\\n\").concat(hitDetectionBypass, \"\\n}\");\n  };\n  return ShaderBuilder;\n}();\nexport { ShaderBuilder };\n/**\n * @typedef {Object} StyleParseResult\n * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style\n * @property {Object<string,import(\"./Helper\").UniformValue>} uniforms Uniform definitions.\n * @property {Array<import(\"../renderer/webgl/PointsLayer\").CustomAttribute>} attributes Attribute descriptions.\n */\n/**\n * Parses a {@link import(\"../style/literal\").LiteralStyle} object and returns a {@link ShaderBuilder}\n * object that has been configured according to the given style, as well as `attributes` and `uniforms`\n * arrays to be fed to the `WebGLPointsRenderer` class.\n *\n * Also returns `uniforms` and `attributes` properties as expected by the\n * {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n *\n * @param {import(\"../style/literal\").LiteralStyle} style Literal style.\n * @return {StyleParseResult} Result containing shader params, attributes and uniforms.\n */\nexport function parseLiteralStyle(style) {\n  var symbStyle = style.symbol;\n  var size = symbStyle.size !== undefined ? symbStyle.size : 1;\n  var color = symbStyle.color || 'white';\n  var texCoord = symbStyle.textureCoord || [0, 0, 1, 1];\n  var offset = symbStyle.offset || [0, 0];\n  var opacity = symbStyle.opacity !== undefined ? symbStyle.opacity : 1;\n  var rotation = symbStyle.rotation !== undefined ? symbStyle.rotation : 0;\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n  var vertContext = {\n    inFragmentShader: false,\n    variables: [],\n    attributes: [],\n    stringLiteralsMap: {},\n    functions: {}\n  };\n  var parsedSize = expressionToGlsl(vertContext, size, ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER);\n  var parsedOffset = expressionToGlsl(vertContext, offset, ValueTypes.NUMBER_ARRAY);\n  var parsedTexCoord = expressionToGlsl(vertContext, texCoord, ValueTypes.NUMBER_ARRAY);\n  var parsedRotation = expressionToGlsl(vertContext, rotation, ValueTypes.NUMBER);\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n  var fragContext = {\n    inFragmentShader: true,\n    variables: vertContext.variables,\n    attributes: [],\n    stringLiteralsMap: vertContext.stringLiteralsMap,\n    functions: {}\n  };\n  var parsedColor = expressionToGlsl(fragContext, color, ValueTypes.COLOR);\n  var parsedOpacity = expressionToGlsl(fragContext, opacity, ValueTypes.NUMBER);\n  var opacityFilter = '1.0';\n  var visibleSize = \"vec2(\".concat(expressionToGlsl(fragContext, size, ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER), \").x\");\n  switch (symbStyle.symbolType) {\n    case 'square':\n      break;\n    case 'image':\n      break;\n    // taken from https://thebookofshaders.com/07/\n    case 'circle':\n      opacityFilter = \"(1.0-smoothstep(1.-4./\".concat(visibleSize, \",1.,dot(v_quadCoord-.5,v_quadCoord-.5)*4.))\");\n      break;\n    case 'triangle':\n      var st = '(v_quadCoord*2.-1.)';\n      var a = \"(atan(\".concat(st, \".x,\").concat(st, \".y))\");\n      opacityFilter = \"(1.0-smoothstep(.5-3./\".concat(visibleSize, \",.5,cos(floor(.5+\").concat(a, \"/2.094395102)*2.094395102-\").concat(a, \")*length(\").concat(st, \")))\");\n      break;\n    default:\n      throw new Error('Unexpected symbol type: ' + symbStyle.symbolType);\n  }\n  var builder = new ShaderBuilder().setSizeExpression(\"vec2(\".concat(parsedSize, \")\")).setRotationExpression(parsedRotation).setSymbolOffsetExpression(parsedOffset).setTextureCoordinateExpression(parsedTexCoord).setSymbolRotateWithView(!!symbStyle.rotateWithView).setColorExpression(\"vec4(\".concat(parsedColor, \".rgb, \").concat(parsedColor, \".a * \").concat(parsedOpacity, \" * \").concat(opacityFilter, \")\"));\n  if (style.filter) {\n    var parsedFilter = expressionToGlsl(fragContext, style.filter, ValueTypes.BOOLEAN);\n    builder.setFragmentDiscardExpression(\"!\".concat(parsedFilter));\n  }\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n  var uniforms = {};\n  // define one uniform per variable\n  fragContext.variables.forEach(function (varName) {\n    var uniformName = uniformNameForVariable(varName);\n    builder.addUniform(\"float \".concat(uniformName));\n    uniforms[uniformName] = function () {\n      if (!style.variables || style.variables[varName] === undefined) {\n        throw new Error(\"The following variable is missing from the style: \".concat(varName));\n      }\n      var value = style.variables[varName];\n      if (typeof value === 'string') {\n        value = getStringNumberEquivalent(vertContext, value);\n      }\n      return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n    };\n  });\n  if (symbStyle.symbolType === 'image' && symbStyle.src) {\n    var texture = new Image();\n    texture.crossOrigin = symbStyle.crossOrigin === undefined ? 'anonymous' : symbStyle.crossOrigin;\n    texture.src = symbStyle.src;\n    builder.addUniform('sampler2D u_texture').setColorExpression(builder.getColorExpression() + ' * texture2D(u_texture, v_texCoord)');\n    uniforms['u_texture'] = texture;\n  }\n  // for each feature attribute used in the fragment shader, define a varying that will be used to pass data\n  // from the vertex to the fragment shader, as well as an attribute in the vertex shader (if not already present)\n  fragContext.attributes.forEach(function (attrName) {\n    if (vertContext.attributes.indexOf(attrName) === -1) {\n      vertContext.attributes.push(attrName);\n    }\n    builder.addVarying(\"v_\".concat(attrName), 'float', \"a_\".concat(attrName));\n  });\n  // for each feature attribute used in the vertex shader, define an attribute in the vertex shader.\n  vertContext.attributes.forEach(function (attrName) {\n    builder.addAttribute(\"float a_\".concat(attrName));\n  });\n  return {\n    builder: builder,\n    attributes: vertContext.attributes.map(function (attributeName) {\n      return {\n        name: attributeName,\n        callback: function (feature, props) {\n          var value = props[attributeName];\n          if (typeof value === 'string') {\n            value = getStringNumberEquivalent(vertContext, value);\n          }\n          return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n        }\n      };\n    }),\n    uniforms: uniforms\n  };\n}","map":{"version":3,"names":["ValueTypes","expressionToGlsl","getStringNumberEquivalent","uniformNameForVariable","ShaderBuilder","uniforms","attributes","varyings","sizeExpression","rotationExpression","offsetExpression","colorExpression","texCoordExpression","discardExpression","rotateWithView","prototype","addUniform","name","push","addAttribute","addVarying","type","expression","setSizeExpression","setRotationExpression","setSymbolOffsetExpression","setColorExpression","setTextureCoordinateExpression","setFragmentDiscardExpression","setSymbolRotateWithView","getSizeExpression","getOffsetExpression","getColorExpression","getTextureCoordinateExpression","getFragmentDiscardExpression","getSymbolVertexShader","forHitDetection","offsetMatrix","concat","map","uniform","join","attribute","varying","getSymbolFragmentShader","hitDetectionBypass","parseLiteralStyle","style","symbStyle","symbol","size","undefined","color","texCoord","textureCoord","offset","opacity","rotation","vertContext","inFragmentShader","variables","stringLiteralsMap","functions","parsedSize","NUMBER_ARRAY","NUMBER","parsedOffset","parsedTexCoord","parsedRotation","fragContext","parsedColor","COLOR","parsedOpacity","opacityFilter","visibleSize","symbolType","st","a","Error","builder","filter","parsedFilter","BOOLEAN","forEach","varName","uniformName","value","src","texture","Image","crossOrigin","attrName","indexOf","attributeName","callback","feature","props"],"sources":["../src/webgl/ShaderBuilder.js"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}
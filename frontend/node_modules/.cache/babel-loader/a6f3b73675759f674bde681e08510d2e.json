{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/source/GeoTIFF\n */\nimport DataTile from './DataTile.js';\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport { Pool, fromBlob as tiffFromBlob, fromUrl as tiffFromUrl, fromUrls as tiffFromUrls } from 'geotiff';\nimport { Projection, get as getCachedProjection, toUserCoordinate, toUserExtent } from '../proj.js';\nimport { clamp } from '../math.js';\nimport { getCenter, getIntersection } from '../extent.js';\nimport { fromCode as unitsFromCode } from '../proj/Units.js';\n/**\n * @typedef {Object} SourceInfo\n * @property {string} [url] URL for the source GeoTIFF.\n * @property {Array<string>} [overviews] List of any overview URLs, only applies if the url parameter is given.\n * @property {Blob} [blob] Blob containing the source GeoTIFF. `blob` and `url` are mutually exclusive.\n * @property {number} [min=0] The minimum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the minimum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [max] The maximum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the maximum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [nodata] Values to discard (overriding any nodata values in the metadata).\n * When provided, an additional alpha band will be added to the data.  Often the GeoTIFF metadata\n * will include information about nodata values, so you should only need to set this property if\n * you find that it is not already extracted from the metadata.\n * @property {Array<number>} [bands] Band numbers to be read from (where the first band is `1`). If not provided, all bands will\n * be read. For example, if a GeoTIFF has blue (1), green (2), red (3), and near-infrared (4) bands, and you only need the\n * near-infrared band, configure `bands: [4]`.\n */\n/**\n * @typedef {Object} GeoKeys\n * @property {number} GTModelTypeGeoKey Model type.\n * @property {number} GTRasterTypeGeoKey Raster type.\n * @property {number} GeogAngularUnitsGeoKey Angular units.\n * @property {number} GeogInvFlatteningGeoKey Inverse flattening.\n * @property {number} GeogSemiMajorAxisGeoKey Semi-major axis.\n * @property {number} GeographicTypeGeoKey Geographic coordinate system code.\n * @property {number} ProjLinearUnitsGeoKey Projected linear unit code.\n * @property {number} ProjectedCSTypeGeoKey Projected coordinate system code.\n */\n/**\n * @typedef {import(\"geotiff\").GeoTIFF} GeoTIFF\n */\n/**\n * @typedef {import(\"geotiff\").MultiGeoTIFF} MultiGeoTIFF\n */\n/**\n * @typedef {Object} GDALMetadata\n * @property {string} STATISTICS_MINIMUM The minimum value (as a string).\n * @property {string} STATISTICS_MAXIMUM The maximum value (as a string).\n */\nvar STATISTICS_MAXIMUM = 'STATISTICS_MAXIMUM';\nvar STATISTICS_MINIMUM = 'STATISTICS_MINIMUM';\n/**\n * @typedef {import(\"geotiff\").GeoTIFFImage} GeoTIFFImage\n */\nvar workerPool;\nfunction getWorkerPool() {\n  if (!workerPool) {\n    workerPool = new Pool();\n  }\n  return workerPool;\n}\n/**\n * Get the bounding box of an image.  If the image does not have an affine transform,\n * the pixel bounds are returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image bounding box.\n */\nfunction getBoundingBox(image) {\n  try {\n    return image.getBoundingBox();\n  } catch (_) {\n    var fileDirectory = image.fileDirectory;\n    return [0, 0, fileDirectory.ImageWidth, fileDirectory.ImageLength];\n  }\n}\n/**\n * Get the origin of an image.  If the image does not have an affine transform,\n * the top-left corner of the pixel bounds is returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image origin.\n */\nfunction getOrigin(image) {\n  try {\n    return image.getOrigin().slice(0, 2);\n  } catch (_) {\n    return [0, image.fileDirectory.ImageLength];\n  }\n}\n/**\n * Get the resolution of an image.  If the image does not have an affine transform,\n * the width of the image is compared with the reference image.\n * @param {GeoTIFFImage} image The image.\n * @param {GeoTIFFImage} referenceImage The reference image.\n * @return {Array<number>} The map x and y units per pixel.\n */\nfunction getResolutions(image, referenceImage) {\n  try {\n    return image.getResolution(referenceImage);\n  } catch (_) {\n    return [referenceImage.fileDirectory.ImageWidth / image.fileDirectory.ImageWidth, referenceImage.fileDirectory.ImageHeight / image.fileDirectory.ImageHeight];\n  }\n}\n/**\n * @param {GeoTIFFImage} image A GeoTIFF.\n * @return {import(\"../proj/Projection.js\").default} The image projection.\n */\nfunction getProjection(image) {\n  var geoKeys = image.geoKeys;\n  if (!geoKeys) {\n    return null;\n  }\n  if (geoKeys.ProjectedCSTypeGeoKey) {\n    var code = 'EPSG:' + geoKeys.ProjectedCSTypeGeoKey;\n    var projection = getCachedProjection(code);\n    if (!projection) {\n      var units = unitsFromCode(geoKeys.ProjLinearUnitsGeoKey);\n      if (units) {\n        projection = new Projection({\n          code: code,\n          units: units\n        });\n      }\n    }\n    return projection;\n  }\n  if (geoKeys.GeographicTypeGeoKey) {\n    var code = 'EPSG:' + geoKeys.GeographicTypeGeoKey;\n    var projection = getCachedProjection(code);\n    if (!projection) {\n      var units = unitsFromCode(geoKeys.GeogAngularUnitsGeoKey);\n      if (units) {\n        projection = new Projection({\n          code: code,\n          units: units\n        });\n      }\n    }\n    return projection;\n  }\n  return null;\n}\n/**\n * @param {GeoTIFF|MultiGeoTIFF} tiff A GeoTIFF.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\nfunction getImagesForTIFF(tiff) {\n  return tiff.getImageCount().then(function (count) {\n    var requests = new Array(count);\n    for (var i = 0; i < count; ++i) {\n      requests[i] = tiff.getImage(i);\n    }\n    return Promise.all(requests);\n  });\n}\n/**\n * @param {SourceInfo} source The GeoTIFF source.\n * @param {Object} options Options for the GeoTIFF source.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\nfunction getImagesForSource(source, options) {\n  var request;\n  if (source.blob) {\n    request = tiffFromBlob(source.blob);\n  } else if (source.overviews) {\n    request = tiffFromUrls(source.url, source.overviews, options);\n  } else {\n    request = tiffFromUrl(source.url, options);\n  }\n  return request.then(getImagesForTIFF);\n}\n/**\n * @param {number|Array<number>|Array<Array<number>>} expected Expected value.\n * @param {number|Array<number>|Array<Array<number>>} got Actual value.\n * @param {number} tolerance Accepted tolerance in fraction of expected between expected and got.\n * @param {string} message The error message.\n * @param {function(Error):void} rejector A function to be called with any error.\n */\nfunction assertEqual(expected, got, tolerance, message, rejector) {\n  if (Array.isArray(expected)) {\n    var length_1 = expected.length;\n    if (!Array.isArray(got) || length_1 != got.length) {\n      var error = new Error(message);\n      rejector(error);\n      throw error;\n    }\n    for (var i = 0; i < length_1; ++i) {\n      assertEqual(expected[i], got[i], tolerance, message, rejector);\n    }\n    return;\n  }\n  got = /** @type {number} */got;\n  if (Math.abs(expected - got) > tolerance * expected) {\n    throw new Error(message);\n  }\n}\n/**\n * @param {Array} array The data array.\n * @return {number} The minimum value.\n */\nfunction getMinForDataType(array) {\n  if (array instanceof Int8Array) {\n    return -128;\n  }\n  if (array instanceof Int16Array) {\n    return -32768;\n  }\n  if (array instanceof Int32Array) {\n    return -2147483648;\n  }\n  if (array instanceof Float32Array) {\n    return 1.2e-38;\n  }\n  return 0;\n}\n/**\n * @param {Array} array The data array.\n * @return {number} The maximum value.\n */\nfunction getMaxForDataType(array) {\n  if (array instanceof Int8Array) {\n    return 127;\n  }\n  if (array instanceof Uint8Array) {\n    return 255;\n  }\n  if (array instanceof Uint8ClampedArray) {\n    return 255;\n  }\n  if (array instanceof Int16Array) {\n    return 32767;\n  }\n  if (array instanceof Uint16Array) {\n    return 65535;\n  }\n  if (array instanceof Int32Array) {\n    return 2147483647;\n  }\n  if (array instanceof Uint32Array) {\n    return 4294967295;\n  }\n  if (array instanceof Float32Array) {\n    return 3.4e38;\n  }\n  return 255;\n}\n/**\n * @typedef {Object} GeoTIFFSourceOptions\n * @property {boolean} [forceXHR=false] Whether to force the usage of the browsers XMLHttpRequest API.\n * @property {Object<string, string>} [headers] additional key-value pairs of headers to be passed with each request. Key is the header name, value the header value.\n * @property {string} [credentials] How credentials shall be handled. See\n * https://developer.mozilla.org/en-US/docs/Web/API/fetch for reference and possible values\n * @property {number} [maxRanges] The maximum amount of ranges to request in a single multi-range request.\n * By default only a single range is used.\n * @property {boolean} [allowFullFile=false] Whether or not a full file is accepted when only a portion is\n * requested. Only use this when you know the source image to be small enough to fit in memory.\n * @property {number} [blockSize=65536] The block size to use.\n * @property {number} [cacheSize=100] The number of blocks that shall be held in a LRU cache.\n */\n/**\n * @typedef {Object} Options\n * @property {Array<SourceInfo>} sources List of information about GeoTIFF sources.\n * Multiple sources can be combined when their resolution sets are equal after applying a scale.\n * The list of sources defines a mapping between input bands as they are read from each GeoTIFF and\n * the output bands that are provided by data tiles. To control which bands to read from each GeoTIFF,\n * use the {@link import(\"./GeoTIFF.js\").SourceInfo bands} property. If, for example, you specify two\n * sources, one with 3 bands and {@link import(\"./GeoTIFF.js\").SourceInfo nodata} configured, and\n * another with 1 band, the resulting data tiles will have 5 bands: 3 from the first source, 1 alpha\n * band from the first source, and 1 band from the second source.\n * @property {GeoTIFFSourceOptions} [sourceOptions] Additional options to be passed to [geotiff.js](https://geotiffjs.github.io/geotiff.js/module-geotiff.html)'s `fromUrl` or `fromUrls` methods.\n * @property {boolean} [convertToRGB = false] By default, bands from the sources are read as-is. When\n * reading GeoTIFFs with the purpose of displaying them as RGB images, setting this to `true` will\n * convert other color spaces (YCbCr, CMYK) to RGB.\n * @property {boolean} [normalize=true] By default, the source data is normalized to values between\n * 0 and 1 with scaling factors based on the raster statistics or `min` and `max` properties of each source.\n * If instead you want to work with the raw values in a style expression, set this to `false`.  Setting this option\n * to `false` will make it so any `min` and `max` properties on sources are ignored.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {boolean} [wrapX=false] Render tiles beyond the tile grid extent.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * the linear interpolation is used to resample the data.  If false, nearest neighbor is used.\n */\n/**\n * @classdesc\n * A source for working with GeoTIFF data.\n * @api\n */\nvar GeoTIFFSource = /** @class */function (_super) {\n  __extends(GeoTIFFSource, _super);\n  /**\n   * @param {Options} options Data tile options.\n   */\n  function GeoTIFFSource(options) {\n    var _this = _super.call(this, {\n      state: 'loading',\n      tileGrid: null,\n      projection: null,\n      opaque: options.opaque,\n      transition: options.transition,\n      interpolate: options.interpolate !== false,\n      wrapX: options.wrapX\n    }) || this;\n    /**\n     * @type {Array<SourceInfo>}\n     * @private\n     */\n    _this.sourceInfo_ = options.sources;\n    var numSources = _this.sourceInfo_.length;\n    /**\n     * @type {Object}\n     * @private\n     */\n    _this.sourceOptions_ = options.sourceOptions;\n    /**\n     * @type {Array<Array<GeoTIFFImage>>}\n     * @private\n     */\n    _this.sourceImagery_ = new Array(numSources);\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    _this.resolutionFactors_ = new Array(numSources);\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    _this.samplesPerPixel_;\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n    _this.nodataValues_;\n    /**\n     * @type {Array<Array<GDALMetadata>>}\n     * @private\n     */\n    _this.metadata_;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    _this.normalize_ = options.normalize !== false;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    _this.addAlpha_ = false;\n    /**\n     * @type {Error}\n     * @private\n     */\n    _this.error_ = null;\n    /**\n     * @type {'readRasters' | 'readRGB'}\n     */\n    _this.readMethod_ = options.convertToRGB ? 'readRGB' : 'readRasters';\n    _this.setKey(_this.sourceInfo_.map(function (source) {\n      return source.url;\n    }).join(','));\n    var self = _this;\n    var requests = new Array(numSources);\n    for (var i = 0; i < numSources; ++i) {\n      requests[i] = getImagesForSource(_this.sourceInfo_[i], _this.sourceOptions_);\n    }\n    Promise.all(requests).then(function (sources) {\n      self.configure_(sources);\n    }).catch(function (error) {\n      console.error(error); // eslint-disable-line no-console\n      self.error_ = error;\n      self.setState('error');\n    });\n    return _this;\n  }\n  /**\n   * @return {Error} A source loading error. When the source state is `error`, use this function\n   * to get more information about the error. To debug a faulty configuration, you may want to use\n   * a listener like\n   * ```js\n   * geotiffSource.on('change', () => {\n   *   if (geotiffSource.getState() === 'error') {\n   *     console.error(geotiffSource.getError());\n   *   }\n   * });\n   * ```\n   */\n  GeoTIFFSource.prototype.getError = function () {\n    return this.error_;\n  };\n  /**\n   * Configure the tile grid based on images within the source GeoTIFFs.  Each GeoTIFF\n   * must have the same internal tiled structure.\n   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n   * from a single GeoTIFF.\n   * @private\n   */\n  GeoTIFFSource.prototype.configure_ = function (sources) {\n    var extent;\n    var origin;\n    var commonRenderTileSizes;\n    var commonSourceTileSizes;\n    var resolutions;\n    var samplesPerPixel = new Array(sources.length);\n    var nodataValues = new Array(sources.length);\n    var metadata = new Array(sources.length);\n    var minZoom = 0;\n    var sourceCount = sources.length;\n    var _loop_1 = function (sourceIndex) {\n      var images = sources[sourceIndex];\n      var imageCount = images.length;\n      var sourceExtent = void 0;\n      var sourceOrigin = void 0;\n      var sourceTileSizes = new Array(imageCount);\n      var renderTileSizes = new Array(imageCount);\n      var sourceResolutions = new Array(imageCount);\n      nodataValues[sourceIndex] = new Array(imageCount);\n      metadata[sourceIndex] = new Array(imageCount);\n      for (var imageIndex = 0; imageIndex < imageCount; ++imageIndex) {\n        var image = images[imageIndex];\n        var nodataValue = image.getGDALNoData();\n        metadata[sourceIndex][imageIndex] = image.getGDALMetadata(0);\n        nodataValues[sourceIndex][imageIndex] = nodataValue;\n        var wantedSamples = this_1.sourceInfo_[sourceIndex].bands;\n        samplesPerPixel[sourceIndex] = wantedSamples ? wantedSamples.length : image.getSamplesPerPixel();\n        var level = imageCount - (imageIndex + 1);\n        if (!sourceExtent) {\n          sourceExtent = getBoundingBox(image);\n        }\n        if (!sourceOrigin) {\n          sourceOrigin = getOrigin(image);\n        }\n        var imageResolutions = getResolutions(image, images[0]);\n        sourceResolutions[level] = imageResolutions[0];\n        var sourceTileSize = [image.getTileWidth(), image.getTileHeight()];\n        sourceTileSizes[level] = sourceTileSize;\n        var aspectRatio = imageResolutions[0] / Math.abs(imageResolutions[1]);\n        renderTileSizes[level] = [sourceTileSize[0], sourceTileSize[1] / aspectRatio];\n      }\n      if (!extent) {\n        extent = sourceExtent;\n      } else {\n        getIntersection(extent, sourceExtent, extent);\n      }\n      if (!origin) {\n        origin = sourceOrigin;\n      } else {\n        var message = \"Origin mismatch for source \".concat(sourceIndex, \", got [\").concat(sourceOrigin, \"] but expected [\").concat(origin, \"]\");\n        assertEqual(origin, sourceOrigin, 0, message, this_1.viewRejector);\n      }\n      if (!resolutions) {\n        resolutions = sourceResolutions;\n        this_1.resolutionFactors_[sourceIndex] = 1;\n      } else {\n        if (resolutions.length - minZoom > sourceResolutions.length) {\n          minZoom = resolutions.length - sourceResolutions.length;\n        }\n        var resolutionFactor_1 = resolutions[resolutions.length - 1] / sourceResolutions[sourceResolutions.length - 1];\n        this_1.resolutionFactors_[sourceIndex] = resolutionFactor_1;\n        var scaledSourceResolutions = sourceResolutions.map(function (resolution) {\n          return resolution *= resolutionFactor_1;\n        });\n        var message = \"Resolution mismatch for source \".concat(sourceIndex, \", got [\").concat(scaledSourceResolutions, \"] but expected [\").concat(resolutions, \"]\");\n        assertEqual(resolutions.slice(minZoom, resolutions.length), scaledSourceResolutions, 0.02, message, this_1.viewRejector);\n      }\n      if (!commonRenderTileSizes) {\n        commonRenderTileSizes = renderTileSizes;\n      } else {\n        assertEqual(commonRenderTileSizes.slice(minZoom, commonRenderTileSizes.length), renderTileSizes, 0.01, \"Tile size mismatch for source \".concat(sourceIndex), this_1.viewRejector);\n      }\n      if (!commonSourceTileSizes) {\n        commonSourceTileSizes = sourceTileSizes;\n      } else {\n        assertEqual(commonSourceTileSizes.slice(minZoom, commonSourceTileSizes.length), sourceTileSizes, 0, \"Tile size mismatch for source \".concat(sourceIndex), this_1.viewRejector);\n      }\n      this_1.sourceImagery_[sourceIndex] = images.reverse();\n    };\n    var this_1 = this;\n    for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      _loop_1(sourceIndex);\n    }\n    for (var i = 0, ii = this.sourceImagery_.length; i < ii; ++i) {\n      var sourceImagery = this.sourceImagery_[i];\n      while (sourceImagery.length < resolutions.length) {\n        sourceImagery.unshift(undefined);\n      }\n    }\n    if (!this.getProjection()) {\n      var firstSource = sources[0];\n      for (var i = firstSource.length - 1; i >= 0; --i) {\n        var image = firstSource[i];\n        var projection = getProjection(image);\n        if (projection) {\n          this.projection = projection;\n          break;\n        }\n      }\n    }\n    this.samplesPerPixel_ = samplesPerPixel;\n    this.nodataValues_ = nodataValues;\n    this.metadata_ = metadata;\n    // decide if we need to add an alpha band to handle nodata\n    outer: for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      // option 1: source is configured with a nodata value\n      if (this.sourceInfo_[sourceIndex].nodata !== undefined) {\n        this.addAlpha_ = true;\n        break;\n      }\n      var values = nodataValues[sourceIndex];\n      // option 2: check image metadata for limited bands\n      var bands = this.sourceInfo_[sourceIndex].bands;\n      if (bands) {\n        for (var i = 0; i < bands.length; ++i) {\n          if (values[bands[i] - 1] !== null) {\n            this.addAlpha_ = true;\n            break outer;\n          }\n        }\n        continue;\n      }\n      // option 3: check image metadata for all bands\n      for (var imageIndex = 0; imageIndex < values.length; ++imageIndex) {\n        if (values[imageIndex] !== null) {\n          this.addAlpha_ = true;\n          break outer;\n        }\n      }\n    }\n    var additionalBands = this.addAlpha_ ? 1 : 0;\n    this.bandCount = samplesPerPixel.reduce(function (accumulator, value) {\n      accumulator += value;\n      return accumulator;\n    }, 0) + additionalBands;\n    var tileGrid = new TileGrid({\n      extent: extent,\n      minZoom: minZoom,\n      origin: origin,\n      resolutions: resolutions,\n      tileSizes: commonRenderTileSizes\n    });\n    this.tileGrid = tileGrid;\n    this.setTileSizes(commonSourceTileSizes);\n    this.setLoader(this.loadTile_.bind(this));\n    this.setState('ready');\n    this.viewResolver({\n      projection: this.projection,\n      resolutions: resolutions,\n      center: toUserCoordinate(getCenter(extent), this.projection),\n      extent: toUserExtent(extent, this.projection),\n      zoom: 0\n    });\n  };\n  GeoTIFFSource.prototype.loadTile_ = function (z, x, y) {\n    var sourceTileSize = this.getTileSize(z);\n    var sourceCount = this.sourceImagery_.length;\n    var requests = new Array(sourceCount);\n    var addAlpha = this.addAlpha_;\n    var bandCount = this.bandCount;\n    var samplesPerPixel = this.samplesPerPixel_;\n    var nodataValues = this.nodataValues_;\n    var sourceInfo = this.sourceInfo_;\n    var _loop_2 = function (sourceIndex) {\n      var source = sourceInfo[sourceIndex];\n      var resolutionFactor = this_2.resolutionFactors_[sourceIndex];\n      var pixelBounds = [Math.round(x * (sourceTileSize[0] * resolutionFactor)), Math.round(y * (sourceTileSize[1] * resolutionFactor)), Math.round((x + 1) * (sourceTileSize[0] * resolutionFactor)), Math.round((y + 1) * (sourceTileSize[1] * resolutionFactor))];\n      var image = this_2.sourceImagery_[sourceIndex][z];\n      var samples = void 0;\n      if (source.bands) {\n        samples = source.bands.map(function (bandNumber) {\n          return bandNumber - 1;\n        });\n      }\n      /** @type {number|Array<number>} */\n      var fillValue = void 0;\n      if ('nodata' in source && source.nodata !== null) {\n        fillValue = source.nodata;\n      } else {\n        if (!samples) {\n          fillValue = nodataValues[sourceIndex];\n        } else {\n          fillValue = samples.map(function (sampleIndex) {\n            return nodataValues[sourceIndex][sampleIndex];\n          });\n        }\n      }\n      requests[sourceIndex] = image[this_2.readMethod_]({\n        window: pixelBounds,\n        width: sourceTileSize[0],\n        height: sourceTileSize[1],\n        samples: samples,\n        fillValue: fillValue,\n        pool: getWorkerPool(),\n        interleave: false\n      });\n    };\n    var this_2 = this;\n    for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      _loop_2(sourceIndex);\n    }\n    var pixelCount = sourceTileSize[0] * sourceTileSize[1];\n    var dataLength = pixelCount * bandCount;\n    var normalize = this.normalize_;\n    var metadata = this.metadata_;\n    return Promise.all(requests).then(function (sourceSamples) {\n      /** @type {Uint8Array|Float32Array} */\n      var data;\n      if (normalize) {\n        data = new Uint8Array(dataLength);\n      } else {\n        data = new Float32Array(dataLength);\n      }\n      var dataIndex = 0;\n      for (var pixelIndex = 0; pixelIndex < pixelCount; ++pixelIndex) {\n        var transparent = addAlpha;\n        for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n          var source = sourceInfo[sourceIndex];\n          var min = source.min;\n          var max = source.max;\n          var gain = void 0,\n            bias = void 0;\n          if (normalize) {\n            var stats = metadata[sourceIndex][0];\n            if (min === undefined) {\n              if (stats && STATISTICS_MINIMUM in stats) {\n                min = parseFloat(stats[STATISTICS_MINIMUM]);\n              } else {\n                min = getMinForDataType(sourceSamples[sourceIndex][0]);\n              }\n            }\n            if (max === undefined) {\n              if (stats && STATISTICS_MAXIMUM in stats) {\n                max = parseFloat(stats[STATISTICS_MAXIMUM]);\n              } else {\n                max = getMaxForDataType(sourceSamples[sourceIndex][0]);\n              }\n            }\n            gain = 255 / (max - min);\n            bias = -min * gain;\n          }\n          for (var sampleIndex = 0; sampleIndex < samplesPerPixel[sourceIndex]; ++sampleIndex) {\n            var sourceValue = sourceSamples[sourceIndex][sampleIndex][pixelIndex];\n            var value = void 0;\n            if (normalize) {\n              value = clamp(gain * sourceValue + bias, 0, 255);\n            } else {\n              value = sourceValue;\n            }\n            if (!addAlpha) {\n              data[dataIndex] = value;\n            } else {\n              var nodata = source.nodata;\n              if (nodata === undefined) {\n                var bandIndex = void 0;\n                if (source.bands) {\n                  bandIndex = source.bands[sampleIndex] - 1;\n                } else {\n                  bandIndex = sampleIndex;\n                }\n                nodata = nodataValues[sourceIndex][bandIndex];\n              }\n              var nodataIsNaN = isNaN(nodata);\n              if (!nodataIsNaN && sourceValue !== nodata || nodataIsNaN && !isNaN(sourceValue)) {\n                transparent = false;\n                data[dataIndex] = value;\n              }\n            }\n            dataIndex++;\n          }\n        }\n        if (addAlpha) {\n          if (!transparent) {\n            data[dataIndex] = 255;\n          }\n          dataIndex++;\n        }\n      }\n      return data;\n    }).catch(function (error) {\n      // output then rethrow\n      console.error(error); // eslint-disable-line no-console\n      throw error;\n    });\n  };\n  return GeoTIFFSource;\n}(DataTile);\n/**\n * Get a promise for view properties based on the source.  Use the result of this function\n * as the `view` option in a map constructor.\n *\n *     const source = new GeoTIFF(options);\n *\n *     const map = new Map({\n *       target: 'map',\n *       layers: [\n *         new TileLayer({\n *           source: source,\n *         }),\n *       ],\n *       view: source.getView(),\n *     });\n *\n * @function\n * @return {Promise<import(\"../View.js\").ViewOptions>} A promise for view-related properties.\n * @api\n *\n */\nGeoTIFFSource.prototype.getView;\nexport default GeoTIFFSource;","map":{"version":3,"names":["DataTile","TileGrid","Pool","fromBlob","tiffFromBlob","fromUrl","tiffFromUrl","fromUrls","tiffFromUrls","Projection","get","getCachedProjection","toUserCoordinate","toUserExtent","clamp","getCenter","getIntersection","fromCode","unitsFromCode","STATISTICS_MAXIMUM","STATISTICS_MINIMUM","workerPool","getWorkerPool","getBoundingBox","image","_","fileDirectory","ImageWidth","ImageLength","getOrigin","slice","getResolutions","referenceImage","getResolution","ImageHeight","getProjection","geoKeys","ProjectedCSTypeGeoKey","code","projection","units","ProjLinearUnitsGeoKey","GeographicTypeGeoKey","GeogAngularUnitsGeoKey","getImagesForTIFF","tiff","getImageCount","then","count","requests","Array","i","getImage","Promise","all","getImagesForSource","source","options","request","blob","overviews","url","assertEqual","expected","got","tolerance","message","rejector","isArray","length_1","length","error","Error","Math","abs","getMinForDataType","array","Int8Array","Int16Array","Int32Array","Float32Array","getMaxForDataType","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","GeoTIFFSource","_super","__extends","_this","call","state","tileGrid","opaque","transition","interpolate","wrapX","sourceInfo_","sources","numSources","sourceOptions_","sourceOptions","sourceImagery_","resolutionFactors_","samplesPerPixel_","nodataValues_","metadata_","normalize_","normalize","addAlpha_","error_","readMethod_","convertToRGB","setKey","map","join","self","configure_","catch","console","setState","prototype","getError","extent","origin","commonRenderTileSizes","commonSourceTileSizes","resolutions","samplesPerPixel","nodataValues","metadata","minZoom","sourceCount","sourceIndex","images","imageCount","sourceExtent","sourceOrigin","sourceTileSizes","renderTileSizes","sourceResolutions","imageIndex","nodataValue","getGDALNoData","getGDALMetadata","wantedSamples","this_1","bands","getSamplesPerPixel","level","imageResolutions","sourceTileSize","getTileWidth","getTileHeight","aspectRatio","concat","viewRejector","resolutionFactor_1","scaledSourceResolutions","resolution","reverse","ii","sourceImagery","unshift","undefined","firstSource","outer","nodata","values","additionalBands","bandCount","reduce","accumulator","value","tileSizes","setTileSizes","setLoader","loadTile_","bind","viewResolver","center","zoom","z","x","y","getTileSize","addAlpha","sourceInfo","resolutionFactor","this_2","pixelBounds","round","samples","bandNumber","fillValue","sampleIndex","window","width","height","pool","interleave","pixelCount","dataLength","sourceSamples","data","dataIndex","pixelIndex","transparent","min","max","gain","bias","stats","parseFloat","sourceValue","bandIndex","nodataIsNaN","isNaN","getView"],"sources":["../src/source/GeoTIFF.js"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}